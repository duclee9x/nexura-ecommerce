// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v4.24.4
// source: nexura.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "nexuraTelemetry";

/** Service names for health checks */
export enum ServiceName {
  UNSPECIFIED = 0,
  CART_SERVICE = 1,
  USER_SERVICE = 2,
  PRODUCT_CATALOG_SERVICE = 3,
  RECOMMENDATION_SERVICE = 4,
  SHIPPING_SERVICE = 5,
  CURRENCY_SERVICE = 6,
  PAYMENT_SERVICE = 7,
  EMAIL_SERVICE = 8,
  CHECKOUT_SERVICE = 9,
  AD_SERVICE = 10,
  FEATURE_FLAG_SERVICE = 11,
  ADDRESS_SERVICE = 12,
  UNRECOGNIZED = -1,
}

export function serviceNameFromJSON(object: any): ServiceName {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ServiceName.UNSPECIFIED;
    case 1:
    case "CART_SERVICE":
      return ServiceName.CART_SERVICE;
    case 2:
    case "USER_SERVICE":
      return ServiceName.USER_SERVICE;
    case 3:
    case "PRODUCT_CATALOG_SERVICE":
      return ServiceName.PRODUCT_CATALOG_SERVICE;
    case 4:
    case "RECOMMENDATION_SERVICE":
      return ServiceName.RECOMMENDATION_SERVICE;
    case 5:
    case "SHIPPING_SERVICE":
      return ServiceName.SHIPPING_SERVICE;
    case 6:
    case "CURRENCY_SERVICE":
      return ServiceName.CURRENCY_SERVICE;
    case 7:
    case "PAYMENT_SERVICE":
      return ServiceName.PAYMENT_SERVICE;
    case 8:
    case "EMAIL_SERVICE":
      return ServiceName.EMAIL_SERVICE;
    case 9:
    case "CHECKOUT_SERVICE":
      return ServiceName.CHECKOUT_SERVICE;
    case 10:
    case "AD_SERVICE":
      return ServiceName.AD_SERVICE;
    case 11:
    case "FEATURE_FLAG_SERVICE":
      return ServiceName.FEATURE_FLAG_SERVICE;
    case 12:
    case "ADDRESS_SERVICE":
      return ServiceName.ADDRESS_SERVICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceName.UNRECOGNIZED;
  }
}

export function serviceNameToJSON(object: ServiceName): string {
  switch (object) {
    case ServiceName.UNSPECIFIED:
      return "UNSPECIFIED";
    case ServiceName.CART_SERVICE:
      return "CART_SERVICE";
    case ServiceName.USER_SERVICE:
      return "USER_SERVICE";
    case ServiceName.PRODUCT_CATALOG_SERVICE:
      return "PRODUCT_CATALOG_SERVICE";
    case ServiceName.RECOMMENDATION_SERVICE:
      return "RECOMMENDATION_SERVICE";
    case ServiceName.SHIPPING_SERVICE:
      return "SHIPPING_SERVICE";
    case ServiceName.CURRENCY_SERVICE:
      return "CURRENCY_SERVICE";
    case ServiceName.PAYMENT_SERVICE:
      return "PAYMENT_SERVICE";
    case ServiceName.EMAIL_SERVICE:
      return "EMAIL_SERVICE";
    case ServiceName.CHECKOUT_SERVICE:
      return "CHECKOUT_SERVICE";
    case ServiceName.AD_SERVICE:
      return "AD_SERVICE";
    case ServiceName.FEATURE_FLAG_SERVICE:
      return "FEATURE_FLAG_SERVICE";
    case ServiceName.ADDRESS_SERVICE:
      return "ADDRESS_SERVICE";
    case ServiceName.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderStatus {
  ORDER_PENDING = 0,
  ORDER_PROCESSING = 1,
  ORDER_COMPLETED = 2,
  ORDER_FAILED = 3,
  ORDER_CANCELLED = 4,
  ORDER_COMPENSATING = 5,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_PENDING":
      return OrderStatus.ORDER_PENDING;
    case 1:
    case "ORDER_PROCESSING":
      return OrderStatus.ORDER_PROCESSING;
    case 2:
    case "ORDER_COMPLETED":
      return OrderStatus.ORDER_COMPLETED;
    case 3:
    case "ORDER_FAILED":
      return OrderStatus.ORDER_FAILED;
    case 4:
    case "ORDER_CANCELLED":
      return OrderStatus.ORDER_CANCELLED;
    case 5:
    case "ORDER_COMPENSATING":
      return OrderStatus.ORDER_COMPENSATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_PENDING:
      return "ORDER_PENDING";
    case OrderStatus.ORDER_PROCESSING:
      return "ORDER_PROCESSING";
    case OrderStatus.ORDER_COMPLETED:
      return "ORDER_COMPLETED";
    case OrderStatus.ORDER_FAILED:
      return "ORDER_FAILED";
    case OrderStatus.ORDER_CANCELLED:
      return "ORDER_CANCELLED";
    case OrderStatus.ORDER_COMPENSATING:
      return "ORDER_COMPENSATING";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StepStatus {
  STEP_PENDING = 0,
  STEP_STARTED = 1,
  STEP_COMPLETED = 2,
  STEP_FAILED = 3,
  STEP_COMPENSATED = 4,
  UNRECOGNIZED = -1,
}

export function stepStatusFromJSON(object: any): StepStatus {
  switch (object) {
    case 0:
    case "STEP_PENDING":
      return StepStatus.STEP_PENDING;
    case 1:
    case "STEP_STARTED":
      return StepStatus.STEP_STARTED;
    case 2:
    case "STEP_COMPLETED":
      return StepStatus.STEP_COMPLETED;
    case 3:
    case "STEP_FAILED":
      return StepStatus.STEP_FAILED;
    case 4:
    case "STEP_COMPENSATED":
      return StepStatus.STEP_COMPENSATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StepStatus.UNRECOGNIZED;
  }
}

export function stepStatusToJSON(object: StepStatus): string {
  switch (object) {
    case StepStatus.STEP_PENDING:
      return "STEP_PENDING";
    case StepStatus.STEP_STARTED:
      return "STEP_STARTED";
    case StepStatus.STEP_COMPLETED:
      return "STEP_COMPLETED";
    case StepStatus.STEP_FAILED:
      return "STEP_FAILED";
    case StepStatus.STEP_COMPENSATED:
      return "STEP_COMPENSATED";
    case StepStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentProvider {
  STRIPE = 0,
  PAYPAL = 1,
  VNPAY = 2,
  UNRECOGNIZED = -1,
}

export function paymentProviderFromJSON(object: any): PaymentProvider {
  switch (object) {
    case 0:
    case "STRIPE":
      return PaymentProvider.STRIPE;
    case 1:
    case "PAYPAL":
      return PaymentProvider.PAYPAL;
    case 2:
    case "VNPAY":
      return PaymentProvider.VNPAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentProvider.UNRECOGNIZED;
  }
}

export function paymentProviderToJSON(object: PaymentProvider): string {
  switch (object) {
    case PaymentProvider.STRIPE:
      return "STRIPE";
    case PaymentProvider.PAYPAL:
      return "PAYPAL";
    case PaymentProvider.VNPAY:
      return "VNPAY";
    case PaymentProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentStatus {
  PENDING = 0,
  PAID = 1,
  FAILED = 2,
  CANCELLED = 3,
  REFUNDED = 4,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PENDING":
      return PaymentStatus.PENDING;
    case 1:
    case "PAID":
      return PaymentStatus.PAID;
    case 2:
    case "FAILED":
      return PaymentStatus.FAILED;
    case 3:
    case "CANCELLED":
      return PaymentStatus.CANCELLED;
    case 4:
    case "REFUNDED":
      return PaymentStatus.REFUNDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PENDING:
      return "PENDING";
    case PaymentStatus.PAID:
      return "PAID";
    case PaymentStatus.FAILED:
      return "FAILED";
    case PaymentStatus.CANCELLED:
      return "CANCELLED";
    case PaymentStatus.REFUNDED:
      return "REFUNDED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetAddressesRequest {
  userId: string;
}

export interface GetAddressesResponse {
  success: boolean;
  message: string;
  addresses: ExtendedAddress[];
}

export interface GetCountriesResponse {
  success: boolean;
  message: string;
  countries: Country[];
}

export interface GetProvincesByCountryRequest {
  countryId: string;
}

export interface GetProvincesResponse {
  success: boolean;
  message: string;
  provinces: Province[];
}

export interface GetDistrictsByProvinceRequest {
  provinceId: string;
}

export interface GetDistrictsResponse {
  success: boolean;
  message: string;
  districts: District[];
}

export interface GetWardsByDistrictRequest {
  districtId: string;
}

export interface GetWardsResponse {
  success: boolean;
  message: string;
  wards: Ward[];
}

export interface AddAddressRequest {
  userId: string;
  address: Address | undefined;
}

export interface UpdateAddressRequest {
  userId: string;
  address: ExtendedAddress | undefined;
}

export interface DeleteAddressRequest {
  userId: string;
  addressId: string;
}

export interface AddressResponse {
  success: boolean;
  message: string;
  address: Address | undefined;
}

export interface DeleteAddressResponse {
  success: boolean;
  message: string;
}

export interface Country {
  id: string;
  name: string;
  codeName: string;
}

export interface Province {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  administrativeUnitId: string;
  administrativeRegionId: string;
  countryId: string;
}

export interface District {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  provinceId: string;
  administrativeUnitId: string;
}

export interface Ward {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  districtId: string;
  administrativeUnitId: string;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success: boolean;
  message: string;
}

export interface ValidateOTPRequest {
  email: string;
  otp: string;
}

export interface ValidateOTPResponse {
  success: boolean;
  message: string;
}

export interface ResetPasswordRequest {
  email: string;
  newPassword: string;
}

export interface ResetPasswordResponse {
  success: boolean;
  message: string;
}

export interface GetUserRequest {
  id: string;
}

export interface UpdateUserResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface GetUserResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface DeleteUserRequest {
  id: string;
}

export interface UpdateUserRequest {
  id: string;
  user: User | undefined;
  currentPassword: string;
  newPassword: string;
}

export interface RegisterUserRequest {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

export interface RegisterUserResponse {
  success: boolean;
  message: string;
}

export interface LoginUserRequest {
  email: string;
  password: string;
}

export interface LoginUserResponse {
  success: boolean;
  message: string;
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
}

export interface User {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  createdAt: string;
  dateOfBirth: string;
  gender: string;
  updatedAt: string;
  isActive: boolean;
  isVerified: boolean;
  role: string;
  lastLogin: string;
  permissions: string;
  profilePictureUrl: string;
}

export interface ExtendedAddress {
  id: string;
  name: string;
  street: string;
  city: string;
  state: string;
  countryId: string;
  countryName: string;
  zip: string;
  vnProvinceId: string;
  vnProvinceName: string;
  vnDistrictId: string;
  vnDistrictName: string;
  vnWardId: string;
  vnWardName: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface Address {
  id: string;
  name: string;
  street: string;
  city: string;
  state: string;
  countryId: string;
  zip: string;
  vnProvinceId: string;
  vnDistrictId: string;
  vnWardId: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface DeleteUserResponse {
  success: boolean;
  message: string;
}

export interface VerifyAccountRequest {
  token: string;
}

export interface VerifyAccountResponse {
  success: boolean;
  message: string;
}

export interface GetCartRequest {
  userId: string;
}

export interface GetCartResponse {
  cart: Cart | undefined;
}

export interface AddItemRequest {
  userId: string;
  productId: string;
  variantId: string;
  quantity: number;
  image: string;
  currencyCode: string;
}

export interface AddItemResponse {
  cart: Cart | undefined;
}

export interface UpdateItemRequest {
  userId: string;
  productId: string;
  variantId: string;
  quantity: number;
  image: string;
}

export interface UpdateItemResponse {
  cart: Cart | undefined;
}

export interface RemoveItemRequest {
  userId: string;
  productId: string;
  variantId: string;
}

export interface RemoveItemResponse {
  cart: Cart | undefined;
}

export interface ClearCartRequest {
  userId: string;
}

export interface ClearCartResponse {
  success: boolean;
}

export interface Cart {
  id: string;
  userId: string;
  items: CartItem[];
  createdAt: string;
  updatedAt: string;
  currencyCode: string;
}

export interface CartItem {
  id: string;
  productId: string;
  variantId: string;
  image: string;
  quantity: number;
  createdAt: string;
  updatedAt: string;
}

export interface ValidateCartRequest {
  userId: string;
}

export interface ValidateCartResponse {
  valid: boolean;
  message: string;
  items: CartItem[];
  issues: string[];
}

export interface ListRecommendationsRequest {
  userId: string;
  productIds: string[];
}

export interface ListRecommendationsResponse {
  productIds: string[];
}

/** ---------------Product Catalog---------------- */
export interface Empty {
}

export interface GetVariantsForCartRequest {
  variantIds: string[];
}

export interface GetVariantsForCartResponse {
  variants: VariantCart[];
}

export interface VariantCart {
  id: string;
  price: number;
  image: string;
  stock?: Stock | undefined;
  variantName: string;
  productName: string;
  productSlug: string;
  attributes: VariantAttribute[];
}

export interface GetProductAttributesRequest {
  productId: string;
}

export interface GetProductAttributesResponse {
  attributes: ProductAttribute[];
}

export interface UpdateProductAttributesRequest {
  attribute: ProductAttribute | undefined;
}

export interface UpdateProductAttributesResponse {
  attribute: ProductAttribute | undefined;
}

export interface DeleteProductAttributesRequest {
  attributeId: string;
}

export interface DeleteProductAttributesResponse {
  attributeId: string;
}

export interface CreateProductAttributeRequest {
  attribute: ProductAttribute | undefined;
}

export interface CreateProductAttributeResponse {
  attribute: ProductAttribute | undefined;
}

export interface ProductAttribute {
  id: string;
  name: string;
  required: boolean;
  visible: boolean;
  values: string[];
  productId: string;
  variantable: boolean;
  filterable: boolean;
  searchable: boolean;
  displayOrder: number;
}

export interface Product {
  id: string;
  name: string;
  slug: string;
  description: string;
  costPrice: number;
  basePrice: number;
  sku: string;
  barcode: string;
  brandId: string;
  featured: boolean;
  status: string;
  createdAt: string;
  updatedAt: string;
  seo: Seo | undefined;
  taxable: boolean;
  shippable: boolean;
  categories: string[];
  productTags: ProductTag[];
  images: Image[];
  attributes: ProductAttribute[];
  variants: ProductVariant[];
  dimensions: Dimensions | undefined;
  sizeCharts: SizeChart[];
}

export interface SizeChart {
  id: string;
  name: string;
  category: string;
  description?: string | undefined;
  productId: string;
  columns: SizeChartColumn[];
  rows: SizeChartRow[];
  images: SizeChartImage[];
  createdAt: string;
  updatedAt: string;
}

export interface SizeChartColumn {
  id: string;
  name: string;
  type: string;
  unit?: string | undefined;
  sizeChartId: string;
  createdAt: string;
}

export interface SizeChartRow {
  id: string;
  name: string;
  cells: SizeChartCell[];
}

export interface SizeChartCell {
  id: string;
  value: string;
}

export interface SizeChartImage {
  id: string;
  url: string;
  name: string;
  sizeChartId: string;
  createdAt: string;
}

export interface ProductTag {
  id: string;
  tag: Tag | undefined;
  productId: string;
}

export interface Tag {
  id: string;
  name: string;
  createdAt: string;
  updatedAt: string;
}

export interface Dimensions {
  length: number;
  width: number;
  height: number;
  weight: number;
}

export interface Seo {
  title: string;
  description: string;
  keywords: string;
}

export interface ProductVariant {
  id: string;
  sku: string;
  price: number;
  lowStockThreshold: number;
  stock: Stock | undefined;
  warehouseId: string;
  imageIds: string[];
  attributes: VariantAttribute[];
}

export interface Stock {
  quantity: number;
  reserved: number;
}

export interface VariantAttribute {
  id: string;
  name: string;
  value: string;
  extraValue: string;
}

export interface Image {
  id: string;
  url: string;
  blurhash: string;
  isMain: boolean;
}

export interface CreateProductRequest {
  product: Product | undefined;
}

export interface CreateProductResponse {
  product: Product | undefined;
}

export interface UpdateProductRequest {
  product: Product | undefined;
}

export interface UpdateProductResponse {
  product: Product | undefined;
}

export interface DeleteProductRequest {
  id: string;
}

export interface DeleteProductResponse {
  id: string;
}

export interface CreateVariantRequest {
  variant: ProductVariant | undefined;
}

export interface CreateVariantResponse {
  variant: ProductVariant | undefined;
}

export interface CreateBrandRequest {
  brand: Brand | undefined;
}

export interface CreateBrandResponse {
  brand: Brand | undefined;
}

export interface GetAllCategoryResponse {
  categories: Category[];
}

export interface CreateCategoryRequest {
  category: Category | undefined;
}

export interface CreateCategoryResponse {
  category: Category | undefined;
}

export interface UpdateCategoryRequest {
  category: Category | undefined;
}

export interface UpdateCategoryResponse {
  category: Category | undefined;
}

export interface DeleteCategoryRequest {
  id: string;
}

export interface DeleteCategoryResponse {
  id: string;
}

export interface CreateImageRequest {
  image: Image | undefined;
}

export interface CreateImageResponse {
  image: Image | undefined;
}

export interface ListProductsResponse {
  products: Product[];
}

export interface ListProductsRequest {
}

export interface GetProductByIdRequest {
  id: string;
}

export interface GetProductBySlugRequest {
  slug: string;
}

export interface GetProductResponse {
  product: Product | undefined;
}

export interface Variant {
  id: string;
  name: string;
  description: string;
  picture: string;
  priceUsd: Money | undefined;
}

export interface Brand {
  id: string;
  name: string;
  logo: string;
}

export interface Category {
  id: string;
  name: string;
  parentId: string;
}

export interface GetWarehousesResponse {
  warehouses: Warehouse[];
}

export interface Warehouse {
  id: string;
  name: string;
  code: string;
  location: string[];
  address: string;
  manager: string;
  contact: string;
  status: string;
  createdAt: string;
  updatedAt: string;
}

export interface SearchProductsRequest {
  query: string;
}

export interface SearchProductsResponse {
  results: Product[];
}

export interface GetQuoteRequest {
  address: Address | undefined;
  items: CartItem[];
}

export interface GetQuoteResponse {
  costUsd: Money | undefined;
}

export interface ShipOrderRequest {
  address: Address | undefined;
  items: CartItem[];
}

export interface ShipOrderResponse {
  trackingId: string;
}

export interface CancelShipmentRequest {
  orderId: string;
  trackingId: string;
}

export interface CancelShipmentResponse {
  success: boolean;
  message: string;
}

/** Represents an amount of money with its currency type. */
export interface Money {
  /** The 3-letter currency code defined in ISO 4217. */
  currencyCode: string;
  /**
   * The whole units of the amount.
   * For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
   */
  units: number;
  /**
   * Number of nano (10^-9) units of the amount.
   * The value must be between -999,999,999 and +999,999,999 inclusive.
   * If `units` is positive, `nanos` must be positive or zero.
   * If `units` is zero, `nanos` can be positive, zero, or negative.
   * If `units` is negative, `nanos` must be negative or zero.
   * For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
   */
  nanos: number;
}

export interface GetSupportedCurrenciesResponse {
  /** The 3-letter currency code defined in ISO 4217. */
  currencyCodes: string[];
}

export interface CurrencyConversionRequest {
  from:
    | Money
    | undefined;
  /** The 3-letter currency code defined in ISO 4217. */
  toCode: string;
}

export interface SendOTPResetPasswordRequest {
  email: string;
  verificationCode: string;
}

export interface SendOTPResetPasswordResponse {
  success: boolean;
  message: string;
}

export interface SendWelcomeEmailRequest {
  email: string;
  name: string;
  token: string;
}

export interface SendWelcomeEmailResponse {
  success: boolean;
  message: string;
}

export interface AdRequest {
  /** List of important key words from the current page describing the context. */
  contextKeys: string[];
}

export interface AdResponse {
  ads: Ad[];
}

export interface Ad {
  /** url to redirect to when an ad is clicked. */
  redirectUrl: string;
  /** short advertisement text to display. */
  text: string;
}

export interface NewBrandRequest {
  brand: Brand | undefined;
}

export interface NewBrandResponse {
  success: boolean;
  message: string;
  brand: Brand | undefined;
}

export interface RemoveBrandRequest {
  id: string;
}

export interface RemoveBrandResponse {
  success: boolean;
  message: string;
}

export interface GetAllBrandResponse {
  success: boolean;
  message: string;
  brands: Brand[];
}

export interface HealthCheckRequest {
  /** The name of the service to check */
  service: string;
}

export interface HealthCheckResponse {
  status: HealthCheckResponse_ServingStatus;
}

export enum HealthCheckResponse_ServingStatus {
  UNKNOWN = 0,
  SERVING = 1,
  NOT_SERVING = 2,
  /** SERVICE_UNKNOWN - Used when the requested service is not known */
  SERVICE_UNKNOWN = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_ServingStatusFromJSON(object: any): HealthCheckResponse_ServingStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return HealthCheckResponse_ServingStatus.UNKNOWN;
    case 1:
    case "SERVING":
      return HealthCheckResponse_ServingStatus.SERVING;
    case 2:
    case "NOT_SERVING":
      return HealthCheckResponse_ServingStatus.NOT_SERVING;
    case 3:
    case "SERVICE_UNKNOWN":
      return HealthCheckResponse_ServingStatus.SERVICE_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_ServingStatus.UNRECOGNIZED;
  }
}

export function healthCheckResponse_ServingStatusToJSON(object: HealthCheckResponse_ServingStatus): string {
  switch (object) {
    case HealthCheckResponse_ServingStatus.UNKNOWN:
      return "UNKNOWN";
    case HealthCheckResponse_ServingStatus.SERVING:
      return "SERVING";
    case HealthCheckResponse_ServingStatus.NOT_SERVING:
      return "NOT_SERVING";
    case HealthCheckResponse_ServingStatus.SERVICE_UNKNOWN:
      return "SERVICE_UNKNOWN";
    case HealthCheckResponse_ServingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateOrderRequest {
  userId: string;
  currencyCode: string;
  totalAmount: number;
  items: OrderItem[];
  shippingAddressId: string;
  paymentId: string;
  paymentStatus: PaymentStatus;
}

export interface OrderItem {
  productId: string;
  variantId: string;
  quantity: number;
  price: Money | undefined;
}

export interface CreateOrderResponse {
  orderId: string;
  status: OrderStatus;
}

export interface GetOrderStatusRequest {
  orderId: string;
}

export interface GetOrderStatusResponse {
  status: OrderStatus;
}

export interface GetOrderRequest {
  orderId: string;
}

export interface GetOrderResponse {
  order: Order | undefined;
}

export interface Order {
  id: string;
  userId: string;
  status: string;
  totalAmount: number;
  shippingAddressId: string;
  items: OrderItem[];
  paymentId: string;
  createdAt: string;
  updatedAt: string;
}

export interface UpdateOrderStatusRequest {
  orderId: string;
  status: OrderStatus;
}

export interface UpdateOrderStatusResponse {
  orderId: string;
  status: OrderStatus;
  steps: OrderStep[];
  message: string;
}

export interface CancelOrderRequest {
  orderId: string;
}

export interface CancelOrderResponse {
  orderId: string;
  status: OrderStatus;
  message: string;
}

export interface OrderStep {
  service: string;
  status: StepStatus;
  error: string;
  timestamp: string;
}

export interface ValidateAndReserveRequest {
  userId: string;
  variants: ProductVariant[];
}

export interface ValidateAndReserveResponse {
  success: boolean;
  reservationId: string;
  validationErrors: ValidationError[];
}

export interface ValidationError {
  variantId: string;
  error: string;
}

export interface ReleaseReservationRequest {
  reservationId: string;
}

export interface ReleaseReservationResponse {
  success: boolean;
  message: string;
}

export interface CommitReservationRequest {
  reservationId: string;
}

export interface CommitReservationResponse {
  success: boolean;
  message: string;
}

export interface InitiatePaymentRequest {
  orderId: string;
  amount: number;
  provider: PaymentProvider;
  currency: string;
}

export interface InitiatePaymentResponse {
  paymentId: string;
  redirectUrl: string;
  status: PaymentStatus;
}

export interface VerifyPaymentRequest {
  paymentId: string;
}

export interface VerifyPaymentResponse {
  status: PaymentStatus;
}

export interface CancelPaymentRequest {
  paymentId: string;
}

export interface CancelPaymentResponse {
  success: boolean;
}

export interface RefundPaymentRequest {
  paymentId: string;
}

export interface RefundPaymentResponse {
  success: boolean;
}

export interface GetPaymentStatusRequest {
  paymentId: string;
}

export interface GetPaymentStatusResponse {
  status: PaymentStatus;
}

function createBaseGetAddressesRequest(): GetAddressesRequest {
  return { userId: "" };
}

export const GetAddressesRequest: MessageFns<GetAddressesRequest> = {
  encode(message: GetAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetAddressesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressesRequest>, I>>(base?: I): GetAddressesRequest {
    return GetAddressesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressesRequest>, I>>(object: I): GetAddressesRequest {
    const message = createBaseGetAddressesRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetAddressesResponse(): GetAddressesResponse {
  return { success: false, message: "", addresses: [] };
}

export const GetAddressesResponse: MessageFns<GetAddressesResponse> = {
  encode(message: GetAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.addresses) {
      ExtendedAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(ExtendedAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => ExtendedAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAddressesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => ExtendedAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressesResponse>, I>>(base?: I): GetAddressesResponse {
    return GetAddressesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressesResponse>, I>>(object: I): GetAddressesResponse {
    const message = createBaseGetAddressesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.addresses = object.addresses?.map((e) => ExtendedAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCountriesResponse(): GetCountriesResponse {
  return { success: false, message: "", countries: [] };
}

export const GetCountriesResponse: MessageFns<GetCountriesResponse> = {
  encode(message: GetCountriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.countries) {
      Country.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countries.push(Country.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountriesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      countries: globalThis.Array.isArray(object?.countries)
        ? object.countries.map((e: any) => Country.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCountriesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.countries?.length) {
      obj.countries = message.countries.map((e) => Country.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCountriesResponse>, I>>(base?: I): GetCountriesResponse {
    return GetCountriesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCountriesResponse>, I>>(object: I): GetCountriesResponse {
    const message = createBaseGetCountriesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.countries = object.countries?.map((e) => Country.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProvincesByCountryRequest(): GetProvincesByCountryRequest {
  return { countryId: "" };
}

export const GetProvincesByCountryRequest: MessageFns<GetProvincesByCountryRequest> = {
  encode(message: GetProvincesByCountryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryId !== "") {
      writer.uint32(10).string(message.countryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvincesByCountryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvincesByCountryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvincesByCountryRequest {
    return { countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "" };
  },

  toJSON(message: GetProvincesByCountryRequest): unknown {
    const obj: any = {};
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProvincesByCountryRequest>, I>>(base?: I): GetProvincesByCountryRequest {
    return GetProvincesByCountryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProvincesByCountryRequest>, I>>(object: I): GetProvincesByCountryRequest {
    const message = createBaseGetProvincesByCountryRequest();
    message.countryId = object.countryId ?? "";
    return message;
  },
};

function createBaseGetProvincesResponse(): GetProvincesResponse {
  return { success: false, message: "", provinces: [] };
}

export const GetProvincesResponse: MessageFns<GetProvincesResponse> = {
  encode(message: GetProvincesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.provinces) {
      Province.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvincesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvincesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provinces.push(Province.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvincesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      provinces: globalThis.Array.isArray(object?.provinces)
        ? object.provinces.map((e: any) => Province.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetProvincesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.provinces?.length) {
      obj.provinces = message.provinces.map((e) => Province.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProvincesResponse>, I>>(base?: I): GetProvincesResponse {
    return GetProvincesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProvincesResponse>, I>>(object: I): GetProvincesResponse {
    const message = createBaseGetProvincesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.provinces = object.provinces?.map((e) => Province.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDistrictsByProvinceRequest(): GetDistrictsByProvinceRequest {
  return { provinceId: "" };
}

export const GetDistrictsByProvinceRequest: MessageFns<GetDistrictsByProvinceRequest> = {
  encode(message: GetDistrictsByProvinceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provinceId !== "") {
      writer.uint32(10).string(message.provinceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDistrictsByProvinceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDistrictsByProvinceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provinceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDistrictsByProvinceRequest {
    return { provinceId: isSet(object.provinceId) ? globalThis.String(object.provinceId) : "" };
  },

  toJSON(message: GetDistrictsByProvinceRequest): unknown {
    const obj: any = {};
    if (message.provinceId !== "") {
      obj.provinceId = message.provinceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDistrictsByProvinceRequest>, I>>(base?: I): GetDistrictsByProvinceRequest {
    return GetDistrictsByProvinceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDistrictsByProvinceRequest>, I>>(
    object: I,
  ): GetDistrictsByProvinceRequest {
    const message = createBaseGetDistrictsByProvinceRequest();
    message.provinceId = object.provinceId ?? "";
    return message;
  },
};

function createBaseGetDistrictsResponse(): GetDistrictsResponse {
  return { success: false, message: "", districts: [] };
}

export const GetDistrictsResponse: MessageFns<GetDistrictsResponse> = {
  encode(message: GetDistrictsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.districts) {
      District.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDistrictsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDistrictsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.districts.push(District.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDistrictsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      districts: globalThis.Array.isArray(object?.districts)
        ? object.districts.map((e: any) => District.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDistrictsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.districts?.length) {
      obj.districts = message.districts.map((e) => District.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDistrictsResponse>, I>>(base?: I): GetDistrictsResponse {
    return GetDistrictsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDistrictsResponse>, I>>(object: I): GetDistrictsResponse {
    const message = createBaseGetDistrictsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.districts = object.districts?.map((e) => District.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWardsByDistrictRequest(): GetWardsByDistrictRequest {
  return { districtId: "" };
}

export const GetWardsByDistrictRequest: MessageFns<GetWardsByDistrictRequest> = {
  encode(message: GetWardsByDistrictRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.districtId !== "") {
      writer.uint32(10).string(message.districtId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWardsByDistrictRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWardsByDistrictRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.districtId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWardsByDistrictRequest {
    return { districtId: isSet(object.districtId) ? globalThis.String(object.districtId) : "" };
  },

  toJSON(message: GetWardsByDistrictRequest): unknown {
    const obj: any = {};
    if (message.districtId !== "") {
      obj.districtId = message.districtId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWardsByDistrictRequest>, I>>(base?: I): GetWardsByDistrictRequest {
    return GetWardsByDistrictRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWardsByDistrictRequest>, I>>(object: I): GetWardsByDistrictRequest {
    const message = createBaseGetWardsByDistrictRequest();
    message.districtId = object.districtId ?? "";
    return message;
  },
};

function createBaseGetWardsResponse(): GetWardsResponse {
  return { success: false, message: "", wards: [] };
}

export const GetWardsResponse: MessageFns<GetWardsResponse> = {
  encode(message: GetWardsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.wards) {
      Ward.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWardsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wards.push(Ward.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWardsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      wards: globalThis.Array.isArray(object?.wards) ? object.wards.map((e: any) => Ward.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWardsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.wards?.length) {
      obj.wards = message.wards.map((e) => Ward.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWardsResponse>, I>>(base?: I): GetWardsResponse {
    return GetWardsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWardsResponse>, I>>(object: I): GetWardsResponse {
    const message = createBaseGetWardsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.wards = object.wards?.map((e) => Ward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddAddressRequest(): AddAddressRequest {
  return { userId: "", address: undefined };
}

export const AddAddressRequest: MessageFns<AddAddressRequest> = {
  encode(message: AddAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: AddAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddAddressRequest>, I>>(base?: I): AddAddressRequest {
    return AddAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddAddressRequest>, I>>(object: I): AddAddressRequest {
    const message = createBaseAddAddressRequest();
    message.userId = object.userId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseUpdateAddressRequest(): UpdateAddressRequest {
  return { userId: "", address: undefined };
}

export const UpdateAddressRequest: MessageFns<UpdateAddressRequest> = {
  encode(message: UpdateAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.address !== undefined) {
      ExtendedAddress.encode(message.address, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = ExtendedAddress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      address: isSet(object.address) ? ExtendedAddress.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: UpdateAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.address !== undefined) {
      obj.address = ExtendedAddress.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAddressRequest>, I>>(base?: I): UpdateAddressRequest {
    return UpdateAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAddressRequest>, I>>(object: I): UpdateAddressRequest {
    const message = createBaseUpdateAddressRequest();
    message.userId = object.userId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? ExtendedAddress.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseDeleteAddressRequest(): DeleteAddressRequest {
  return { userId: "", addressId: "" };
}

export const DeleteAddressRequest: MessageFns<DeleteAddressRequest> = {
  encode(message: DeleteAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.addressId !== "") {
      writer.uint32(18).string(message.addressId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      addressId: isSet(object.addressId) ? globalThis.String(object.addressId) : "",
    };
  },

  toJSON(message: DeleteAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.addressId !== "") {
      obj.addressId = message.addressId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAddressRequest>, I>>(base?: I): DeleteAddressRequest {
    return DeleteAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAddressRequest>, I>>(object: I): DeleteAddressRequest {
    const message = createBaseDeleteAddressRequest();
    message.userId = object.userId ?? "";
    message.addressId = object.addressId ?? "";
    return message;
  },
};

function createBaseAddressResponse(): AddressResponse {
  return { success: false, message: "", address: undefined };
}

export const AddressResponse: MessageFns<AddressResponse> = {
  encode(message: AddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: AddressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressResponse>, I>>(base?: I): AddressResponse {
    return AddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressResponse>, I>>(object: I): AddressResponse {
    const message = createBaseAddressResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseDeleteAddressResponse(): DeleteAddressResponse {
  return { success: false, message: "" };
}

export const DeleteAddressResponse: MessageFns<DeleteAddressResponse> = {
  encode(message: DeleteAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAddressResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteAddressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAddressResponse>, I>>(base?: I): DeleteAddressResponse {
    return DeleteAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAddressResponse>, I>>(object: I): DeleteAddressResponse {
    const message = createBaseDeleteAddressResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCountry(): Country {
  return { id: "", name: "", codeName: "" };
}

export const Country: MessageFns<Country> = {
  encode(message: Country, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.codeName !== "") {
      writer.uint32(26).string(message.codeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Country {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.codeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Country {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      codeName: isSet(object.codeName) ? globalThis.String(object.codeName) : "",
    };
  },

  toJSON(message: Country): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.codeName !== "") {
      obj.codeName = message.codeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Country>, I>>(base?: I): Country {
    return Country.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Country>, I>>(object: I): Country {
    const message = createBaseCountry();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.codeName = object.codeName ?? "";
    return message;
  },
};

function createBaseProvince(): Province {
  return {
    id: "",
    name: "",
    nameEn: "",
    fullName: "",
    fullNameEn: "",
    administrativeUnitId: "",
    administrativeRegionId: "",
    countryId: "",
  };
}

export const Province: MessageFns<Province> = {
  encode(message: Province, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(50).string(message.administrativeUnitId);
    }
    if (message.administrativeRegionId !== "") {
      writer.uint32(58).string(message.administrativeRegionId);
    }
    if (message.countryId !== "") {
      writer.uint32(66).string(message.countryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Province {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvince();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeRegionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Province {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
      administrativeRegionId: isSet(object.administrativeRegionId)
        ? globalThis.String(object.administrativeRegionId)
        : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
    };
  },

  toJSON(message: Province): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    if (message.administrativeRegionId !== "") {
      obj.administrativeRegionId = message.administrativeRegionId;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Province>, I>>(base?: I): Province {
    return Province.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Province>, I>>(object: I): Province {
    const message = createBaseProvince();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    message.administrativeRegionId = object.administrativeRegionId ?? "";
    message.countryId = object.countryId ?? "";
    return message;
  },
};

function createBaseDistrict(): District {
  return { id: "", name: "", nameEn: "", fullName: "", fullNameEn: "", provinceId: "", administrativeUnitId: "" };
}

export const District: MessageFns<District> = {
  encode(message: District, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.provinceId !== "") {
      writer.uint32(50).string(message.provinceId);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(58).string(message.administrativeUnitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): District {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistrict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.provinceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): District {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      provinceId: isSet(object.provinceId) ? globalThis.String(object.provinceId) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
    };
  },

  toJSON(message: District): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.provinceId !== "") {
      obj.provinceId = message.provinceId;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<District>, I>>(base?: I): District {
    return District.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<District>, I>>(object: I): District {
    const message = createBaseDistrict();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.provinceId = object.provinceId ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    return message;
  },
};

function createBaseWard(): Ward {
  return { id: "", name: "", nameEn: "", fullName: "", fullNameEn: "", districtId: "", administrativeUnitId: "" };
}

export const Ward: MessageFns<Ward> = {
  encode(message: Ward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.districtId !== "") {
      writer.uint32(50).string(message.districtId);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(58).string(message.administrativeUnitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.districtId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ward {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      districtId: isSet(object.districtId) ? globalThis.String(object.districtId) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
    };
  },

  toJSON(message: Ward): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.districtId !== "") {
      obj.districtId = message.districtId;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ward>, I>>(base?: I): Ward {
    return Ward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ward>, I>>(object: I): Ward {
    const message = createBaseWard();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.districtId = object.districtId ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: false, message: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseValidateOTPRequest(): ValidateOTPRequest {
  return { email: "", otp: "" };
}

export const ValidateOTPRequest: MessageFns<ValidateOTPRequest> = {
  encode(message: ValidateOTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(18).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateOTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateOTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateOTPRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: ValidateOTPRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateOTPRequest>, I>>(base?: I): ValidateOTPRequest {
    return ValidateOTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateOTPRequest>, I>>(object: I): ValidateOTPRequest {
    const message = createBaseValidateOTPRequest();
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseValidateOTPResponse(): ValidateOTPResponse {
  return { success: false, message: "" };
}

export const ValidateOTPResponse: MessageFns<ValidateOTPResponse> = {
  encode(message: ValidateOTPResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateOTPResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateOTPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateOTPResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ValidateOTPResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateOTPResponse>, I>>(base?: I): ValidateOTPResponse {
    return ValidateOTPResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateOTPResponse>, I>>(object: I): ValidateOTPResponse {
    const message = createBaseValidateOTPResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { email: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.email = object.email ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { success: false, message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { id: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return { success: false, message: "", user: undefined };
}

export const UpdateUserResponse: MessageFns<UpdateUserResponse> = {
  encode(message: UpdateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: UpdateUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(object: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { success: false, message: "", user: undefined };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { id: "" };
}

export const DeleteUserRequest: MessageFns<DeleteUserRequest> = {
  encode(message: DeleteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { id: "", user: undefined, currentPassword: "", newPassword: "" };
}

export const UpdateUserRequest: MessageFns<UpdateUserRequest> = {
  encode(message: UpdateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.currentPassword !== "") {
      writer.uint32(26).string(message.currentPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(34).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentPassword = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      currentPassword: isSet(object.currentPassword) ? globalThis.String(object.currentPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.currentPassword !== "") {
      obj.currentPassword = message.currentPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.id = object.id ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.currentPassword = object.currentPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { firstName: "", lastName: "", email: "", password: "" };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(18).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(object: I): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { success: false, message: "" };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(object: I): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseLoginUserRequest(): LoginUserRequest {
  return { email: "", password: "" };
}

export const LoginUserRequest: MessageFns<LoginUserRequest> = {
  encode(message: LoginUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserRequest>, I>>(base?: I): LoginUserRequest {
    return LoginUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserRequest>, I>>(object: I): LoginUserRequest {
    const message = createBaseLoginUserRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginUserResponse(): LoginUserResponse {
  return { success: false, message: "", accessToken: "", refreshToken: "", user: undefined };
}

export const LoginUserResponse: MessageFns<LoginUserResponse> = {
  encode(message: LoginUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(26).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(34).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: LoginUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserResponse>, I>>(base?: I): LoginUserResponse {
    return LoginUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserResponse>, I>>(object: I): LoginUserResponse {
    const message = createBaseLoginUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    firstName: "",
    lastName: "",
    email: "",
    phone: "",
    createdAt: "",
    dateOfBirth: "",
    gender: "",
    updatedAt: "",
    isActive: false,
    isVerified: false,
    role: "",
    lastLogin: "",
    permissions: "",
    profilePictureUrl: "",
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(42).string(message.phone);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.dateOfBirth !== "") {
      writer.uint32(58).string(message.dateOfBirth);
    }
    if (message.gender !== "") {
      writer.uint32(66).string(message.gender);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.isVerified !== false) {
      writer.uint32(88).bool(message.isVerified);
    }
    if (message.role !== "") {
      writer.uint32(98).string(message.role);
    }
    if (message.lastLogin !== "") {
      writer.uint32(106).string(message.lastLogin);
    }
    if (message.permissions !== "") {
      writer.uint32(114).string(message.permissions);
    }
    if (message.profilePictureUrl !== "") {
      writer.uint32(122).string(message.profilePictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateOfBirth = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.lastLogin = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.permissions = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profilePictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      dateOfBirth: isSet(object.dateOfBirth) ? globalThis.String(object.dateOfBirth) : "",
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      lastLogin: isSet(object.lastLogin) ? globalThis.String(object.lastLogin) : "",
      permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
      profilePictureUrl: isSet(object.profilePictureUrl) ? globalThis.String(object.profilePictureUrl) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.dateOfBirth !== "") {
      obj.dateOfBirth = message.dateOfBirth;
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.lastLogin !== "") {
      obj.lastLogin = message.lastLogin;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    if (message.profilePictureUrl !== "") {
      obj.profilePictureUrl = message.profilePictureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? "";
    message.createdAt = object.createdAt ?? "";
    message.dateOfBirth = object.dateOfBirth ?? "";
    message.gender = object.gender ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.isActive = object.isActive ?? false;
    message.isVerified = object.isVerified ?? false;
    message.role = object.role ?? "";
    message.lastLogin = object.lastLogin ?? "";
    message.permissions = object.permissions ?? "";
    message.profilePictureUrl = object.profilePictureUrl ?? "";
    return message;
  },
};

function createBaseExtendedAddress(): ExtendedAddress {
  return {
    id: "",
    name: "",
    street: "",
    city: "",
    state: "",
    countryId: "",
    countryName: "",
    zip: "",
    vnProvinceId: "",
    vnProvinceName: "",
    vnDistrictId: "",
    vnDistrictName: "",
    vnWardId: "",
    vnWardName: "",
    isDefault: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ExtendedAddress: MessageFns<ExtendedAddress> = {
  encode(message: ExtendedAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.countryId !== "") {
      writer.uint32(50).string(message.countryId);
    }
    if (message.countryName !== "") {
      writer.uint32(58).string(message.countryName);
    }
    if (message.zip !== "") {
      writer.uint32(66).string(message.zip);
    }
    if (message.vnProvinceId !== "") {
      writer.uint32(74).string(message.vnProvinceId);
    }
    if (message.vnProvinceName !== "") {
      writer.uint32(82).string(message.vnProvinceName);
    }
    if (message.vnDistrictId !== "") {
      writer.uint32(90).string(message.vnDistrictId);
    }
    if (message.vnDistrictName !== "") {
      writer.uint32(98).string(message.vnDistrictName);
    }
    if (message.vnWardId !== "") {
      writer.uint32(106).string(message.vnWardId);
    }
    if (message.vnWardName !== "") {
      writer.uint32(114).string(message.vnWardName);
    }
    if (message.isDefault !== false) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendedAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.countryName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.zip = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.vnProvinceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vnProvinceName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.vnDistrictId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.vnDistrictName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.vnWardId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.vnWardName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedAddress {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
      countryName: isSet(object.countryName) ? globalThis.String(object.countryName) : "",
      zip: isSet(object.zip) ? globalThis.String(object.zip) : "",
      vnProvinceId: isSet(object.vnProvinceId) ? globalThis.String(object.vnProvinceId) : "",
      vnProvinceName: isSet(object.vnProvinceName) ? globalThis.String(object.vnProvinceName) : "",
      vnDistrictId: isSet(object.vnDistrictId) ? globalThis.String(object.vnDistrictId) : "",
      vnDistrictName: isSet(object.vnDistrictName) ? globalThis.String(object.vnDistrictName) : "",
      vnWardId: isSet(object.vnWardId) ? globalThis.String(object.vnWardId) : "",
      vnWardName: isSet(object.vnWardName) ? globalThis.String(object.vnWardName) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ExtendedAddress): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    if (message.countryName !== "") {
      obj.countryName = message.countryName;
    }
    if (message.zip !== "") {
      obj.zip = message.zip;
    }
    if (message.vnProvinceId !== "") {
      obj.vnProvinceId = message.vnProvinceId;
    }
    if (message.vnProvinceName !== "") {
      obj.vnProvinceName = message.vnProvinceName;
    }
    if (message.vnDistrictId !== "") {
      obj.vnDistrictId = message.vnDistrictId;
    }
    if (message.vnDistrictName !== "") {
      obj.vnDistrictName = message.vnDistrictName;
    }
    if (message.vnWardId !== "") {
      obj.vnWardId = message.vnWardId;
    }
    if (message.vnWardName !== "") {
      obj.vnWardName = message.vnWardName;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtendedAddress>, I>>(base?: I): ExtendedAddress {
    return ExtendedAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtendedAddress>, I>>(object: I): ExtendedAddress {
    const message = createBaseExtendedAddress();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.state = object.state ?? "";
    message.countryId = object.countryId ?? "";
    message.countryName = object.countryName ?? "";
    message.zip = object.zip ?? "";
    message.vnProvinceId = object.vnProvinceId ?? "";
    message.vnProvinceName = object.vnProvinceName ?? "";
    message.vnDistrictId = object.vnDistrictId ?? "";
    message.vnDistrictName = object.vnDistrictName ?? "";
    message.vnWardId = object.vnWardId ?? "";
    message.vnWardName = object.vnWardName ?? "";
    message.isDefault = object.isDefault ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseAddress(): Address {
  return {
    id: "",
    name: "",
    street: "",
    city: "",
    state: "",
    countryId: "",
    zip: "",
    vnProvinceId: "",
    vnDistrictId: "",
    vnWardId: "",
    isDefault: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.countryId !== "") {
      writer.uint32(50).string(message.countryId);
    }
    if (message.zip !== "") {
      writer.uint32(58).string(message.zip);
    }
    if (message.vnProvinceId !== "") {
      writer.uint32(66).string(message.vnProvinceId);
    }
    if (message.vnDistrictId !== "") {
      writer.uint32(74).string(message.vnDistrictId);
    }
    if (message.vnWardId !== "") {
      writer.uint32(82).string(message.vnWardId);
    }
    if (message.isDefault !== false) {
      writer.uint32(88).bool(message.isDefault);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.zip = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.vnProvinceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.vnDistrictId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vnWardId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
      zip: isSet(object.zip) ? globalThis.String(object.zip) : "",
      vnProvinceId: isSet(object.vnProvinceId) ? globalThis.String(object.vnProvinceId) : "",
      vnDistrictId: isSet(object.vnDistrictId) ? globalThis.String(object.vnDistrictId) : "",
      vnWardId: isSet(object.vnWardId) ? globalThis.String(object.vnWardId) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    if (message.zip !== "") {
      obj.zip = message.zip;
    }
    if (message.vnProvinceId !== "") {
      obj.vnProvinceId = message.vnProvinceId;
    }
    if (message.vnDistrictId !== "") {
      obj.vnDistrictId = message.vnDistrictId;
    }
    if (message.vnWardId !== "") {
      obj.vnWardId = message.vnWardId;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.state = object.state ?? "";
    message.countryId = object.countryId ?? "";
    message.zip = object.zip ?? "";
    message.vnProvinceId = object.vnProvinceId ?? "";
    message.vnDistrictId = object.vnDistrictId ?? "";
    message.vnWardId = object.vnWardId ?? "";
    message.isDefault = object.isDefault ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false, message: "" };
}

export const DeleteUserResponse: MessageFns<DeleteUserResponse> = {
  encode(message: DeleteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(object: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyAccountRequest(): VerifyAccountRequest {
  return { token: "" };
}

export const VerifyAccountRequest: MessageFns<VerifyAccountRequest> = {
  encode(message: VerifyAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccountRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: VerifyAccountRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(base?: I): VerifyAccountRequest {
    return VerifyAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(object: I): VerifyAccountRequest {
    const message = createBaseVerifyAccountRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseVerifyAccountResponse(): VerifyAccountResponse {
  return { success: false, message: "" };
}

export const VerifyAccountResponse: MessageFns<VerifyAccountResponse> = {
  encode(message: VerifyAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccountResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: VerifyAccountResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccountResponse>, I>>(base?: I): VerifyAccountResponse {
    return VerifyAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccountResponse>, I>>(object: I): VerifyAccountResponse {
    const message = createBaseVerifyAccountResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetCartRequest(): GetCartRequest {
  return { userId: "" };
}

export const GetCartRequest: MessageFns<GetCartRequest> = {
  encode(message: GetCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCartRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetCartRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCartRequest>, I>>(base?: I): GetCartRequest {
    return GetCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCartRequest>, I>>(object: I): GetCartRequest {
    const message = createBaseGetCartRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetCartResponse(): GetCartResponse {
  return { cart: undefined };
}

export const GetCartResponse: MessageFns<GetCartResponse> = {
  encode(message: GetCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cart !== undefined) {
      Cart.encode(message.cart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cart = Cart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCartResponse {
    return { cart: isSet(object.cart) ? Cart.fromJSON(object.cart) : undefined };
  },

  toJSON(message: GetCartResponse): unknown {
    const obj: any = {};
    if (message.cart !== undefined) {
      obj.cart = Cart.toJSON(message.cart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCartResponse>, I>>(base?: I): GetCartResponse {
    return GetCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCartResponse>, I>>(object: I): GetCartResponse {
    const message = createBaseGetCartResponse();
    message.cart = (object.cart !== undefined && object.cart !== null) ? Cart.fromPartial(object.cart) : undefined;
    return message;
  },
};

function createBaseAddItemRequest(): AddItemRequest {
  return { userId: "", productId: "", variantId: "", quantity: 0, image: "", currencyCode: "" };
}

export const AddItemRequest: MessageFns<AddItemRequest> = {
  encode(message: AddItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(26).string(message.variantId);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.image !== "") {
      writer.uint32(42).string(message.image);
    }
    if (message.currencyCode !== "") {
      writer.uint32(50).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: AddItemRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemRequest>, I>>(base?: I): AddItemRequest {
    return AddItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemRequest>, I>>(object: I): AddItemRequest {
    const message = createBaseAddItemRequest();
    message.userId = object.userId ?? "";
    message.productId = object.productId ?? "";
    message.variantId = object.variantId ?? "";
    message.quantity = object.quantity ?? 0;
    message.image = object.image ?? "";
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

function createBaseAddItemResponse(): AddItemResponse {
  return { cart: undefined };
}

export const AddItemResponse: MessageFns<AddItemResponse> = {
  encode(message: AddItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cart !== undefined) {
      Cart.encode(message.cart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cart = Cart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemResponse {
    return { cart: isSet(object.cart) ? Cart.fromJSON(object.cart) : undefined };
  },

  toJSON(message: AddItemResponse): unknown {
    const obj: any = {};
    if (message.cart !== undefined) {
      obj.cart = Cart.toJSON(message.cart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemResponse>, I>>(base?: I): AddItemResponse {
    return AddItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemResponse>, I>>(object: I): AddItemResponse {
    const message = createBaseAddItemResponse();
    message.cart = (object.cart !== undefined && object.cart !== null) ? Cart.fromPartial(object.cart) : undefined;
    return message;
  },
};

function createBaseUpdateItemRequest(): UpdateItemRequest {
  return { userId: "", productId: "", variantId: "", quantity: 0, image: "" };
}

export const UpdateItemRequest: MessageFns<UpdateItemRequest> = {
  encode(message: UpdateItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(26).string(message.variantId);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.image !== "") {
      writer.uint32(42).string(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.image = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateItemRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
    };
  },

  toJSON(message: UpdateItemRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateItemRequest>, I>>(base?: I): UpdateItemRequest {
    return UpdateItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateItemRequest>, I>>(object: I): UpdateItemRequest {
    const message = createBaseUpdateItemRequest();
    message.userId = object.userId ?? "";
    message.productId = object.productId ?? "";
    message.variantId = object.variantId ?? "";
    message.quantity = object.quantity ?? 0;
    message.image = object.image ?? "";
    return message;
  },
};

function createBaseUpdateItemResponse(): UpdateItemResponse {
  return { cart: undefined };
}

export const UpdateItemResponse: MessageFns<UpdateItemResponse> = {
  encode(message: UpdateItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cart !== undefined) {
      Cart.encode(message.cart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cart = Cart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateItemResponse {
    return { cart: isSet(object.cart) ? Cart.fromJSON(object.cart) : undefined };
  },

  toJSON(message: UpdateItemResponse): unknown {
    const obj: any = {};
    if (message.cart !== undefined) {
      obj.cart = Cart.toJSON(message.cart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateItemResponse>, I>>(base?: I): UpdateItemResponse {
    return UpdateItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateItemResponse>, I>>(object: I): UpdateItemResponse {
    const message = createBaseUpdateItemResponse();
    message.cart = (object.cart !== undefined && object.cart !== null) ? Cart.fromPartial(object.cart) : undefined;
    return message;
  },
};

function createBaseRemoveItemRequest(): RemoveItemRequest {
  return { userId: "", productId: "", variantId: "" };
}

export const RemoveItemRequest: MessageFns<RemoveItemRequest> = {
  encode(message: RemoveItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(26).string(message.variantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveItemRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
    };
  },

  toJSON(message: RemoveItemRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveItemRequest>, I>>(base?: I): RemoveItemRequest {
    return RemoveItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveItemRequest>, I>>(object: I): RemoveItemRequest {
    const message = createBaseRemoveItemRequest();
    message.userId = object.userId ?? "";
    message.productId = object.productId ?? "";
    message.variantId = object.variantId ?? "";
    return message;
  },
};

function createBaseRemoveItemResponse(): RemoveItemResponse {
  return { cart: undefined };
}

export const RemoveItemResponse: MessageFns<RemoveItemResponse> = {
  encode(message: RemoveItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cart !== undefined) {
      Cart.encode(message.cart, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cart = Cart.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveItemResponse {
    return { cart: isSet(object.cart) ? Cart.fromJSON(object.cart) : undefined };
  },

  toJSON(message: RemoveItemResponse): unknown {
    const obj: any = {};
    if (message.cart !== undefined) {
      obj.cart = Cart.toJSON(message.cart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveItemResponse>, I>>(base?: I): RemoveItemResponse {
    return RemoveItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveItemResponse>, I>>(object: I): RemoveItemResponse {
    const message = createBaseRemoveItemResponse();
    message.cart = (object.cart !== undefined && object.cart !== null) ? Cart.fromPartial(object.cart) : undefined;
    return message;
  },
};

function createBaseClearCartRequest(): ClearCartRequest {
  return { userId: "" };
}

export const ClearCartRequest: MessageFns<ClearCartRequest> = {
  encode(message: ClearCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearCartRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ClearCartRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCartRequest>, I>>(base?: I): ClearCartRequest {
    return ClearCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCartRequest>, I>>(object: I): ClearCartRequest {
    const message = createBaseClearCartRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseClearCartResponse(): ClearCartResponse {
  return { success: false };
}

export const ClearCartResponse: MessageFns<ClearCartResponse> = {
  encode(message: ClearCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearCartResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: ClearCartResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearCartResponse>, I>>(base?: I): ClearCartResponse {
    return ClearCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearCartResponse>, I>>(object: I): ClearCartResponse {
    const message = createBaseClearCartResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCart(): Cart {
  return { id: "", userId: "", items: [], createdAt: "", updatedAt: "", currencyCode: "" };
}

export const Cart: MessageFns<Cart> = {
  encode(message: Cart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    if (message.currencyCode !== "") {
      writer.uint32(50).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cart {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: Cart): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cart>, I>>(base?: I): Cart {
    return Cart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cart>, I>>(object: I): Cart {
    const message = createBaseCart();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

function createBaseCartItem(): CartItem {
  return { id: "", productId: "", variantId: "", image: "", quantity: 0, createdAt: "", updatedAt: "" };
}

export const CartItem: MessageFns<CartItem> = {
  encode(message: CartItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(26).string(message.variantId);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    if (message.quantity !== 0) {
      writer.uint32(40).int32(message.quantity);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CartItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCartItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CartItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: CartItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CartItem>, I>>(base?: I): CartItem {
    return CartItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CartItem>, I>>(object: I): CartItem {
    const message = createBaseCartItem();
    message.id = object.id ?? "";
    message.productId = object.productId ?? "";
    message.variantId = object.variantId ?? "";
    message.image = object.image ?? "";
    message.quantity = object.quantity ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseValidateCartRequest(): ValidateCartRequest {
  return { userId: "" };
}

export const ValidateCartRequest: MessageFns<ValidateCartRequest> = {
  encode(message: ValidateCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateCartRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ValidateCartRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateCartRequest>, I>>(base?: I): ValidateCartRequest {
    return ValidateCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateCartRequest>, I>>(object: I): ValidateCartRequest {
    const message = createBaseValidateCartRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseValidateCartResponse(): ValidateCartResponse {
  return { valid: false, message: "", items: [], issues: [] };
}

export const ValidateCartResponse: MessageFns<ValidateCartResponse> = {
  encode(message: ValidateCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.issues) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.issues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateCartResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ValidateCartResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    if (message.issues?.length) {
      obj.issues = message.issues;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateCartResponse>, I>>(base?: I): ValidateCartResponse {
    return ValidateCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateCartResponse>, I>>(object: I): ValidateCartResponse {
    const message = createBaseValidateCartResponse();
    message.valid = object.valid ?? false;
    message.message = object.message ?? "";
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    message.issues = object.issues?.map((e) => e) || [];
    return message;
  },
};

function createBaseListRecommendationsRequest(): ListRecommendationsRequest {
  return { userId: "", productIds: [] };
}

export const ListRecommendationsRequest: MessageFns<ListRecommendationsRequest> = {
  encode(message: ListRecommendationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.productIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecommendationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecommendationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecommendationsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRecommendationsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecommendationsRequest>, I>>(base?: I): ListRecommendationsRequest {
    return ListRecommendationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecommendationsRequest>, I>>(object: I): ListRecommendationsRequest {
    const message = createBaseListRecommendationsRequest();
    message.userId = object.userId ?? "";
    message.productIds = object.productIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListRecommendationsResponse(): ListRecommendationsResponse {
  return { productIds: [] };
}

export const ListRecommendationsResponse: MessageFns<ListRecommendationsResponse> = {
  encode(message: ListRecommendationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecommendationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecommendationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecommendationsResponse {
    return {
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRecommendationsResponse): unknown {
    const obj: any = {};
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecommendationsResponse>, I>>(base?: I): ListRecommendationsResponse {
    return ListRecommendationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecommendationsResponse>, I>>(object: I): ListRecommendationsResponse {
    const message = createBaseListRecommendationsResponse();
    message.productIds = object.productIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetVariantsForCartRequest(): GetVariantsForCartRequest {
  return { variantIds: [] };
}

export const GetVariantsForCartRequest: MessageFns<GetVariantsForCartRequest> = {
  encode(message: GetVariantsForCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variantIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVariantsForCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVariantsForCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVariantsForCartRequest {
    return {
      variantIds: globalThis.Array.isArray(object?.variantIds)
        ? object.variantIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetVariantsForCartRequest): unknown {
    const obj: any = {};
    if (message.variantIds?.length) {
      obj.variantIds = message.variantIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVariantsForCartRequest>, I>>(base?: I): GetVariantsForCartRequest {
    return GetVariantsForCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVariantsForCartRequest>, I>>(object: I): GetVariantsForCartRequest {
    const message = createBaseGetVariantsForCartRequest();
    message.variantIds = object.variantIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetVariantsForCartResponse(): GetVariantsForCartResponse {
  return { variants: [] };
}

export const GetVariantsForCartResponse: MessageFns<GetVariantsForCartResponse> = {
  encode(message: GetVariantsForCartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      VariantCart.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVariantsForCartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVariantsForCartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variants.push(VariantCart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVariantsForCartResponse {
    return {
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => VariantCart.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetVariantsForCartResponse): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => VariantCart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVariantsForCartResponse>, I>>(base?: I): GetVariantsForCartResponse {
    return GetVariantsForCartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVariantsForCartResponse>, I>>(object: I): GetVariantsForCartResponse {
    const message = createBaseGetVariantsForCartResponse();
    message.variants = object.variants?.map((e) => VariantCart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVariantCart(): VariantCart {
  return {
    id: "",
    price: 0,
    image: "",
    stock: undefined,
    variantName: "",
    productName: "",
    productSlug: "",
    attributes: [],
  };
}

export const VariantCart: MessageFns<VariantCart> = {
  encode(message: VariantCart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.price !== 0) {
      writer.uint32(21).float(message.price);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    if (message.stock !== undefined) {
      Stock.encode(message.stock, writer.uint32(34).fork()).join();
    }
    if (message.variantName !== "") {
      writer.uint32(42).string(message.variantName);
    }
    if (message.productName !== "") {
      writer.uint32(50).string(message.productName);
    }
    if (message.productSlug !== "") {
      writer.uint32(58).string(message.productSlug);
    }
    for (const v of message.attributes) {
      VariantAttribute.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantCart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantCart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stock = Stock.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.variantName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.productSlug = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attributes.push(VariantAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantCart {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      stock: isSet(object.stock) ? Stock.fromJSON(object.stock) : undefined,
      variantName: isSet(object.variantName) ? globalThis.String(object.variantName) : "",
      productName: isSet(object.productName) ? globalThis.String(object.productName) : "",
      productSlug: isSet(object.productSlug) ? globalThis.String(object.productSlug) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VariantAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VariantCart): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.stock !== undefined) {
      obj.stock = Stock.toJSON(message.stock);
    }
    if (message.variantName !== "") {
      obj.variantName = message.variantName;
    }
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    if (message.productSlug !== "") {
      obj.productSlug = message.productSlug;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VariantAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VariantCart>, I>>(base?: I): VariantCart {
    return VariantCart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VariantCart>, I>>(object: I): VariantCart {
    const message = createBaseVariantCart();
    message.id = object.id ?? "";
    message.price = object.price ?? 0;
    message.image = object.image ?? "";
    message.stock = (object.stock !== undefined && object.stock !== null) ? Stock.fromPartial(object.stock) : undefined;
    message.variantName = object.variantName ?? "";
    message.productName = object.productName ?? "";
    message.productSlug = object.productSlug ?? "";
    message.attributes = object.attributes?.map((e) => VariantAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProductAttributesRequest(): GetProductAttributesRequest {
  return { productId: "" };
}

export const GetProductAttributesRequest: MessageFns<GetProductAttributesRequest> = {
  encode(message: GetProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductAttributesRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductAttributesRequest>, I>>(base?: I): GetProductAttributesRequest {
    return GetProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductAttributesRequest>, I>>(object: I): GetProductAttributesRequest {
    const message = createBaseGetProductAttributesRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetProductAttributesResponse(): GetProductAttributesResponse {
  return { attributes: [] };
}

export const GetProductAttributesResponse: MessageFns<GetProductAttributesResponse> = {
  encode(message: GetProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      ProductAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributes.push(ProductAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductAttributesResponse {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => ProductAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => ProductAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductAttributesResponse>, I>>(base?: I): GetProductAttributesResponse {
    return GetProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductAttributesResponse>, I>>(object: I): GetProductAttributesResponse {
    const message = createBaseGetProductAttributesResponse();
    message.attributes = object.attributes?.map((e) => ProductAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateProductAttributesRequest(): UpdateProductAttributesRequest {
  return { attribute: undefined };
}

export const UpdateProductAttributesRequest: MessageFns<UpdateProductAttributesRequest> = {
  encode(message: UpdateProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductAttributesRequest {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: UpdateProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductAttributesRequest>, I>>(base?: I): UpdateProductAttributesRequest {
    return UpdateProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductAttributesRequest>, I>>(
    object: I,
  ): UpdateProductAttributesRequest {
    const message = createBaseUpdateProductAttributesRequest();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductAttributesResponse(): UpdateProductAttributesResponse {
  return { attribute: undefined };
}

export const UpdateProductAttributesResponse: MessageFns<UpdateProductAttributesResponse> = {
  encode(message: UpdateProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductAttributesResponse {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: UpdateProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductAttributesResponse>, I>>(base?: I): UpdateProductAttributesResponse {
    return UpdateProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductAttributesResponse>, I>>(
    object: I,
  ): UpdateProductAttributesResponse {
    const message = createBaseUpdateProductAttributesResponse();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseDeleteProductAttributesRequest(): DeleteProductAttributesRequest {
  return { attributeId: "" };
}

export const DeleteProductAttributesRequest: MessageFns<DeleteProductAttributesRequest> = {
  encode(message: DeleteProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductAttributesRequest {
    return { attributeId: isSet(object.attributeId) ? globalThis.String(object.attributeId) : "" };
  },

  toJSON(message: DeleteProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.attributeId !== "") {
      obj.attributeId = message.attributeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductAttributesRequest>, I>>(base?: I): DeleteProductAttributesRequest {
    return DeleteProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductAttributesRequest>, I>>(
    object: I,
  ): DeleteProductAttributesRequest {
    const message = createBaseDeleteProductAttributesRequest();
    message.attributeId = object.attributeId ?? "";
    return message;
  },
};

function createBaseDeleteProductAttributesResponse(): DeleteProductAttributesResponse {
  return { attributeId: "" };
}

export const DeleteProductAttributesResponse: MessageFns<DeleteProductAttributesResponse> = {
  encode(message: DeleteProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductAttributesResponse {
    return { attributeId: isSet(object.attributeId) ? globalThis.String(object.attributeId) : "" };
  },

  toJSON(message: DeleteProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributeId !== "") {
      obj.attributeId = message.attributeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductAttributesResponse>, I>>(base?: I): DeleteProductAttributesResponse {
    return DeleteProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductAttributesResponse>, I>>(
    object: I,
  ): DeleteProductAttributesResponse {
    const message = createBaseDeleteProductAttributesResponse();
    message.attributeId = object.attributeId ?? "";
    return message;
  },
};

function createBaseCreateProductAttributeRequest(): CreateProductAttributeRequest {
  return { attribute: undefined };
}

export const CreateProductAttributeRequest: MessageFns<CreateProductAttributeRequest> = {
  encode(message: CreateProductAttributeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductAttributeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductAttributeRequest {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: CreateProductAttributeRequest): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductAttributeRequest>, I>>(base?: I): CreateProductAttributeRequest {
    return CreateProductAttributeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductAttributeRequest>, I>>(
    object: I,
  ): CreateProductAttributeRequest {
    const message = createBaseCreateProductAttributeRequest();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseCreateProductAttributeResponse(): CreateProductAttributeResponse {
  return { attribute: undefined };
}

export const CreateProductAttributeResponse: MessageFns<CreateProductAttributeResponse> = {
  encode(message: CreateProductAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductAttributeResponse {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: CreateProductAttributeResponse): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductAttributeResponse>, I>>(base?: I): CreateProductAttributeResponse {
    return CreateProductAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductAttributeResponse>, I>>(
    object: I,
  ): CreateProductAttributeResponse {
    const message = createBaseCreateProductAttributeResponse();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseProductAttribute(): ProductAttribute {
  return {
    id: "",
    name: "",
    required: false,
    visible: false,
    values: [],
    productId: "",
    variantable: false,
    filterable: false,
    searchable: false,
    displayOrder: 0,
  };
}

export const ProductAttribute: MessageFns<ProductAttribute> = {
  encode(message: ProductAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (message.visible !== false) {
      writer.uint32(32).bool(message.visible);
    }
    for (const v of message.values) {
      writer.uint32(42).string(v!);
    }
    if (message.productId !== "") {
      writer.uint32(50).string(message.productId);
    }
    if (message.variantable !== false) {
      writer.uint32(56).bool(message.variantable);
    }
    if (message.filterable !== false) {
      writer.uint32(64).bool(message.filterable);
    }
    if (message.searchable !== false) {
      writer.uint32(72).bool(message.searchable);
    }
    if (message.displayOrder !== 0) {
      writer.uint32(80).int32(message.displayOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visible = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.variantable = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.filterable = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.searchable = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.displayOrder = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantable: isSet(object.variantable) ? globalThis.Boolean(object.variantable) : false,
      filterable: isSet(object.filterable) ? globalThis.Boolean(object.filterable) : false,
      searchable: isSet(object.searchable) ? globalThis.Boolean(object.searchable) : false,
      displayOrder: isSet(object.displayOrder) ? globalThis.Number(object.displayOrder) : 0,
    };
  },

  toJSON(message: ProductAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantable !== false) {
      obj.variantable = message.variantable;
    }
    if (message.filterable !== false) {
      obj.filterable = message.filterable;
    }
    if (message.searchable !== false) {
      obj.searchable = message.searchable;
    }
    if (message.displayOrder !== 0) {
      obj.displayOrder = Math.round(message.displayOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductAttribute>, I>>(base?: I): ProductAttribute {
    return ProductAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductAttribute>, I>>(object: I): ProductAttribute {
    const message = createBaseProductAttribute();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.required = object.required ?? false;
    message.visible = object.visible ?? false;
    message.values = object.values?.map((e) => e) || [];
    message.productId = object.productId ?? "";
    message.variantable = object.variantable ?? false;
    message.filterable = object.filterable ?? false;
    message.searchable = object.searchable ?? false;
    message.displayOrder = object.displayOrder ?? 0;
    return message;
  },
};

function createBaseProduct(): Product {
  return {
    id: "",
    name: "",
    slug: "",
    description: "",
    costPrice: 0,
    basePrice: 0,
    sku: "",
    barcode: "",
    brandId: "",
    featured: false,
    status: "",
    createdAt: "",
    updatedAt: "",
    seo: undefined,
    taxable: false,
    shippable: false,
    categories: [],
    productTags: [],
    images: [],
    attributes: [],
    variants: [],
    dimensions: undefined,
    sizeCharts: [],
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.costPrice !== 0) {
      writer.uint32(45).float(message.costPrice);
    }
    if (message.basePrice !== 0) {
      writer.uint32(53).float(message.basePrice);
    }
    if (message.sku !== "") {
      writer.uint32(58).string(message.sku);
    }
    if (message.barcode !== "") {
      writer.uint32(66).string(message.barcode);
    }
    if (message.brandId !== "") {
      writer.uint32(74).string(message.brandId);
    }
    if (message.featured !== false) {
      writer.uint32(80).bool(message.featured);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    if (message.seo !== undefined) {
      Seo.encode(message.seo, writer.uint32(114).fork()).join();
    }
    if (message.taxable !== false) {
      writer.uint32(120).bool(message.taxable);
    }
    if (message.shippable !== false) {
      writer.uint32(128).bool(message.shippable);
    }
    for (const v of message.categories) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.productTags) {
      ProductTag.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.attributes) {
      ProductAttribute.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.variants) {
      ProductVariant.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.dimensions !== undefined) {
      Dimensions.encode(message.dimensions, writer.uint32(178).fork()).join();
    }
    for (const v of message.sizeCharts) {
      SizeChart.encode(v!, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.costPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.basePrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.barcode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.brandId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.featured = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.seo = Seo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.taxable = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.shippable = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.productTags.push(ProductTag.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.attributes.push(ProductAttribute.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.variants.push(ProductVariant.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dimensions = Dimensions.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.sizeCharts.push(SizeChart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      costPrice: isSet(object.costPrice) ? globalThis.Number(object.costPrice) : 0,
      basePrice: isSet(object.basePrice) ? globalThis.Number(object.basePrice) : 0,
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      barcode: isSet(object.barcode) ? globalThis.String(object.barcode) : "",
      brandId: isSet(object.brandId) ? globalThis.String(object.brandId) : "",
      featured: isSet(object.featured) ? globalThis.Boolean(object.featured) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      seo: isSet(object.seo) ? Seo.fromJSON(object.seo) : undefined,
      taxable: isSet(object.taxable) ? globalThis.Boolean(object.taxable) : false,
      shippable: isSet(object.shippable) ? globalThis.Boolean(object.shippable) : false,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      productTags: globalThis.Array.isArray(object?.productTags)
        ? object.productTags.map((e: any) => ProductTag.fromJSON(e))
        : [],
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => Image.fromJSON(e)) : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => ProductAttribute.fromJSON(e))
        : [],
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => ProductVariant.fromJSON(e))
        : [],
      dimensions: isSet(object.dimensions) ? Dimensions.fromJSON(object.dimensions) : undefined,
      sizeCharts: globalThis.Array.isArray(object?.sizeCharts)
        ? object.sizeCharts.map((e: any) => SizeChart.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.costPrice !== 0) {
      obj.costPrice = message.costPrice;
    }
    if (message.basePrice !== 0) {
      obj.basePrice = message.basePrice;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.barcode !== "") {
      obj.barcode = message.barcode;
    }
    if (message.brandId !== "") {
      obj.brandId = message.brandId;
    }
    if (message.featured !== false) {
      obj.featured = message.featured;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.seo !== undefined) {
      obj.seo = Seo.toJSON(message.seo);
    }
    if (message.taxable !== false) {
      obj.taxable = message.taxable;
    }
    if (message.shippable !== false) {
      obj.shippable = message.shippable;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.productTags?.length) {
      obj.productTags = message.productTags.map((e) => ProductTag.toJSON(e));
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => ProductAttribute.toJSON(e));
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => ProductVariant.toJSON(e));
    }
    if (message.dimensions !== undefined) {
      obj.dimensions = Dimensions.toJSON(message.dimensions);
    }
    if (message.sizeCharts?.length) {
      obj.sizeCharts = message.sizeCharts.map((e) => SizeChart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Product>, I>>(base?: I): Product {
    return Product.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Product>, I>>(object: I): Product {
    const message = createBaseProduct();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.description = object.description ?? "";
    message.costPrice = object.costPrice ?? 0;
    message.basePrice = object.basePrice ?? 0;
    message.sku = object.sku ?? "";
    message.barcode = object.barcode ?? "";
    message.brandId = object.brandId ?? "";
    message.featured = object.featured ?? false;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.seo = (object.seo !== undefined && object.seo !== null) ? Seo.fromPartial(object.seo) : undefined;
    message.taxable = object.taxable ?? false;
    message.shippable = object.shippable ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.productTags = object.productTags?.map((e) => ProductTag.fromPartial(e)) || [];
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => ProductAttribute.fromPartial(e)) || [];
    message.variants = object.variants?.map((e) => ProductVariant.fromPartial(e)) || [];
    message.dimensions = (object.dimensions !== undefined && object.dimensions !== null)
      ? Dimensions.fromPartial(object.dimensions)
      : undefined;
    message.sizeCharts = object.sizeCharts?.map((e) => SizeChart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSizeChart(): SizeChart {
  return {
    id: "",
    name: "",
    category: "",
    description: undefined,
    productId: "",
    columns: [],
    rows: [],
    images: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const SizeChart: MessageFns<SizeChart> = {
  encode(message: SizeChart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.productId !== "") {
      writer.uint32(42).string(message.productId);
    }
    for (const v of message.columns) {
      SizeChartColumn.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.rows) {
      SizeChartRow.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.images) {
      SizeChartImage.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.columns.push(SizeChartColumn.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rows.push(SizeChartRow.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.images.push(SizeChartImage.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChart {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => SizeChartColumn.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => SizeChartRow.fromJSON(e)) : [],
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => SizeChartImage.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: SizeChart): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => SizeChartColumn.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => SizeChartRow.toJSON(e));
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => SizeChartImage.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChart>, I>>(base?: I): SizeChart {
    return SizeChart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChart>, I>>(object: I): SizeChart {
    const message = createBaseSizeChart();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.category = object.category ?? "";
    message.description = object.description ?? undefined;
    message.productId = object.productId ?? "";
    message.columns = object.columns?.map((e) => SizeChartColumn.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => SizeChartRow.fromPartial(e)) || [];
    message.images = object.images?.map((e) => SizeChartImage.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSizeChartColumn(): SizeChartColumn {
  return { id: "", name: "", type: "", unit: undefined, sizeChartId: "", createdAt: "" };
}

export const SizeChartColumn: MessageFns<SizeChartColumn> = {
  encode(message: SizeChartColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.unit !== undefined) {
      writer.uint32(34).string(message.unit);
    }
    if (message.sizeChartId !== "") {
      writer.uint32(42).string(message.sizeChartId);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sizeChartId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartColumn {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      unit: isSet(object.unit) ? globalThis.String(object.unit) : undefined,
      sizeChartId: isSet(object.sizeChartId) ? globalThis.String(object.sizeChartId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: SizeChartColumn): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.unit !== undefined) {
      obj.unit = message.unit;
    }
    if (message.sizeChartId !== "") {
      obj.sizeChartId = message.sizeChartId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartColumn>, I>>(base?: I): SizeChartColumn {
    return SizeChartColumn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartColumn>, I>>(object: I): SizeChartColumn {
    const message = createBaseSizeChartColumn();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.unit = object.unit ?? undefined;
    message.sizeChartId = object.sizeChartId ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseSizeChartRow(): SizeChartRow {
  return { id: "", name: "", cells: [] };
}

export const SizeChartRow: MessageFns<SizeChartRow> = {
  encode(message: SizeChartRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.cells) {
      SizeChartCell.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cells.push(SizeChartCell.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartRow {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => SizeChartCell.fromJSON(e)) : [],
    };
  },

  toJSON(message: SizeChartRow): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => SizeChartCell.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartRow>, I>>(base?: I): SizeChartRow {
    return SizeChartRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartRow>, I>>(object: I): SizeChartRow {
    const message = createBaseSizeChartRow();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.cells = object.cells?.map((e) => SizeChartCell.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSizeChartCell(): SizeChartCell {
  return { id: "", value: "" };
}

export const SizeChartCell: MessageFns<SizeChartCell> = {
  encode(message: SizeChartCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartCell {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SizeChartCell): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartCell>, I>>(base?: I): SizeChartCell {
    return SizeChartCell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartCell>, I>>(object: I): SizeChartCell {
    const message = createBaseSizeChartCell();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSizeChartImage(): SizeChartImage {
  return { id: "", url: "", name: "", sizeChartId: "", createdAt: "" };
}

export const SizeChartImage: MessageFns<SizeChartImage> = {
  encode(message: SizeChartImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.sizeChartId !== "") {
      writer.uint32(34).string(message.sizeChartId);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sizeChartId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartImage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sizeChartId: isSet(object.sizeChartId) ? globalThis.String(object.sizeChartId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: SizeChartImage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sizeChartId !== "") {
      obj.sizeChartId = message.sizeChartId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartImage>, I>>(base?: I): SizeChartImage {
    return SizeChartImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartImage>, I>>(object: I): SizeChartImage {
    const message = createBaseSizeChartImage();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.name = object.name ?? "";
    message.sizeChartId = object.sizeChartId ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseProductTag(): ProductTag {
  return { id: "", tag: undefined, productId: "" };
}

export const ProductTag: MessageFns<ProductTag> = {
  encode(message: ProductTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tag !== undefined) {
      Tag.encode(message.tag, writer.uint32(18).fork()).join();
    }
    if (message.productId !== "") {
      writer.uint32(26).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductTag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tag: isSet(object.tag) ? Tag.fromJSON(object.tag) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
    };
  },

  toJSON(message: ProductTag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tag !== undefined) {
      obj.tag = Tag.toJSON(message.tag);
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductTag>, I>>(base?: I): ProductTag {
    return ProductTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductTag>, I>>(object: I): ProductTag {
    const message = createBaseProductTag();
    message.id = object.id ?? "";
    message.tag = (object.tag !== undefined && object.tag !== null) ? Tag.fromPartial(object.tag) : undefined;
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseTag(): Tag {
  return { id: "", name: "", createdAt: "", updatedAt: "" };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(34).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseDimensions(): Dimensions {
  return { length: 0, width: 0, height: 0, weight: 0 };
}

export const Dimensions: MessageFns<Dimensions> = {
  encode(message: Dimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.length !== 0) {
      writer.uint32(13).float(message.length);
    }
    if (message.width !== 0) {
      writer.uint32(21).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(29).float(message.height);
    }
    if (message.weight !== 0) {
      writer.uint32(37).float(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.length = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.width = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimensions {
    return {
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: Dimensions): unknown {
    const obj: any = {};
    if (message.length !== 0) {
      obj.length = message.length;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dimensions>, I>>(base?: I): Dimensions {
    return Dimensions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dimensions>, I>>(object: I): Dimensions {
    const message = createBaseDimensions();
    message.length = object.length ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseSeo(): Seo {
  return { title: "", description: "", keywords: "" };
}

export const Seo: MessageFns<Seo> = {
  encode(message: Seo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.keywords !== "") {
      writer.uint32(26).string(message.keywords);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keywords = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Seo {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      keywords: isSet(object.keywords) ? globalThis.String(object.keywords) : "",
    };
  },

  toJSON(message: Seo): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.keywords !== "") {
      obj.keywords = message.keywords;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Seo>, I>>(base?: I): Seo {
    return Seo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Seo>, I>>(object: I): Seo {
    const message = createBaseSeo();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.keywords = object.keywords ?? "";
    return message;
  },
};

function createBaseProductVariant(): ProductVariant {
  return {
    id: "",
    sku: "",
    price: 0,
    lowStockThreshold: 0,
    stock: undefined,
    warehouseId: "",
    imageIds: [],
    attributes: [],
  };
}

export const ProductVariant: MessageFns<ProductVariant> = {
  encode(message: ProductVariant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sku !== "") {
      writer.uint32(18).string(message.sku);
    }
    if (message.price !== 0) {
      writer.uint32(29).float(message.price);
    }
    if (message.lowStockThreshold !== 0) {
      writer.uint32(37).float(message.lowStockThreshold);
    }
    if (message.stock !== undefined) {
      Stock.encode(message.stock, writer.uint32(42).fork()).join();
    }
    if (message.warehouseId !== "") {
      writer.uint32(50).string(message.warehouseId);
    }
    for (const v of message.imageIds) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.attributes) {
      VariantAttribute.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductVariant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.lowStockThreshold = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stock = Stock.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.warehouseId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.imageIds.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attributes.push(VariantAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductVariant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      lowStockThreshold: isSet(object.lowStockThreshold) ? globalThis.Number(object.lowStockThreshold) : 0,
      stock: isSet(object.stock) ? Stock.fromJSON(object.stock) : undefined,
      warehouseId: isSet(object.warehouseId) ? globalThis.String(object.warehouseId) : "",
      imageIds: globalThis.Array.isArray(object?.imageIds) ? object.imageIds.map((e: any) => globalThis.String(e)) : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VariantAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProductVariant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.lowStockThreshold !== 0) {
      obj.lowStockThreshold = message.lowStockThreshold;
    }
    if (message.stock !== undefined) {
      obj.stock = Stock.toJSON(message.stock);
    }
    if (message.warehouseId !== "") {
      obj.warehouseId = message.warehouseId;
    }
    if (message.imageIds?.length) {
      obj.imageIds = message.imageIds;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VariantAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductVariant>, I>>(base?: I): ProductVariant {
    return ProductVariant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductVariant>, I>>(object: I): ProductVariant {
    const message = createBaseProductVariant();
    message.id = object.id ?? "";
    message.sku = object.sku ?? "";
    message.price = object.price ?? 0;
    message.lowStockThreshold = object.lowStockThreshold ?? 0;
    message.stock = (object.stock !== undefined && object.stock !== null) ? Stock.fromPartial(object.stock) : undefined;
    message.warehouseId = object.warehouseId ?? "";
    message.imageIds = object.imageIds?.map((e) => e) || [];
    message.attributes = object.attributes?.map((e) => VariantAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStock(): Stock {
  return { quantity: 0, reserved: 0 };
}

export const Stock: MessageFns<Stock> = {
  encode(message: Stock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quantity !== 0) {
      writer.uint32(8).int32(message.quantity);
    }
    if (message.reserved !== 0) {
      writer.uint32(16).int32(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stock {
    return {
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
    };
  },

  toJSON(message: Stock): unknown {
    const obj: any = {};
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stock>, I>>(base?: I): Stock {
    return Stock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stock>, I>>(object: I): Stock {
    const message = createBaseStock();
    message.quantity = object.quantity ?? 0;
    message.reserved = object.reserved ?? 0;
    return message;
  },
};

function createBaseVariantAttribute(): VariantAttribute {
  return { id: "", name: "", value: "", extraValue: "" };
}

export const VariantAttribute: MessageFns<VariantAttribute> = {
  encode(message: VariantAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.extraValue !== "") {
      writer.uint32(34).string(message.extraValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      extraValue: isSet(object.extraValue) ? globalThis.String(object.extraValue) : "",
    };
  },

  toJSON(message: VariantAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.extraValue !== "") {
      obj.extraValue = message.extraValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VariantAttribute>, I>>(base?: I): VariantAttribute {
    return VariantAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VariantAttribute>, I>>(object: I): VariantAttribute {
    const message = createBaseVariantAttribute();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.extraValue = object.extraValue ?? "";
    return message;
  },
};

function createBaseImage(): Image {
  return { id: "", url: "", blurhash: "", isMain: false };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.blurhash !== "") {
      writer.uint32(26).string(message.blurhash);
    }
    if (message.isMain !== false) {
      writer.uint32(32).bool(message.isMain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blurhash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isMain = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      blurhash: isSet(object.blurhash) ? globalThis.String(object.blurhash) : "",
      isMain: isSet(object.isMain) ? globalThis.Boolean(object.isMain) : false,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.blurhash !== "") {
      obj.blurhash = message.blurhash;
    }
    if (message.isMain !== false) {
      obj.isMain = message.isMain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Image>, I>>(base?: I): Image {
    return Image.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image>, I>>(object: I): Image {
    const message = createBaseImage();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.blurhash = object.blurhash ?? "";
    message.isMain = object.isMain ?? false;
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { product: undefined };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductRequest>, I>>(base?: I): CreateProductRequest {
    return CreateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductRequest>, I>>(object: I): CreateProductRequest {
    const message = createBaseCreateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return { product: undefined };
}

export const CreateProductResponse: MessageFns<CreateProductResponse> = {
  encode(message: CreateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductResponse>, I>>(base?: I): CreateProductResponse {
    return CreateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductResponse>, I>>(object: I): CreateProductResponse {
    const message = createBaseCreateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { product: undefined };
}

export const UpdateProductRequest: MessageFns<UpdateProductRequest> = {
  encode(message: UpdateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(base?: I): UpdateProductRequest {
    return UpdateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(object: I): UpdateProductRequest {
    const message = createBaseUpdateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return { product: undefined };
}

export const UpdateProductResponse: MessageFns<UpdateProductResponse> = {
  encode(message: UpdateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(base?: I): UpdateProductResponse {
    return UpdateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(object: I): UpdateProductResponse {
    const message = createBaseUpdateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { id: "" };
}

export const DeleteProductRequest: MessageFns<DeleteProductRequest> = {
  encode(message: DeleteProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteProductRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(base?: I): DeleteProductRequest {
    return DeleteProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(object: I): DeleteProductRequest {
    const message = createBaseDeleteProductRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteProductResponse(): DeleteProductResponse {
  return { id: "" };
}

export const DeleteProductResponse: MessageFns<DeleteProductResponse> = {
  encode(message: DeleteProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteProductResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(base?: I): DeleteProductResponse {
    return DeleteProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(object: I): DeleteProductResponse {
    const message = createBaseDeleteProductResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateVariantRequest(): CreateVariantRequest {
  return { variant: undefined };
}

export const CreateVariantRequest: MessageFns<CreateVariantRequest> = {
  encode(message: CreateVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      ProductVariant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = ProductVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantRequest {
    return { variant: isSet(object.variant) ? ProductVariant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: CreateVariantRequest): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = ProductVariant.toJSON(message.variant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVariantRequest>, I>>(base?: I): CreateVariantRequest {
    return CreateVariantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVariantRequest>, I>>(object: I): CreateVariantRequest {
    const message = createBaseCreateVariantRequest();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? ProductVariant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseCreateVariantResponse(): CreateVariantResponse {
  return { variant: undefined };
}

export const CreateVariantResponse: MessageFns<CreateVariantResponse> = {
  encode(message: CreateVariantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      ProductVariant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = ProductVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantResponse {
    return { variant: isSet(object.variant) ? ProductVariant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: CreateVariantResponse): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = ProductVariant.toJSON(message.variant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVariantResponse>, I>>(base?: I): CreateVariantResponse {
    return CreateVariantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVariantResponse>, I>>(object: I): CreateVariantResponse {
    const message = createBaseCreateVariantResponse();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? ProductVariant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseCreateBrandRequest(): CreateBrandRequest {
  return { brand: undefined };
}

export const CreateBrandRequest: MessageFns<CreateBrandRequest> = {
  encode(message: CreateBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandRequest {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandRequest): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBrandRequest>, I>>(base?: I): CreateBrandRequest {
    return CreateBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBrandRequest>, I>>(object: I): CreateBrandRequest {
    const message = createBaseCreateBrandRequest();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseCreateBrandResponse(): CreateBrandResponse {
  return { brand: undefined };
}

export const CreateBrandResponse: MessageFns<CreateBrandResponse> = {
  encode(message: CreateBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandResponse {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandResponse): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBrandResponse>, I>>(base?: I): CreateBrandResponse {
    return CreateBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBrandResponse>, I>>(object: I): CreateBrandResponse {
    const message = createBaseCreateBrandResponse();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseGetAllCategoryResponse(): GetAllCategoryResponse {
  return { categories: [] };
}

export const GetAllCategoryResponse: MessageFns<GetAllCategoryResponse> = {
  encode(message: GetAllCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      Category.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.categories.push(Category.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCategoryResponse {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => Category.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllCategoryResponse): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => Category.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCategoryResponse>, I>>(base?: I): GetAllCategoryResponse {
    return GetAllCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCategoryResponse>, I>>(object: I): GetAllCategoryResponse {
    const message = createBaseGetAllCategoryResponse();
    message.categories = object.categories?.map((e) => Category.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateCategoryRequest(): CreateCategoryRequest {
  return { category: undefined };
}

export const CreateCategoryRequest: MessageFns<CreateCategoryRequest> = {
  encode(message: CreateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryRequest {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: CreateCategoryRequest): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCategoryRequest>, I>>(base?: I): CreateCategoryRequest {
    return CreateCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCategoryRequest>, I>>(object: I): CreateCategoryRequest {
    const message = createBaseCreateCategoryRequest();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseCreateCategoryResponse(): CreateCategoryResponse {
  return { category: undefined };
}

export const CreateCategoryResponse: MessageFns<CreateCategoryResponse> = {
  encode(message: CreateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryResponse {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: CreateCategoryResponse): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCategoryResponse>, I>>(base?: I): CreateCategoryResponse {
    return CreateCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCategoryResponse>, I>>(object: I): CreateCategoryResponse {
    const message = createBaseCreateCategoryResponse();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseUpdateCategoryRequest(): UpdateCategoryRequest {
  return { category: undefined };
}

export const UpdateCategoryRequest: MessageFns<UpdateCategoryRequest> = {
  encode(message: UpdateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryRequest {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: UpdateCategoryRequest): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryRequest>, I>>(base?: I): UpdateCategoryRequest {
    return UpdateCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryRequest>, I>>(object: I): UpdateCategoryRequest {
    const message = createBaseUpdateCategoryRequest();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseUpdateCategoryResponse(): UpdateCategoryResponse {
  return { category: undefined };
}

export const UpdateCategoryResponse: MessageFns<UpdateCategoryResponse> = {
  encode(message: UpdateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryResponse {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: UpdateCategoryResponse): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryResponse>, I>>(base?: I): UpdateCategoryResponse {
    return UpdateCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryResponse>, I>>(object: I): UpdateCategoryResponse {
    const message = createBaseUpdateCategoryResponse();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseDeleteCategoryRequest(): DeleteCategoryRequest {
  return { id: "" };
}

export const DeleteCategoryRequest: MessageFns<DeleteCategoryRequest> = {
  encode(message: DeleteCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCategoryRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryRequest>, I>>(base?: I): DeleteCategoryRequest {
    return DeleteCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryRequest>, I>>(object: I): DeleteCategoryRequest {
    const message = createBaseDeleteCategoryRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteCategoryResponse(): DeleteCategoryResponse {
  return { id: "" };
}

export const DeleteCategoryResponse: MessageFns<DeleteCategoryResponse> = {
  encode(message: DeleteCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCategoryResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryResponse>, I>>(base?: I): DeleteCategoryResponse {
    return DeleteCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryResponse>, I>>(object: I): DeleteCategoryResponse {
    const message = createBaseDeleteCategoryResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateImageRequest(): CreateImageRequest {
  return { image: undefined };
}

export const CreateImageRequest: MessageFns<CreateImageRequest> = {
  encode(message: CreateImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageRequest {
    return { image: isSet(object.image) ? Image.fromJSON(object.image) : undefined };
  },

  toJSON(message: CreateImageRequest): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageRequest>, I>>(base?: I): CreateImageRequest {
    return CreateImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageRequest>, I>>(object: I): CreateImageRequest {
    const message = createBaseCreateImageRequest();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseCreateImageResponse(): CreateImageResponse {
  return { image: undefined };
}

export const CreateImageResponse: MessageFns<CreateImageResponse> = {
  encode(message: CreateImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageResponse {
    return { image: isSet(object.image) ? Image.fromJSON(object.image) : undefined };
  },

  toJSON(message: CreateImageResponse): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageResponse>, I>>(base?: I): CreateImageResponse {
    return CreateImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageResponse>, I>>(object: I): CreateImageResponse {
    const message = createBaseCreateImageResponse();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [] };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsResponse>, I>>(base?: I): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsResponse>, I>>(object: I): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListProductsRequest(): ListProductsRequest {
  return {};
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(_: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListProductsRequest {
    return {};
  },

  toJSON(_: ListProductsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsRequest>, I>>(base?: I): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsRequest>, I>>(_: I): ListProductsRequest {
    const message = createBaseListProductsRequest();
    return message;
  },
};

function createBaseGetProductByIdRequest(): GetProductByIdRequest {
  return { id: "" };
}

export const GetProductByIdRequest: MessageFns<GetProductByIdRequest> = {
  encode(message: GetProductByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetProductByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductByIdRequest>, I>>(base?: I): GetProductByIdRequest {
    return GetProductByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductByIdRequest>, I>>(object: I): GetProductByIdRequest {
    const message = createBaseGetProductByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetProductBySlugRequest(): GetProductBySlugRequest {
  return { slug: "" };
}

export const GetProductBySlugRequest: MessageFns<GetProductBySlugRequest> = {
  encode(message: GetProductBySlugRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductBySlugRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductBySlugRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductBySlugRequest {
    return { slug: isSet(object.slug) ? globalThis.String(object.slug) : "" };
  },

  toJSON(message: GetProductBySlugRequest): unknown {
    const obj: any = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductBySlugRequest>, I>>(base?: I): GetProductBySlugRequest {
    return GetProductBySlugRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductBySlugRequest>, I>>(object: I): GetProductBySlugRequest {
    const message = createBaseGetProductBySlugRequest();
    message.slug = object.slug ?? "";
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { product: undefined };
}

export const GetProductResponse: MessageFns<GetProductResponse> = {
  encode(message: GetProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: GetProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductResponse>, I>>(base?: I): GetProductResponse {
    return GetProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductResponse>, I>>(object: I): GetProductResponse {
    const message = createBaseGetProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseVariant(): Variant {
  return { id: "", name: "", description: "", picture: "", priceUsd: undefined };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.picture !== "") {
      writer.uint32(34).string(message.picture);
    }
    if (message.priceUsd !== undefined) {
      Money.encode(message.priceUsd, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.picture = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.priceUsd = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : "",
      priceUsd: isSet(object.priceUsd) ? Money.fromJSON(object.priceUsd) : undefined,
    };
  },

  toJSON(message: Variant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.picture !== "") {
      obj.picture = message.picture;
    }
    if (message.priceUsd !== undefined) {
      obj.priceUsd = Money.toJSON(message.priceUsd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Variant>, I>>(base?: I): Variant {
    return Variant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Variant>, I>>(object: I): Variant {
    const message = createBaseVariant();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.picture = object.picture ?? "";
    message.priceUsd = (object.priceUsd !== undefined && object.priceUsd !== null)
      ? Money.fromPartial(object.priceUsd)
      : undefined;
    return message;
  },
};

function createBaseBrand(): Brand {
  return { id: "", name: "", logo: "" };
}

export const Brand: MessageFns<Brand> = {
  encode(message: Brand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Brand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Brand {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
    };
  },

  toJSON(message: Brand): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Brand>, I>>(base?: I): Brand {
    return Brand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Brand>, I>>(object: I): Brand {
    const message = createBaseBrand();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.logo = object.logo ?? "";
    return message;
  },
};

function createBaseCategory(): Category {
  return { id: "", name: "", parentId: "" };
}

export const Category: MessageFns<Category> = {
  encode(message: Category, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.parentId !== "") {
      writer.uint32(26).string(message.parentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Category {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Category {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
    };
  },

  toJSON(message: Category): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Category>, I>>(base?: I): Category {
    return Category.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Category>, I>>(object: I): Category {
    const message = createBaseCategory();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.parentId = object.parentId ?? "";
    return message;
  },
};

function createBaseGetWarehousesResponse(): GetWarehousesResponse {
  return { warehouses: [] };
}

export const GetWarehousesResponse: MessageFns<GetWarehousesResponse> = {
  encode(message: GetWarehousesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.warehouses) {
      Warehouse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWarehousesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWarehousesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.warehouses.push(Warehouse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWarehousesResponse {
    return {
      warehouses: globalThis.Array.isArray(object?.warehouses)
        ? object.warehouses.map((e: any) => Warehouse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetWarehousesResponse): unknown {
    const obj: any = {};
    if (message.warehouses?.length) {
      obj.warehouses = message.warehouses.map((e) => Warehouse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWarehousesResponse>, I>>(base?: I): GetWarehousesResponse {
    return GetWarehousesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWarehousesResponse>, I>>(object: I): GetWarehousesResponse {
    const message = createBaseGetWarehousesResponse();
    message.warehouses = object.warehouses?.map((e) => Warehouse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWarehouse(): Warehouse {
  return {
    id: "",
    name: "",
    code: "",
    location: [],
    address: "",
    manager: "",
    contact: "",
    status: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Warehouse: MessageFns<Warehouse> = {
  encode(message: Warehouse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    for (const v of message.location) {
      writer.uint32(34).string(v!);
    }
    if (message.address !== "") {
      writer.uint32(42).string(message.address);
    }
    if (message.manager !== "") {
      writer.uint32(50).string(message.manager);
    }
    if (message.contact !== "") {
      writer.uint32(58).string(message.contact);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Warehouse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWarehouse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contact = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Warehouse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.String(e)) : [],
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      contact: isSet(object.contact) ? globalThis.String(object.contact) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Warehouse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.location?.length) {
      obj.location = message.location;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.contact !== "") {
      obj.contact = message.contact;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Warehouse>, I>>(base?: I): Warehouse {
    return Warehouse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Warehouse>, I>>(object: I): Warehouse {
    const message = createBaseWarehouse();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.code = object.code ?? "";
    message.location = object.location?.map((e) => e) || [];
    message.address = object.address ?? "";
    message.manager = object.manager ?? "";
    message.contact = object.contact ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSearchProductsRequest(): SearchProductsRequest {
  return { query: "" };
}

export const SearchProductsRequest: MessageFns<SearchProductsRequest> = {
  encode(message: SearchProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SearchProductsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(base?: I): SearchProductsRequest {
    return SearchProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(object: I): SearchProductsRequest {
    const message = createBaseSearchProductsRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchProductsResponse(): SearchProductsResponse {
  return { results: [] };
}

export const SearchProductsResponse: MessageFns<SearchProductsResponse> = {
  encode(message: SearchProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchProductsResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(base?: I): SearchProductsResponse {
    return SearchProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(object: I): SearchProductsResponse {
    const message = createBaseSearchProductsResponse();
    message.results = object.results?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuoteRequest(): GetQuoteRequest {
  return { address: undefined, items: [] };
}

export const GetQuoteRequest: MessageFns<GetQuoteRequest> = {
  encode(message: GetQuoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteRequest {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetQuoteRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(base?: I): GetQuoteRequest {
    return GetQuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(object: I): GetQuoteRequest {
    const message = createBaseGetQuoteRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuoteResponse(): GetQuoteResponse {
  return { costUsd: undefined };
}

export const GetQuoteResponse: MessageFns<GetQuoteResponse> = {
  encode(message: GetQuoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.costUsd !== undefined) {
      Money.encode(message.costUsd, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.costUsd = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteResponse {
    return { costUsd: isSet(object.costUsd) ? Money.fromJSON(object.costUsd) : undefined };
  },

  toJSON(message: GetQuoteResponse): unknown {
    const obj: any = {};
    if (message.costUsd !== undefined) {
      obj.costUsd = Money.toJSON(message.costUsd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(base?: I): GetQuoteResponse {
    return GetQuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(object: I): GetQuoteResponse {
    const message = createBaseGetQuoteResponse();
    message.costUsd = (object.costUsd !== undefined && object.costUsd !== null)
      ? Money.fromPartial(object.costUsd)
      : undefined;
    return message;
  },
};

function createBaseShipOrderRequest(): ShipOrderRequest {
  return { address: undefined, items: [] };
}

export const ShipOrderRequest: MessageFns<ShipOrderRequest> = {
  encode(message: ShipOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipOrderRequest {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: ShipOrderRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShipOrderRequest>, I>>(base?: I): ShipOrderRequest {
    return ShipOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShipOrderRequest>, I>>(object: I): ShipOrderRequest {
    const message = createBaseShipOrderRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipOrderResponse(): ShipOrderResponse {
  return { trackingId: "" };
}

export const ShipOrderResponse: MessageFns<ShipOrderResponse> = {
  encode(message: ShipOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipOrderResponse {
    return { trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "" };
  },

  toJSON(message: ShipOrderResponse): unknown {
    const obj: any = {};
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShipOrderResponse>, I>>(base?: I): ShipOrderResponse {
    return ShipOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShipOrderResponse>, I>>(object: I): ShipOrderResponse {
    const message = createBaseShipOrderResponse();
    message.trackingId = object.trackingId ?? "";
    return message;
  },
};

function createBaseCancelShipmentRequest(): CancelShipmentRequest {
  return { orderId: "", trackingId: "" };
}

export const CancelShipmentRequest: MessageFns<CancelShipmentRequest> = {
  encode(message: CancelShipmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.trackingId !== "") {
      writer.uint32(18).string(message.trackingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelShipmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelShipmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelShipmentRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "",
    };
  },

  toJSON(message: CancelShipmentRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelShipmentRequest>, I>>(base?: I): CancelShipmentRequest {
    return CancelShipmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelShipmentRequest>, I>>(object: I): CancelShipmentRequest {
    const message = createBaseCancelShipmentRequest();
    message.orderId = object.orderId ?? "";
    message.trackingId = object.trackingId ?? "";
    return message;
  },
};

function createBaseCancelShipmentResponse(): CancelShipmentResponse {
  return { success: false, message: "" };
}

export const CancelShipmentResponse: MessageFns<CancelShipmentResponse> = {
  encode(message: CancelShipmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelShipmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelShipmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelShipmentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CancelShipmentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelShipmentResponse>, I>>(base?: I): CancelShipmentResponse {
    return CancelShipmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelShipmentResponse>, I>>(object: I): CancelShipmentResponse {
    const message = createBaseCancelShipmentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseMoney(): Money {
  return { currencyCode: "", units: 0, nanos: 0 };
}

export const Money: MessageFns<Money> = {
  encode(message: Money, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.units !== 0) {
      writer.uint32(16).int64(message.units);
    }
    if (message.nanos !== 0) {
      writer.uint32(24).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Money {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.units = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Money {
    return {
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      units: isSet(object.units) ? globalThis.Number(object.units) : 0,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: Money): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.units !== 0) {
      obj.units = Math.round(message.units);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Money>, I>>(base?: I): Money {
    return Money.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Money>, I>>(object: I): Money {
    const message = createBaseMoney();
    message.currencyCode = object.currencyCode ?? "";
    message.units = object.units ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseGetSupportedCurrenciesResponse(): GetSupportedCurrenciesResponse {
  return { currencyCodes: [] };
}

export const GetSupportedCurrenciesResponse: MessageFns<GetSupportedCurrenciesResponse> = {
  encode(message: GetSupportedCurrenciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.currencyCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSupportedCurrenciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSupportedCurrenciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSupportedCurrenciesResponse {
    return {
      currencyCodes: globalThis.Array.isArray(object?.currencyCodes)
        ? object.currencyCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetSupportedCurrenciesResponse): unknown {
    const obj: any = {};
    if (message.currencyCodes?.length) {
      obj.currencyCodes = message.currencyCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSupportedCurrenciesResponse>, I>>(base?: I): GetSupportedCurrenciesResponse {
    return GetSupportedCurrenciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSupportedCurrenciesResponse>, I>>(
    object: I,
  ): GetSupportedCurrenciesResponse {
    const message = createBaseGetSupportedCurrenciesResponse();
    message.currencyCodes = object.currencyCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCurrencyConversionRequest(): CurrencyConversionRequest {
  return { from: undefined, toCode: "" };
}

export const CurrencyConversionRequest: MessageFns<CurrencyConversionRequest> = {
  encode(message: CurrencyConversionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== undefined) {
      Money.encode(message.from, writer.uint32(10).fork()).join();
    }
    if (message.toCode !== "") {
      writer.uint32(18).string(message.toCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyConversionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyConversionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = Money.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyConversionRequest {
    return {
      from: isSet(object.from) ? Money.fromJSON(object.from) : undefined,
      toCode: isSet(object.toCode) ? globalThis.String(object.toCode) : "",
    };
  },

  toJSON(message: CurrencyConversionRequest): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Money.toJSON(message.from);
    }
    if (message.toCode !== "") {
      obj.toCode = message.toCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyConversionRequest>, I>>(base?: I): CurrencyConversionRequest {
    return CurrencyConversionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyConversionRequest>, I>>(object: I): CurrencyConversionRequest {
    const message = createBaseCurrencyConversionRequest();
    message.from = (object.from !== undefined && object.from !== null) ? Money.fromPartial(object.from) : undefined;
    message.toCode = object.toCode ?? "";
    return message;
  },
};

function createBaseSendOTPResetPasswordRequest(): SendOTPResetPasswordRequest {
  return { email: "", verificationCode: "" };
}

export const SendOTPResetPasswordRequest: MessageFns<SendOTPResetPasswordRequest> = {
  encode(message: SendOTPResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.verificationCode !== "") {
      writer.uint32(18).string(message.verificationCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendOTPResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOTPResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verificationCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOTPResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      verificationCode: isSet(object.verificationCode) ? globalThis.String(object.verificationCode) : "",
    };
  },

  toJSON(message: SendOTPResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.verificationCode !== "") {
      obj.verificationCode = message.verificationCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOTPResetPasswordRequest>, I>>(base?: I): SendOTPResetPasswordRequest {
    return SendOTPResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOTPResetPasswordRequest>, I>>(object: I): SendOTPResetPasswordRequest {
    const message = createBaseSendOTPResetPasswordRequest();
    message.email = object.email ?? "";
    message.verificationCode = object.verificationCode ?? "";
    return message;
  },
};

function createBaseSendOTPResetPasswordResponse(): SendOTPResetPasswordResponse {
  return { success: false, message: "" };
}

export const SendOTPResetPasswordResponse: MessageFns<SendOTPResetPasswordResponse> = {
  encode(message: SendOTPResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendOTPResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOTPResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOTPResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendOTPResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOTPResetPasswordResponse>, I>>(base?: I): SendOTPResetPasswordResponse {
    return SendOTPResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOTPResetPasswordResponse>, I>>(object: I): SendOTPResetPasswordResponse {
    const message = createBaseSendOTPResetPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSendWelcomeEmailRequest(): SendWelcomeEmailRequest {
  return { email: "", name: "", token: "" };
}

export const SendWelcomeEmailRequest: MessageFns<SendWelcomeEmailRequest> = {
  encode(message: SendWelcomeEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendWelcomeEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendWelcomeEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendWelcomeEmailRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: SendWelcomeEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendWelcomeEmailRequest>, I>>(base?: I): SendWelcomeEmailRequest {
    return SendWelcomeEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendWelcomeEmailRequest>, I>>(object: I): SendWelcomeEmailRequest {
    const message = createBaseSendWelcomeEmailRequest();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseSendWelcomeEmailResponse(): SendWelcomeEmailResponse {
  return { success: false, message: "" };
}

export const SendWelcomeEmailResponse: MessageFns<SendWelcomeEmailResponse> = {
  encode(message: SendWelcomeEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendWelcomeEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendWelcomeEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendWelcomeEmailResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendWelcomeEmailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendWelcomeEmailResponse>, I>>(base?: I): SendWelcomeEmailResponse {
    return SendWelcomeEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendWelcomeEmailResponse>, I>>(object: I): SendWelcomeEmailResponse {
    const message = createBaseSendWelcomeEmailResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAdRequest(): AdRequest {
  return { contextKeys: [] };
}

export const AdRequest: MessageFns<AdRequest> = {
  encode(message: AdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contextKeys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contextKeys.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdRequest {
    return {
      contextKeys: globalThis.Array.isArray(object?.contextKeys)
        ? object.contextKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AdRequest): unknown {
    const obj: any = {};
    if (message.contextKeys?.length) {
      obj.contextKeys = message.contextKeys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdRequest>, I>>(base?: I): AdRequest {
    return AdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdRequest>, I>>(object: I): AdRequest {
    const message = createBaseAdRequest();
    message.contextKeys = object.contextKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseAdResponse(): AdResponse {
  return { ads: [] };
}

export const AdResponse: MessageFns<AdResponse> = {
  encode(message: AdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ads) {
      Ad.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ads.push(Ad.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdResponse {
    return { ads: globalThis.Array.isArray(object?.ads) ? object.ads.map((e: any) => Ad.fromJSON(e)) : [] };
  },

  toJSON(message: AdResponse): unknown {
    const obj: any = {};
    if (message.ads?.length) {
      obj.ads = message.ads.map((e) => Ad.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdResponse>, I>>(base?: I): AdResponse {
    return AdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdResponse>, I>>(object: I): AdResponse {
    const message = createBaseAdResponse();
    message.ads = object.ads?.map((e) => Ad.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAd(): Ad {
  return { redirectUrl: "", text: "" };
}

export const Ad: MessageFns<Ad> = {
  encode(message: Ad, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUrl !== "") {
      writer.uint32(10).string(message.redirectUrl);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ad {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ad {
    return {
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: Ad): unknown {
    const obj: any = {};
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ad>, I>>(base?: I): Ad {
    return Ad.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ad>, I>>(object: I): Ad {
    const message = createBaseAd();
    message.redirectUrl = object.redirectUrl ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseNewBrandRequest(): NewBrandRequest {
  return { brand: undefined };
}

export const NewBrandRequest: MessageFns<NewBrandRequest> = {
  encode(message: NewBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBrandRequest {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: NewBrandRequest): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBrandRequest>, I>>(base?: I): NewBrandRequest {
    return NewBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBrandRequest>, I>>(object: I): NewBrandRequest {
    const message = createBaseNewBrandRequest();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseNewBrandResponse(): NewBrandResponse {
  return { success: false, message: "", brand: undefined };
}

export const NewBrandResponse: MessageFns<NewBrandResponse> = {
  encode(message: NewBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined,
    };
  },

  toJSON(message: NewBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBrandResponse>, I>>(base?: I): NewBrandResponse {
    return NewBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBrandResponse>, I>>(object: I): NewBrandResponse {
    const message = createBaseNewBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseRemoveBrandRequest(): RemoveBrandRequest {
  return { id: "" };
}

export const RemoveBrandRequest: MessageFns<RemoveBrandRequest> = {
  encode(message: RemoveBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveBrandRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: RemoveBrandRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveBrandRequest>, I>>(base?: I): RemoveBrandRequest {
    return RemoveBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveBrandRequest>, I>>(object: I): RemoveBrandRequest {
    const message = createBaseRemoveBrandRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRemoveBrandResponse(): RemoveBrandResponse {
  return { success: false, message: "" };
}

export const RemoveBrandResponse: MessageFns<RemoveBrandResponse> = {
  encode(message: RemoveBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RemoveBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveBrandResponse>, I>>(base?: I): RemoveBrandResponse {
    return RemoveBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveBrandResponse>, I>>(object: I): RemoveBrandResponse {
    const message = createBaseRemoveBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetAllBrandResponse(): GetAllBrandResponse {
  return { success: false, message: "", brands: [] };
}

export const GetAllBrandResponse: MessageFns<GetAllBrandResponse> = {
  encode(message: GetAllBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.brands) {
      Brand.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brands.push(Brand.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      brands: globalThis.Array.isArray(object?.brands) ? object.brands.map((e: any) => Brand.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAllBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.brands?.length) {
      obj.brands = message.brands.map((e) => Brand.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllBrandResponse>, I>>(base?: I): GetAllBrandResponse {
    return GetAllBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllBrandResponse>, I>>(object: I): GetAllBrandResponse {
    const message = createBaseGetAllBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.brands = object.brands?.map((e) => Brand.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { service: "" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0 };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return { status: isSet(object.status) ? healthCheckResponse_ServingStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthCheckResponse_ServingStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return {
    userId: "",
    currencyCode: "",
    totalAmount: 0,
    items: [],
    shippingAddressId: "",
    paymentId: "",
    paymentStatus: 0,
  };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currencyCode !== "") {
      writer.uint32(18).string(message.currencyCode);
    }
    if (message.totalAmount !== 0) {
      writer.uint32(25).double(message.totalAmount);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.shippingAddressId !== "") {
      writer.uint32(42).string(message.shippingAddressId);
    }
    if (message.paymentId !== "") {
      writer.uint32(50).string(message.paymentId);
    }
    if (message.paymentStatus !== 0) {
      writer.uint32(56).int32(message.paymentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.totalAmount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shippingAddressId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.paymentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      totalAmount: isSet(object.totalAmount) ? globalThis.Number(object.totalAmount) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      shippingAddressId: isSet(object.shippingAddressId) ? globalThis.String(object.shippingAddressId) : "",
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      paymentStatus: isSet(object.paymentStatus) ? paymentStatusFromJSON(object.paymentStatus) : 0,
    };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.totalAmount !== 0) {
      obj.totalAmount = message.totalAmount;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.shippingAddressId !== "") {
      obj.shippingAddressId = message.shippingAddressId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.paymentStatus !== 0) {
      obj.paymentStatus = paymentStatusToJSON(message.paymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(base?: I): CreateOrderRequest {
    return CreateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(object: I): CreateOrderRequest {
    const message = createBaseCreateOrderRequest();
    message.userId = object.userId ?? "";
    message.currencyCode = object.currencyCode ?? "";
    message.totalAmount = object.totalAmount ?? 0;
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.shippingAddressId = object.shippingAddressId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.paymentStatus = object.paymentStatus ?? 0;
    return message;
  },
};

function createBaseOrderItem(): OrderItem {
  return { productId: "", variantId: "", quantity: 0, price: undefined };
}

export const OrderItem: MessageFns<OrderItem> = {
  encode(message: OrderItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.variantId !== "") {
      writer.uint32(18).string(message.variantId);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int32(message.quantity);
    }
    if (message.price !== undefined) {
      Money.encode(message.price, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.price = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderItem {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? Money.fromJSON(object.price) : undefined,
    };
  },

  toJSON(message: OrderItem): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== undefined) {
      obj.price = Money.toJSON(message.price);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderItem>, I>>(base?: I): OrderItem {
    return OrderItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderItem>, I>>(object: I): OrderItem {
    const message = createBaseOrderItem();
    message.productId = object.productId ?? "";
    message.variantId = object.variantId ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Money.fromPartial(object.price) : undefined;
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { orderId: "", status: 0 };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(base?: I): CreateOrderResponse {
    return CreateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(object: I): CreateOrderResponse {
    const message = createBaseCreateOrderResponse();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetOrderStatusRequest(): GetOrderStatusRequest {
  return { orderId: "" };
}

export const GetOrderStatusRequest: MessageFns<GetOrderStatusRequest> = {
  encode(message: GetOrderStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderStatusRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrderStatusRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderStatusRequest>, I>>(base?: I): GetOrderStatusRequest {
    return GetOrderStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderStatusRequest>, I>>(object: I): GetOrderStatusRequest {
    const message = createBaseGetOrderStatusRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseGetOrderStatusResponse(): GetOrderStatusResponse {
  return { status: 0 };
}

export const GetOrderStatusResponse: MessageFns<GetOrderStatusResponse> = {
  encode(message: GetOrderStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderStatusResponse {
    return { status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: GetOrderStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderStatusResponse>, I>>(base?: I): GetOrderStatusResponse {
    return GetOrderStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderStatusResponse>, I>>(object: I): GetOrderStatusResponse {
    const message = createBaseGetOrderStatusResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetOrderRequest(): GetOrderRequest {
  return { orderId: "" };
}

export const GetOrderRequest: MessageFns<GetOrderRequest> = {
  encode(message: GetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: GetOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderRequest>, I>>(base?: I): GetOrderRequest {
    return GetOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderRequest>, I>>(object: I): GetOrderRequest {
    const message = createBaseGetOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseGetOrderResponse(): GetOrderResponse {
  return { order: undefined };
}

export const GetOrderResponse: MessageFns<GetOrderResponse> = {
  encode(message: GetOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: GetOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderResponse>, I>>(base?: I): GetOrderResponse {
    return GetOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderResponse>, I>>(object: I): GetOrderResponse {
    const message = createBaseGetOrderResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseOrder(): Order {
  return {
    id: "",
    userId: "",
    status: "",
    totalAmount: 0,
    shippingAddressId: "",
    items: [],
    paymentId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.totalAmount !== 0) {
      writer.uint32(33).double(message.totalAmount);
    }
    if (message.shippingAddressId !== "") {
      writer.uint32(42).string(message.shippingAddressId);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.paymentId !== "") {
      writer.uint32(58).string(message.paymentId);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.totalAmount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shippingAddressId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      totalAmount: isSet(object.totalAmount) ? globalThis.Number(object.totalAmount) : 0,
      shippingAddressId: isSet(object.shippingAddressId) ? globalThis.String(object.shippingAddressId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.totalAmount !== 0) {
      obj.totalAmount = message.totalAmount;
    }
    if (message.shippingAddressId !== "") {
      obj.shippingAddressId = message.shippingAddressId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.status = object.status ?? "";
    message.totalAmount = object.totalAmount ?? 0;
    message.shippingAddressId = object.shippingAddressId ?? "";
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.paymentId = object.paymentId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseUpdateOrderStatusRequest(): UpdateOrderStatusRequest {
  return { orderId: "", status: 0 };
}

export const UpdateOrderStatusRequest: MessageFns<UpdateOrderStatusRequest> = {
  encode(message: UpdateOrderStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderStatusRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: UpdateOrderStatusRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderStatusRequest>, I>>(base?: I): UpdateOrderStatusRequest {
    return UpdateOrderStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderStatusRequest>, I>>(object: I): UpdateOrderStatusRequest {
    const message = createBaseUpdateOrderStatusRequest();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseUpdateOrderStatusResponse(): UpdateOrderStatusResponse {
  return { orderId: "", status: 0, steps: [], message: "" };
}

export const UpdateOrderStatusResponse: MessageFns<UpdateOrderStatusResponse> = {
  encode(message: UpdateOrderStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.steps) {
      OrderStep.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.steps.push(OrderStep.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderStatusResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => OrderStep.fromJSON(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: UpdateOrderStatusResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => OrderStep.toJSON(e));
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderStatusResponse>, I>>(base?: I): UpdateOrderStatusResponse {
    return UpdateOrderStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderStatusResponse>, I>>(object: I): UpdateOrderStatusResponse {
    const message = createBaseUpdateOrderStatusResponse();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    message.steps = object.steps?.map((e) => OrderStep.fromPartial(e)) || [];
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { orderId: "" };
}

export const CancelOrderRequest: MessageFns<CancelOrderRequest> = {
  encode(message: CancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderRequest {
    return { orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "" };
  },

  toJSON(message: CancelOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(base?: I): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(object: I): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.orderId = object.orderId ?? "";
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return { orderId: "", status: 0, message: "" };
}

export const CancelOrderResponse: MessageFns<CancelOrderResponse> = {
  encode(message: CancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderResponse {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CancelOrderResponse): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(base?: I): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(object: I): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseOrderStep(): OrderStep {
  return { service: "", status: 0, error: "", timestamp: "" };
}

export const OrderStep: MessageFns<OrderStep> = {
  encode(message: OrderStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderStep {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      status: isSet(object.status) ? stepStatusFromJSON(object.status) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: OrderStep): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.status !== 0) {
      obj.status = stepStatusToJSON(message.status);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderStep>, I>>(base?: I): OrderStep {
    return OrderStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderStep>, I>>(object: I): OrderStep {
    const message = createBaseOrderStep();
    message.service = object.service ?? "";
    message.status = object.status ?? 0;
    message.error = object.error ?? "";
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseValidateAndReserveRequest(): ValidateAndReserveRequest {
  return { userId: "", variants: [] };
}

export const ValidateAndReserveRequest: MessageFns<ValidateAndReserveRequest> = {
  encode(message: ValidateAndReserveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.variants) {
      ProductVariant.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAndReserveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAndReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variants.push(ProductVariant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateAndReserveRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => ProductVariant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidateAndReserveRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => ProductVariant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateAndReserveRequest>, I>>(base?: I): ValidateAndReserveRequest {
    return ValidateAndReserveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateAndReserveRequest>, I>>(object: I): ValidateAndReserveRequest {
    const message = createBaseValidateAndReserveRequest();
    message.userId = object.userId ?? "";
    message.variants = object.variants?.map((e) => ProductVariant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidateAndReserveResponse(): ValidateAndReserveResponse {
  return { success: false, reservationId: "", validationErrors: [] };
}

export const ValidateAndReserveResponse: MessageFns<ValidateAndReserveResponse> = {
  encode(message: ValidateAndReserveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.reservationId !== "") {
      writer.uint32(18).string(message.reservationId);
    }
    for (const v of message.validationErrors) {
      ValidationError.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAndReserveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAndReserveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validationErrors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateAndReserveResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reservationId: isSet(object.reservationId) ? globalThis.String(object.reservationId) : "",
      validationErrors: globalThis.Array.isArray(object?.validationErrors)
        ? object.validationErrors.map((e: any) => ValidationError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidateAndReserveResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reservationId !== "") {
      obj.reservationId = message.reservationId;
    }
    if (message.validationErrors?.length) {
      obj.validationErrors = message.validationErrors.map((e) => ValidationError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateAndReserveResponse>, I>>(base?: I): ValidateAndReserveResponse {
    return ValidateAndReserveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateAndReserveResponse>, I>>(object: I): ValidateAndReserveResponse {
    const message = createBaseValidateAndReserveResponse();
    message.success = object.success ?? false;
    message.reservationId = object.reservationId ?? "";
    message.validationErrors = object.validationErrors?.map((e) => ValidationError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { variantId: "", error: "" };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationError {
    return {
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ValidationError): unknown {
    const obj: any = {};
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationError>, I>>(base?: I): ValidationError {
    return ValidationError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationError>, I>>(object: I): ValidationError {
    const message = createBaseValidationError();
    message.variantId = object.variantId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseReleaseReservationRequest(): ReleaseReservationRequest {
  return { reservationId: "" };
}

export const ReleaseReservationRequest: MessageFns<ReleaseReservationRequest> = {
  encode(message: ReleaseReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservationId !== "") {
      writer.uint32(10).string(message.reservationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseReservationRequest {
    return { reservationId: isSet(object.reservationId) ? globalThis.String(object.reservationId) : "" };
  },

  toJSON(message: ReleaseReservationRequest): unknown {
    const obj: any = {};
    if (message.reservationId !== "") {
      obj.reservationId = message.reservationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReleaseReservationRequest>, I>>(base?: I): ReleaseReservationRequest {
    return ReleaseReservationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReleaseReservationRequest>, I>>(object: I): ReleaseReservationRequest {
    const message = createBaseReleaseReservationRequest();
    message.reservationId = object.reservationId ?? "";
    return message;
  },
};

function createBaseReleaseReservationResponse(): ReleaseReservationResponse {
  return { success: false, message: "" };
}

export const ReleaseReservationResponse: MessageFns<ReleaseReservationResponse> = {
  encode(message: ReleaseReservationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseReservationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseReservationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseReservationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ReleaseReservationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReleaseReservationResponse>, I>>(base?: I): ReleaseReservationResponse {
    return ReleaseReservationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReleaseReservationResponse>, I>>(object: I): ReleaseReservationResponse {
    const message = createBaseReleaseReservationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCommitReservationRequest(): CommitReservationRequest {
  return { reservationId: "" };
}

export const CommitReservationRequest: MessageFns<CommitReservationRequest> = {
  encode(message: CommitReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservationId !== "") {
      writer.uint32(10).string(message.reservationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitReservationRequest {
    return { reservationId: isSet(object.reservationId) ? globalThis.String(object.reservationId) : "" };
  },

  toJSON(message: CommitReservationRequest): unknown {
    const obj: any = {};
    if (message.reservationId !== "") {
      obj.reservationId = message.reservationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitReservationRequest>, I>>(base?: I): CommitReservationRequest {
    return CommitReservationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitReservationRequest>, I>>(object: I): CommitReservationRequest {
    const message = createBaseCommitReservationRequest();
    message.reservationId = object.reservationId ?? "";
    return message;
  },
};

function createBaseCommitReservationResponse(): CommitReservationResponse {
  return { success: false, message: "" };
}

export const CommitReservationResponse: MessageFns<CommitReservationResponse> = {
  encode(message: CommitReservationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitReservationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitReservationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitReservationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CommitReservationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitReservationResponse>, I>>(base?: I): CommitReservationResponse {
    return CommitReservationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitReservationResponse>, I>>(object: I): CommitReservationResponse {
    const message = createBaseCommitReservationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseInitiatePaymentRequest(): InitiatePaymentRequest {
  return { orderId: "", amount: 0, provider: 0, currency: "" };
}

export const InitiatePaymentRequest: MessageFns<InitiatePaymentRequest> = {
  encode(message: InitiatePaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePaymentRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      provider: isSet(object.provider) ? paymentProviderFromJSON(object.provider) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: InitiatePaymentRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.provider !== 0) {
      obj.provider = paymentProviderToJSON(message.provider);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiatePaymentRequest>, I>>(base?: I): InitiatePaymentRequest {
    return InitiatePaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiatePaymentRequest>, I>>(object: I): InitiatePaymentRequest {
    const message = createBaseInitiatePaymentRequest();
    message.orderId = object.orderId ?? "";
    message.amount = object.amount ?? 0;
    message.provider = object.provider ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseInitiatePaymentResponse(): InitiatePaymentResponse {
  return { paymentId: "", redirectUrl: "", status: 0 };
}

export const InitiatePaymentResponse: MessageFns<InitiatePaymentResponse> = {
  encode(message: InitiatePaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(18).string(message.redirectUrl);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePaymentResponse {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : "",
      status: isSet(object.status) ? paymentStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: InitiatePaymentResponse): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.status !== 0) {
      obj.status = paymentStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiatePaymentResponse>, I>>(base?: I): InitiatePaymentResponse {
    return InitiatePaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiatePaymentResponse>, I>>(object: I): InitiatePaymentResponse {
    const message = createBaseInitiatePaymentResponse();
    message.paymentId = object.paymentId ?? "";
    message.redirectUrl = object.redirectUrl ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseVerifyPaymentRequest(): VerifyPaymentRequest {
  return { paymentId: "" };
}

export const VerifyPaymentRequest: MessageFns<VerifyPaymentRequest> = {
  encode(message: VerifyPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyPaymentRequest {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: VerifyPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyPaymentRequest>, I>>(base?: I): VerifyPaymentRequest {
    return VerifyPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyPaymentRequest>, I>>(object: I): VerifyPaymentRequest {
    const message = createBaseVerifyPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseVerifyPaymentResponse(): VerifyPaymentResponse {
  return { status: 0 };
}

export const VerifyPaymentResponse: MessageFns<VerifyPaymentResponse> = {
  encode(message: VerifyPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyPaymentResponse {
    return { status: isSet(object.status) ? paymentStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: VerifyPaymentResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = paymentStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyPaymentResponse>, I>>(base?: I): VerifyPaymentResponse {
    return VerifyPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyPaymentResponse>, I>>(object: I): VerifyPaymentResponse {
    const message = createBaseVerifyPaymentResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCancelPaymentRequest(): CancelPaymentRequest {
  return { paymentId: "" };
}

export const CancelPaymentRequest: MessageFns<CancelPaymentRequest> = {
  encode(message: CancelPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPaymentRequest {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: CancelPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPaymentRequest>, I>>(base?: I): CancelPaymentRequest {
    return CancelPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPaymentRequest>, I>>(object: I): CancelPaymentRequest {
    const message = createBaseCancelPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseCancelPaymentResponse(): CancelPaymentResponse {
  return { success: false };
}

export const CancelPaymentResponse: MessageFns<CancelPaymentResponse> = {
  encode(message: CancelPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPaymentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CancelPaymentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPaymentResponse>, I>>(base?: I): CancelPaymentResponse {
    return CancelPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPaymentResponse>, I>>(object: I): CancelPaymentResponse {
    const message = createBaseCancelPaymentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRefundPaymentRequest(): RefundPaymentRequest {
  return { paymentId: "" };
}

export const RefundPaymentRequest: MessageFns<RefundPaymentRequest> = {
  encode(message: RefundPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundPaymentRequest {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: RefundPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundPaymentRequest>, I>>(base?: I): RefundPaymentRequest {
    return RefundPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundPaymentRequest>, I>>(object: I): RefundPaymentRequest {
    const message = createBaseRefundPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseRefundPaymentResponse(): RefundPaymentResponse {
  return { success: false };
}

export const RefundPaymentResponse: MessageFns<RefundPaymentResponse> = {
  encode(message: RefundPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundPaymentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RefundPaymentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundPaymentResponse>, I>>(base?: I): RefundPaymentResponse {
    return RefundPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundPaymentResponse>, I>>(object: I): RefundPaymentResponse {
    const message = createBaseRefundPaymentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetPaymentStatusRequest(): GetPaymentStatusRequest {
  return { paymentId: "" };
}

export const GetPaymentStatusRequest: MessageFns<GetPaymentStatusRequest> = {
  encode(message: GetPaymentStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentStatusRequest {
    return { paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "" };
  },

  toJSON(message: GetPaymentStatusRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentStatusRequest>, I>>(base?: I): GetPaymentStatusRequest {
    return GetPaymentStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentStatusRequest>, I>>(object: I): GetPaymentStatusRequest {
    const message = createBaseGetPaymentStatusRequest();
    message.paymentId = object.paymentId ?? "";
    return message;
  },
};

function createBaseGetPaymentStatusResponse(): GetPaymentStatusResponse {
  return { status: 0 };
}

export const GetPaymentStatusResponse: MessageFns<GetPaymentStatusResponse> = {
  encode(message: GetPaymentStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaymentStatusResponse {
    return { status: isSet(object.status) ? paymentStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: GetPaymentStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = paymentStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaymentStatusResponse>, I>>(base?: I): GetPaymentStatusResponse {
    return GetPaymentStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaymentStatusResponse>, I>>(object: I): GetPaymentStatusResponse {
    const message = createBaseGetPaymentStatusResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

export type AddressServiceService = typeof AddressServiceService;
export const AddressServiceService = {
  getCountries: {
    path: "/nexuraTelemetry.AddressService/GetCountries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetCountriesResponse) => Buffer.from(GetCountriesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCountriesResponse.decode(value),
  },
  getProvincesByCountry: {
    path: "/nexuraTelemetry.AddressService/GetProvincesByCountry",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProvincesByCountryRequest) =>
      Buffer.from(GetProvincesByCountryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProvincesByCountryRequest.decode(value),
    responseSerialize: (value: GetProvincesResponse) => Buffer.from(GetProvincesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProvincesResponse.decode(value),
  },
  getDistrictsByProvince: {
    path: "/nexuraTelemetry.AddressService/GetDistrictsByProvince",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDistrictsByProvinceRequest) =>
      Buffer.from(GetDistrictsByProvinceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDistrictsByProvinceRequest.decode(value),
    responseSerialize: (value: GetDistrictsResponse) => Buffer.from(GetDistrictsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDistrictsResponse.decode(value),
  },
  getWardsByDistrict: {
    path: "/nexuraTelemetry.AddressService/GetWardsByDistrict",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWardsByDistrictRequest) =>
      Buffer.from(GetWardsByDistrictRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWardsByDistrictRequest.decode(value),
    responseSerialize: (value: GetWardsResponse) => Buffer.from(GetWardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWardsResponse.decode(value),
  },
  addAddress: {
    path: "/nexuraTelemetry.AddressService/AddAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddAddressRequest) => Buffer.from(AddAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  updateAddress: {
    path: "/nexuraTelemetry.AddressService/UpdateAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAddressRequest) => Buffer.from(UpdateAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  deleteAddress: {
    path: "/nexuraTelemetry.AddressService/DeleteAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAddressRequest) => Buffer.from(DeleteAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteAddressRequest.decode(value),
    responseSerialize: (value: DeleteAddressResponse) => Buffer.from(DeleteAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteAddressResponse.decode(value),
  },
  getAddresses: {
    path: "/nexuraTelemetry.AddressService/GetAddresses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAddressesRequest) => Buffer.from(GetAddressesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAddressesRequest.decode(value),
    responseSerialize: (value: GetAddressesResponse) => Buffer.from(GetAddressesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAddressesResponse.decode(value),
  },
} as const;

export interface AddressServiceServer extends UntypedServiceImplementation {
  getCountries: handleUnaryCall<Empty, GetCountriesResponse>;
  getProvincesByCountry: handleUnaryCall<GetProvincesByCountryRequest, GetProvincesResponse>;
  getDistrictsByProvince: handleUnaryCall<GetDistrictsByProvinceRequest, GetDistrictsResponse>;
  getWardsByDistrict: handleUnaryCall<GetWardsByDistrictRequest, GetWardsResponse>;
  addAddress: handleUnaryCall<AddAddressRequest, AddressResponse>;
  updateAddress: handleUnaryCall<UpdateAddressRequest, AddressResponse>;
  deleteAddress: handleUnaryCall<DeleteAddressRequest, DeleteAddressResponse>;
  getAddresses: handleUnaryCall<GetAddressesRequest, GetAddressesResponse>;
}

export interface AddressServiceClient extends Client {
  getCountries(
    request: Empty,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getCountries(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getCountries(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
}

export const AddressServiceClient = makeGenericClientConstructor(
  AddressServiceService,
  "nexuraTelemetry.AddressService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AddressServiceClient;
  service: typeof AddressServiceService;
  serviceName: string;
};

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  getUser: {
    path: "/nexuraTelemetry.UserService/GetUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRequest) => Buffer.from(GetUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserRequest.decode(value),
    responseSerialize: (value: GetUserResponse) => Buffer.from(GetUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserResponse.decode(value),
  },
  updateUser: {
    path: "/nexuraTelemetry.UserService/UpdateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserRequest) => Buffer.from(UpdateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserRequest.decode(value),
    responseSerialize: (value: UpdateUserResponse) => Buffer.from(UpdateUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateUserResponse.decode(value),
  },
  deleteUser: {
    path: "/nexuraTelemetry.UserService/DeleteUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteUserRequest) => Buffer.from(DeleteUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteUserRequest.decode(value),
    responseSerialize: (value: DeleteUserResponse) => Buffer.from(DeleteUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteUserResponse.decode(value),
  },
  registerUser: {
    path: "/nexuraTelemetry.UserService/RegisterUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterUserRequest) => Buffer.from(RegisterUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterUserRequest.decode(value),
    responseSerialize: (value: RegisterUserResponse) => Buffer.from(RegisterUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterUserResponse.decode(value),
  },
  loginUser: {
    path: "/nexuraTelemetry.UserService/LoginUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginUserRequest) => Buffer.from(LoginUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginUserRequest.decode(value),
    responseSerialize: (value: LoginUserResponse) => Buffer.from(LoginUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginUserResponse.decode(value),
  },
  forgotPassword: {
    path: "/nexuraTelemetry.UserService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) => Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse) => Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ForgotPasswordResponse.decode(value),
  },
  validateOtp: {
    path: "/nexuraTelemetry.UserService/ValidateOTP",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateOTPRequest) => Buffer.from(ValidateOTPRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateOTPRequest.decode(value),
    responseSerialize: (value: ValidateOTPResponse) => Buffer.from(ValidateOTPResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateOTPResponse.decode(value),
  },
  resetPassword: {
    path: "/nexuraTelemetry.UserService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest) => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse) => Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResetPasswordResponse.decode(value),
  },
  verifyAccount: {
    path: "/nexuraTelemetry.UserService/VerifyAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyAccountRequest) => Buffer.from(VerifyAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyAccountRequest.decode(value),
    responseSerialize: (value: VerifyAccountResponse) => Buffer.from(VerifyAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyAccountResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  getUser: handleUnaryCall<GetUserRequest, GetUserResponse>;
  updateUser: handleUnaryCall<UpdateUserRequest, UpdateUserResponse>;
  deleteUser: handleUnaryCall<DeleteUserRequest, DeleteUserResponse>;
  registerUser: handleUnaryCall<RegisterUserRequest, RegisterUserResponse>;
  loginUser: handleUnaryCall<LoginUserRequest, LoginUserResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  validateOtp: handleUnaryCall<ValidateOTPRequest, ValidateOTPResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  verifyAccount: handleUnaryCall<VerifyAccountRequest, VerifyAccountResponse>;
}

export interface UserServiceClient extends Client {
  getUser(
    request: GetUserRequest,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
}

export const UserServiceClient = makeGenericClientConstructor(
  UserServiceService,
  "nexuraTelemetry.UserService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): UserServiceClient;
  service: typeof UserServiceService;
  serviceName: string;
};

export type CartServiceService = typeof CartServiceService;
export const CartServiceService = {
  getCart: {
    path: "/nexuraTelemetry.CartService/GetCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCartRequest) => Buffer.from(GetCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCartRequest.decode(value),
    responseSerialize: (value: GetCartResponse) => Buffer.from(GetCartResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCartResponse.decode(value),
  },
  addItem: {
    path: "/nexuraTelemetry.CartService/AddItem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddItemRequest) => Buffer.from(AddItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddItemRequest.decode(value),
    responseSerialize: (value: AddItemResponse) => Buffer.from(AddItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddItemResponse.decode(value),
  },
  updateItem: {
    path: "/nexuraTelemetry.CartService/UpdateItem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateItemRequest) => Buffer.from(UpdateItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateItemRequest.decode(value),
    responseSerialize: (value: UpdateItemResponse) => Buffer.from(UpdateItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateItemResponse.decode(value),
  },
  removeItem: {
    path: "/nexuraTelemetry.CartService/RemoveItem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveItemRequest) => Buffer.from(RemoveItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveItemRequest.decode(value),
    responseSerialize: (value: RemoveItemResponse) => Buffer.from(RemoveItemResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemoveItemResponse.decode(value),
  },
  clearCart: {
    path: "/nexuraTelemetry.CartService/ClearCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearCartRequest) => Buffer.from(ClearCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClearCartRequest.decode(value),
    responseSerialize: (value: ClearCartResponse) => Buffer.from(ClearCartResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ClearCartResponse.decode(value),
  },
  validateCart: {
    path: "/nexuraTelemetry.CartService/ValidateCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateCartRequest) => Buffer.from(ValidateCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateCartRequest.decode(value),
    responseSerialize: (value: ValidateCartResponse) => Buffer.from(ValidateCartResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateCartResponse.decode(value),
  },
} as const;

export interface CartServiceServer extends UntypedServiceImplementation {
  getCart: handleUnaryCall<GetCartRequest, GetCartResponse>;
  addItem: handleUnaryCall<AddItemRequest, AddItemResponse>;
  updateItem: handleUnaryCall<UpdateItemRequest, UpdateItemResponse>;
  removeItem: handleUnaryCall<RemoveItemRequest, RemoveItemResponse>;
  clearCart: handleUnaryCall<ClearCartRequest, ClearCartResponse>;
  validateCart: handleUnaryCall<ValidateCartRequest, ValidateCartResponse>;
}

export interface CartServiceClient extends Client {
  getCart(
    request: GetCartRequest,
    callback: (error: ServiceError | null, response: GetCartResponse) => void,
  ): ClientUnaryCall;
  getCart(
    request: GetCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCartResponse) => void,
  ): ClientUnaryCall;
  getCart(
    request: GetCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCartResponse) => void,
  ): ClientUnaryCall;
  addItem(
    request: AddItemRequest,
    callback: (error: ServiceError | null, response: AddItemResponse) => void,
  ): ClientUnaryCall;
  addItem(
    request: AddItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddItemResponse) => void,
  ): ClientUnaryCall;
  addItem(
    request: AddItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddItemResponse) => void,
  ): ClientUnaryCall;
  updateItem(
    request: UpdateItemRequest,
    callback: (error: ServiceError | null, response: UpdateItemResponse) => void,
  ): ClientUnaryCall;
  updateItem(
    request: UpdateItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateItemResponse) => void,
  ): ClientUnaryCall;
  updateItem(
    request: UpdateItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateItemResponse) => void,
  ): ClientUnaryCall;
  removeItem(
    request: RemoveItemRequest,
    callback: (error: ServiceError | null, response: RemoveItemResponse) => void,
  ): ClientUnaryCall;
  removeItem(
    request: RemoveItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RemoveItemResponse) => void,
  ): ClientUnaryCall;
  removeItem(
    request: RemoveItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RemoveItemResponse) => void,
  ): ClientUnaryCall;
  clearCart(
    request: ClearCartRequest,
    callback: (error: ServiceError | null, response: ClearCartResponse) => void,
  ): ClientUnaryCall;
  clearCart(
    request: ClearCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClearCartResponse) => void,
  ): ClientUnaryCall;
  clearCart(
    request: ClearCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClearCartResponse) => void,
  ): ClientUnaryCall;
  validateCart(
    request: ValidateCartRequest,
    callback: (error: ServiceError | null, response: ValidateCartResponse) => void,
  ): ClientUnaryCall;
  validateCart(
    request: ValidateCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateCartResponse) => void,
  ): ClientUnaryCall;
  validateCart(
    request: ValidateCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateCartResponse) => void,
  ): ClientUnaryCall;
}

export const CartServiceClient = makeGenericClientConstructor(
  CartServiceService,
  "nexuraTelemetry.CartService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CartServiceClient;
  service: typeof CartServiceService;
  serviceName: string;
};

export type RecommendationServiceService = typeof RecommendationServiceService;
export const RecommendationServiceService = {
  listRecommendations: {
    path: "/nexuraTelemetry.RecommendationService/ListRecommendations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRecommendationsRequest) =>
      Buffer.from(ListRecommendationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListRecommendationsRequest.decode(value),
    responseSerialize: (value: ListRecommendationsResponse) =>
      Buffer.from(ListRecommendationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListRecommendationsResponse.decode(value),
  },
} as const;

export interface RecommendationServiceServer extends UntypedServiceImplementation {
  listRecommendations: handleUnaryCall<ListRecommendationsRequest, ListRecommendationsResponse>;
}

export interface RecommendationServiceClient extends Client {
  listRecommendations(
    request: ListRecommendationsRequest,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
  listRecommendations(
    request: ListRecommendationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
  listRecommendations(
    request: ListRecommendationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
}

export const RecommendationServiceClient = makeGenericClientConstructor(
  RecommendationServiceService,
  "nexuraTelemetry.RecommendationService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RecommendationServiceClient;
  service: typeof RecommendationServiceService;
  serviceName: string;
};

export type ProductCatalogServiceService = typeof ProductCatalogServiceService;
export const ProductCatalogServiceService = {
  createProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductRequest) => Buffer.from(CreateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductRequest.decode(value),
    responseSerialize: (value: CreateProductResponse) => Buffer.from(CreateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductResponse.decode(value),
  },
  updateProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductRequest) => Buffer.from(UpdateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductRequest.decode(value),
    responseSerialize: (value: UpdateProductResponse) => Buffer.from(UpdateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductResponse.decode(value),
  },
  deleteProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductRequest) => Buffer.from(DeleteProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductRequest.decode(value),
    responseSerialize: (value: DeleteProductResponse) => Buffer.from(DeleteProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductResponse.decode(value),
  },
  createVariant: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateVariant",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateVariantRequest) => Buffer.from(CreateVariantRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateVariantRequest.decode(value),
    responseSerialize: (value: CreateVariantResponse) => Buffer.from(CreateVariantResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateVariantResponse.decode(value),
  },
  getProductById: {
    path: "/nexuraTelemetry.ProductCatalogService/GetProductById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductByIdRequest) => Buffer.from(GetProductByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductByIdRequest.decode(value),
    responseSerialize: (value: GetProductResponse) => Buffer.from(GetProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductResponse.decode(value),
  },
  getProductBySlug: {
    path: "/nexuraTelemetry.ProductCatalogService/GetProductBySlug",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductBySlugRequest) => Buffer.from(GetProductBySlugRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductBySlugRequest.decode(value),
    responseSerialize: (value: GetProductResponse) => Buffer.from(GetProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductResponse.decode(value),
  },
  listProducts: {
    path: "/nexuraTelemetry.ProductCatalogService/ListProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProductsRequest) => Buffer.from(ListProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListProductsRequest.decode(value),
    responseSerialize: (value: ListProductsResponse) => Buffer.from(ListProductsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListProductsResponse.decode(value),
  },
  createBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBrandRequest) => Buffer.from(CreateBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBrandRequest.decode(value),
    responseSerialize: (value: CreateBrandResponse) => Buffer.from(CreateBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBrandResponse.decode(value),
  },
  newBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/NewBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NewBrandRequest) => Buffer.from(NewBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NewBrandRequest.decode(value),
    responseSerialize: (value: NewBrandResponse) => Buffer.from(NewBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NewBrandResponse.decode(value),
  },
  removeBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/RemoveBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveBrandRequest) => Buffer.from(RemoveBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveBrandRequest.decode(value),
    responseSerialize: (value: RemoveBrandResponse) => Buffer.from(RemoveBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemoveBrandResponse.decode(value),
  },
  getAllBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/GetAllBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAllBrandResponse) => Buffer.from(GetAllBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllBrandResponse.decode(value),
  },
  getVariantsForCart: {
    path: "/nexuraTelemetry.ProductCatalogService/GetVariantsForCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVariantsForCartRequest) =>
      Buffer.from(GetVariantsForCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetVariantsForCartRequest.decode(value),
    responseSerialize: (value: GetVariantsForCartResponse) =>
      Buffer.from(GetVariantsForCartResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetVariantsForCartResponse.decode(value),
  },
  createCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCategoryRequest) => Buffer.from(CreateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCategoryRequest.decode(value),
    responseSerialize: (value: CreateCategoryResponse) => Buffer.from(CreateCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateCategoryResponse.decode(value),
  },
  updateCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCategoryRequest) => Buffer.from(UpdateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateCategoryRequest.decode(value),
    responseSerialize: (value: UpdateCategoryResponse) => Buffer.from(UpdateCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateCategoryResponse.decode(value),
  },
  deleteCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCategoryRequest) => Buffer.from(DeleteCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteCategoryRequest.decode(value),
    responseSerialize: (value: DeleteCategoryResponse) => Buffer.from(DeleteCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteCategoryResponse.decode(value),
  },
  getAllCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/GetAllCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAllCategoryResponse) => Buffer.from(GetAllCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllCategoryResponse.decode(value),
  },
  getProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/GetProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductAttributesRequest) =>
      Buffer.from(GetProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductAttributesRequest.decode(value),
    responseSerialize: (value: GetProductAttributesResponse) =>
      Buffer.from(GetProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductAttributesResponse.decode(value),
  },
  updateProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductAttributesRequest) =>
      Buffer.from(UpdateProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductAttributesRequest.decode(value),
    responseSerialize: (value: UpdateProductAttributesResponse) =>
      Buffer.from(UpdateProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductAttributesResponse.decode(value),
  },
  deleteProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductAttributesRequest) =>
      Buffer.from(DeleteProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductAttributesRequest.decode(value),
    responseSerialize: (value: DeleteProductAttributesResponse) =>
      Buffer.from(DeleteProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductAttributesResponse.decode(value),
  },
  createProductAttribute: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateProductAttribute",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductAttributeRequest) =>
      Buffer.from(CreateProductAttributeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductAttributeRequest.decode(value),
    responseSerialize: (value: CreateProductAttributeResponse) =>
      Buffer.from(CreateProductAttributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductAttributeResponse.decode(value),
  },
  getWarehouses: {
    path: "/nexuraTelemetry.ProductCatalogService/GetWarehouses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetWarehousesResponse) => Buffer.from(GetWarehousesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWarehousesResponse.decode(value),
  },
  validateAndReserve: {
    path: "/nexuraTelemetry.ProductCatalogService/ValidateAndReserve",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateAndReserveRequest) =>
      Buffer.from(ValidateAndReserveRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateAndReserveRequest.decode(value),
    responseSerialize: (value: ValidateAndReserveResponse) =>
      Buffer.from(ValidateAndReserveResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateAndReserveResponse.decode(value),
  },
  releaseReservation: {
    path: "/nexuraTelemetry.ProductCatalogService/ReleaseReservation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReleaseReservationRequest) =>
      Buffer.from(ReleaseReservationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReleaseReservationRequest.decode(value),
    responseSerialize: (value: ReleaseReservationResponse) =>
      Buffer.from(ReleaseReservationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReleaseReservationResponse.decode(value),
  },
  commitReservation: {
    path: "/nexuraTelemetry.ProductCatalogService/CommitReservation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommitReservationRequest) => Buffer.from(CommitReservationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommitReservationRequest.decode(value),
    responseSerialize: (value: CommitReservationResponse) =>
      Buffer.from(CommitReservationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CommitReservationResponse.decode(value),
  },
} as const;

export interface ProductCatalogServiceServer extends UntypedServiceImplementation {
  createProduct: handleUnaryCall<CreateProductRequest, CreateProductResponse>;
  updateProduct: handleUnaryCall<UpdateProductRequest, UpdateProductResponse>;
  deleteProduct: handleUnaryCall<DeleteProductRequest, DeleteProductResponse>;
  createVariant: handleUnaryCall<CreateVariantRequest, CreateVariantResponse>;
  getProductById: handleUnaryCall<GetProductByIdRequest, GetProductResponse>;
  getProductBySlug: handleUnaryCall<GetProductBySlugRequest, GetProductResponse>;
  listProducts: handleUnaryCall<ListProductsRequest, ListProductsResponse>;
  createBrand: handleUnaryCall<CreateBrandRequest, CreateBrandResponse>;
  newBrand: handleUnaryCall<NewBrandRequest, NewBrandResponse>;
  removeBrand: handleUnaryCall<RemoveBrandRequest, RemoveBrandResponse>;
  getAllBrand: handleUnaryCall<Empty, GetAllBrandResponse>;
  getVariantsForCart: handleUnaryCall<GetVariantsForCartRequest, GetVariantsForCartResponse>;
  createCategory: handleUnaryCall<CreateCategoryRequest, CreateCategoryResponse>;
  updateCategory: handleUnaryCall<UpdateCategoryRequest, UpdateCategoryResponse>;
  deleteCategory: handleUnaryCall<DeleteCategoryRequest, DeleteCategoryResponse>;
  getAllCategory: handleUnaryCall<Empty, GetAllCategoryResponse>;
  getProductAttributes: handleUnaryCall<GetProductAttributesRequest, GetProductAttributesResponse>;
  updateProductAttributes: handleUnaryCall<UpdateProductAttributesRequest, UpdateProductAttributesResponse>;
  deleteProductAttributes: handleUnaryCall<DeleteProductAttributesRequest, DeleteProductAttributesResponse>;
  createProductAttribute: handleUnaryCall<CreateProductAttributeRequest, CreateProductAttributeResponse>;
  getWarehouses: handleUnaryCall<Empty, GetWarehousesResponse>;
  validateAndReserve: handleUnaryCall<ValidateAndReserveRequest, ValidateAndReserveResponse>;
  releaseReservation: handleUnaryCall<ReleaseReservationRequest, ReleaseReservationResponse>;
  commitReservation: handleUnaryCall<CommitReservationRequest, CommitReservationResponse>;
}

export interface ProductCatalogServiceClient extends Client {
  createProduct(
    request: CreateProductRequest,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  getProductById(
    request: GetProductByIdRequest,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProductById(
    request: GetProductByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProductById(
    request: GetProductByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProductBySlug(
    request: GetProductBySlugRequest,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProductBySlug(
    request: GetProductBySlugRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProductBySlug(
    request: GetProductBySlugRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  getVariantsForCart(
    request: GetVariantsForCartRequest,
    callback: (error: ServiceError | null, response: GetVariantsForCartResponse) => void,
  ): ClientUnaryCall;
  getVariantsForCart(
    request: GetVariantsForCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetVariantsForCartResponse) => void,
  ): ClientUnaryCall;
  getVariantsForCart(
    request: GetVariantsForCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetVariantsForCartResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
  validateAndReserve(
    request: ValidateAndReserveRequest,
    callback: (error: ServiceError | null, response: ValidateAndReserveResponse) => void,
  ): ClientUnaryCall;
  validateAndReserve(
    request: ValidateAndReserveRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateAndReserveResponse) => void,
  ): ClientUnaryCall;
  validateAndReserve(
    request: ValidateAndReserveRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateAndReserveResponse) => void,
  ): ClientUnaryCall;
  releaseReservation(
    request: ReleaseReservationRequest,
    callback: (error: ServiceError | null, response: ReleaseReservationResponse) => void,
  ): ClientUnaryCall;
  releaseReservation(
    request: ReleaseReservationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReleaseReservationResponse) => void,
  ): ClientUnaryCall;
  releaseReservation(
    request: ReleaseReservationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReleaseReservationResponse) => void,
  ): ClientUnaryCall;
  commitReservation(
    request: CommitReservationRequest,
    callback: (error: ServiceError | null, response: CommitReservationResponse) => void,
  ): ClientUnaryCall;
  commitReservation(
    request: CommitReservationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommitReservationResponse) => void,
  ): ClientUnaryCall;
  commitReservation(
    request: CommitReservationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommitReservationResponse) => void,
  ): ClientUnaryCall;
}

export const ProductCatalogServiceClient = makeGenericClientConstructor(
  ProductCatalogServiceService,
  "nexuraTelemetry.ProductCatalogService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ProductCatalogServiceClient;
  service: typeof ProductCatalogServiceService;
  serviceName: string;
};

export type ShippingServiceService = typeof ShippingServiceService;
export const ShippingServiceService = {
  getQuote: {
    path: "/nexuraTelemetry.ShippingService/GetQuote",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetQuoteRequest) => Buffer.from(GetQuoteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetQuoteRequest.decode(value),
    responseSerialize: (value: GetQuoteResponse) => Buffer.from(GetQuoteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetQuoteResponse.decode(value),
  },
  shipOrder: {
    path: "/nexuraTelemetry.ShippingService/ShipOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShipOrderRequest) => Buffer.from(ShipOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ShipOrderRequest.decode(value),
    responseSerialize: (value: ShipOrderResponse) => Buffer.from(ShipOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShipOrderResponse.decode(value),
  },
  cancelShipment: {
    path: "/nexuraTelemetry.ShippingService/CancelShipment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelShipmentRequest) => Buffer.from(CancelShipmentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelShipmentRequest.decode(value),
    responseSerialize: (value: CancelShipmentResponse) => Buffer.from(CancelShipmentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CancelShipmentResponse.decode(value),
  },
} as const;

export interface ShippingServiceServer extends UntypedServiceImplementation {
  getQuote: handleUnaryCall<GetQuoteRequest, GetQuoteResponse>;
  shipOrder: handleUnaryCall<ShipOrderRequest, ShipOrderResponse>;
  cancelShipment: handleUnaryCall<CancelShipmentRequest, CancelShipmentResponse>;
}

export interface ShippingServiceClient extends Client {
  getQuote(
    request: GetQuoteRequest,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  getQuote(
    request: GetQuoteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  getQuote(
    request: GetQuoteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
  cancelShipment(
    request: CancelShipmentRequest,
    callback: (error: ServiceError | null, response: CancelShipmentResponse) => void,
  ): ClientUnaryCall;
  cancelShipment(
    request: CancelShipmentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelShipmentResponse) => void,
  ): ClientUnaryCall;
  cancelShipment(
    request: CancelShipmentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelShipmentResponse) => void,
  ): ClientUnaryCall;
}

export const ShippingServiceClient = makeGenericClientConstructor(
  ShippingServiceService,
  "nexuraTelemetry.ShippingService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ShippingServiceClient;
  service: typeof ShippingServiceService;
  serviceName: string;
};

export type CurrencyServiceService = typeof CurrencyServiceService;
export const CurrencyServiceService = {
  getSupportedCurrencies: {
    path: "/nexuraTelemetry.CurrencyService/GetSupportedCurrencies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetSupportedCurrenciesResponse) =>
      Buffer.from(GetSupportedCurrenciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSupportedCurrenciesResponse.decode(value),
  },
  convert: {
    path: "/nexuraTelemetry.CurrencyService/Convert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CurrencyConversionRequest) =>
      Buffer.from(CurrencyConversionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CurrencyConversionRequest.decode(value),
    responseSerialize: (value: Money) => Buffer.from(Money.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Money.decode(value),
  },
} as const;

export interface CurrencyServiceServer extends UntypedServiceImplementation {
  getSupportedCurrencies: handleUnaryCall<Empty, GetSupportedCurrenciesResponse>;
  convert: handleUnaryCall<CurrencyConversionRequest, Money>;
}

export interface CurrencyServiceClient extends Client {
  getSupportedCurrencies(
    request: Empty,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  getSupportedCurrencies(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  getSupportedCurrencies(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
}

export const CurrencyServiceClient = makeGenericClientConstructor(
  CurrencyServiceService,
  "nexuraTelemetry.CurrencyService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CurrencyServiceClient;
  service: typeof CurrencyServiceService;
  serviceName: string;
};

export type EmailServiceService = typeof EmailServiceService;
export const EmailServiceService = {
  /** rpc SendOrderConfirmation(SendOrderConfirmationRequest) returns (Empty) {} */
  sendOtpResetPassword: {
    path: "/nexuraTelemetry.EmailService/SendOTPResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendOTPResetPasswordRequest) =>
      Buffer.from(SendOTPResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendOTPResetPasswordRequest.decode(value),
    responseSerialize: (value: SendOTPResetPasswordResponse) =>
      Buffer.from(SendOTPResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendOTPResetPasswordResponse.decode(value),
  },
  sendWelcomeEmail: {
    path: "/nexuraTelemetry.EmailService/SendWelcomeEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendWelcomeEmailRequest) => Buffer.from(SendWelcomeEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendWelcomeEmailRequest.decode(value),
    responseSerialize: (value: SendWelcomeEmailResponse) =>
      Buffer.from(SendWelcomeEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendWelcomeEmailResponse.decode(value),
  },
} as const;

export interface EmailServiceServer extends UntypedServiceImplementation {
  /** rpc SendOrderConfirmation(SendOrderConfirmationRequest) returns (Empty) {} */
  sendOtpResetPassword: handleUnaryCall<SendOTPResetPasswordRequest, SendOTPResetPasswordResponse>;
  sendWelcomeEmail: handleUnaryCall<SendWelcomeEmailRequest, SendWelcomeEmailResponse>;
}

export interface EmailServiceClient extends Client {
  /** rpc SendOrderConfirmation(SendOrderConfirmationRequest) returns (Empty) {} */
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
}

export const EmailServiceClient = makeGenericClientConstructor(
  EmailServiceService,
  "nexuraTelemetry.EmailService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EmailServiceClient;
  service: typeof EmailServiceService;
  serviceName: string;
};

export type AdServiceService = typeof AdServiceService;
export const AdServiceService = {
  getAds: {
    path: "/nexuraTelemetry.AdService/GetAds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdRequest) => Buffer.from(AdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdRequest.decode(value),
    responseSerialize: (value: AdResponse) => Buffer.from(AdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdResponse.decode(value),
  },
} as const;

export interface AdServiceServer extends UntypedServiceImplementation {
  getAds: handleUnaryCall<AdRequest, AdResponse>;
}

export interface AdServiceClient extends Client {
  getAds(request: AdRequest, callback: (error: ServiceError | null, response: AdResponse) => void): ClientUnaryCall;
  getAds(
    request: AdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdResponse) => void,
  ): ClientUnaryCall;
  getAds(
    request: AdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdResponse) => void,
  ): ClientUnaryCall;
}

export const AdServiceClient = makeGenericClientConstructor(
  AdServiceService,
  "nexuraTelemetry.AdService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AdServiceClient;
  service: typeof AdServiceService;
  serviceName: string;
};

/** Health service definition */
export type HealthServiceService = typeof HealthServiceService;
export const HealthServiceService = {
  /** Check is the health checking method for all services */
  check: {
    path: "/nexuraTelemetry.HealthService/Check",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  /** Watch is for watching health status changes */
  watch: {
    path: "/nexuraTelemetry.HealthService/Watch",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface HealthServiceServer extends UntypedServiceImplementation {
  /** Check is the health checking method for all services */
  check: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
  /** Watch is for watching health status changes */
  watch: handleServerStreamingCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface HealthServiceClient extends Client {
  /** Check is the health checking method for all services */
  check(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  check(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  check(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  /** Watch is for watching health status changes */
  watch(request: HealthCheckRequest, options?: Partial<CallOptions>): ClientReadableStream<HealthCheckResponse>;
  watch(
    request: HealthCheckRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<HealthCheckResponse>;
}

export const HealthServiceClient = makeGenericClientConstructor(
  HealthServiceService,
  "nexuraTelemetry.HealthService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): HealthServiceClient;
  service: typeof HealthServiceService;
  serviceName: string;
};

export type OrderServiceService = typeof OrderServiceService;
export const OrderServiceService = {
  createOrder: {
    path: "/nexuraTelemetry.OrderService/CreateOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateOrderRequest) => Buffer.from(CreateOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateOrderRequest.decode(value),
    responseSerialize: (value: CreateOrderResponse) => Buffer.from(CreateOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateOrderResponse.decode(value),
  },
  getOrderStatus: {
    path: "/nexuraTelemetry.OrderService/GetOrderStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderStatusRequest) => Buffer.from(GetOrderStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderStatusRequest.decode(value),
    responseSerialize: (value: GetOrderStatusResponse) => Buffer.from(GetOrderStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetOrderStatusResponse.decode(value),
  },
  getOrder: {
    path: "/nexuraTelemetry.OrderService/GetOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderRequest) => Buffer.from(GetOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderRequest.decode(value),
    responseSerialize: (value: GetOrderResponse) => Buffer.from(GetOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetOrderResponse.decode(value),
  },
  cancelOrder: {
    path: "/nexuraTelemetry.OrderService/CancelOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelOrderRequest) => Buffer.from(CancelOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelOrderRequest.decode(value),
    responseSerialize: (value: CancelOrderResponse) => Buffer.from(CancelOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CancelOrderResponse.decode(value),
  },
  updateOrderStatus: {
    path: "/nexuraTelemetry.OrderService/UpdateOrderStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateOrderStatusRequest) => Buffer.from(UpdateOrderStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateOrderStatusRequest.decode(value),
    responseSerialize: (value: UpdateOrderStatusResponse) =>
      Buffer.from(UpdateOrderStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateOrderStatusResponse.decode(value),
  },
} as const;

export interface OrderServiceServer extends UntypedServiceImplementation {
  createOrder: handleUnaryCall<CreateOrderRequest, CreateOrderResponse>;
  getOrderStatus: handleUnaryCall<GetOrderStatusRequest, GetOrderStatusResponse>;
  getOrder: handleUnaryCall<GetOrderRequest, GetOrderResponse>;
  cancelOrder: handleUnaryCall<CancelOrderRequest, CancelOrderResponse>;
  updateOrderStatus: handleUnaryCall<UpdateOrderStatusRequest, UpdateOrderStatusResponse>;
}

export interface OrderServiceClient extends Client {
  createOrder(
    request: CreateOrderRequest,
    callback: (error: ServiceError | null, response: CreateOrderResponse) => void,
  ): ClientUnaryCall;
  createOrder(
    request: CreateOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateOrderResponse) => void,
  ): ClientUnaryCall;
  createOrder(
    request: CreateOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateOrderResponse) => void,
  ): ClientUnaryCall;
  getOrderStatus(
    request: GetOrderStatusRequest,
    callback: (error: ServiceError | null, response: GetOrderStatusResponse) => void,
  ): ClientUnaryCall;
  getOrderStatus(
    request: GetOrderStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetOrderStatusResponse) => void,
  ): ClientUnaryCall;
  getOrderStatus(
    request: GetOrderStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetOrderStatusResponse) => void,
  ): ClientUnaryCall;
  getOrder(
    request: GetOrderRequest,
    callback: (error: ServiceError | null, response: GetOrderResponse) => void,
  ): ClientUnaryCall;
  getOrder(
    request: GetOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetOrderResponse) => void,
  ): ClientUnaryCall;
  getOrder(
    request: GetOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetOrderResponse) => void,
  ): ClientUnaryCall;
  cancelOrder(
    request: CancelOrderRequest,
    callback: (error: ServiceError | null, response: CancelOrderResponse) => void,
  ): ClientUnaryCall;
  cancelOrder(
    request: CancelOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelOrderResponse) => void,
  ): ClientUnaryCall;
  cancelOrder(
    request: CancelOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelOrderResponse) => void,
  ): ClientUnaryCall;
  updateOrderStatus(
    request: UpdateOrderStatusRequest,
    callback: (error: ServiceError | null, response: UpdateOrderStatusResponse) => void,
  ): ClientUnaryCall;
  updateOrderStatus(
    request: UpdateOrderStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateOrderStatusResponse) => void,
  ): ClientUnaryCall;
  updateOrderStatus(
    request: UpdateOrderStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateOrderStatusResponse) => void,
  ): ClientUnaryCall;
}

export const OrderServiceClient = makeGenericClientConstructor(
  OrderServiceService,
  "nexuraTelemetry.OrderService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrderServiceClient;
  service: typeof OrderServiceService;
  serviceName: string;
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  initiatePayment: {
    path: "/nexuraTelemetry.PaymentService/InitiatePayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InitiatePaymentRequest) => Buffer.from(InitiatePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InitiatePaymentRequest.decode(value),
    responseSerialize: (value: InitiatePaymentResponse) => Buffer.from(InitiatePaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InitiatePaymentResponse.decode(value),
  },
  verifyPayment: {
    path: "/nexuraTelemetry.PaymentService/VerifyPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyPaymentRequest) => Buffer.from(VerifyPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyPaymentRequest.decode(value),
    responseSerialize: (value: VerifyPaymentResponse) => Buffer.from(VerifyPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyPaymentResponse.decode(value),
  },
  cancelPayment: {
    path: "/nexuraTelemetry.PaymentService/CancelPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelPaymentRequest) => Buffer.from(CancelPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelPaymentRequest.decode(value),
    responseSerialize: (value: CancelPaymentResponse) => Buffer.from(CancelPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CancelPaymentResponse.decode(value),
  },
  refundPayment: {
    path: "/nexuraTelemetry.PaymentService/RefundPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefundPaymentRequest) => Buffer.from(RefundPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefundPaymentRequest.decode(value),
    responseSerialize: (value: RefundPaymentResponse) => Buffer.from(RefundPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RefundPaymentResponse.decode(value),
  },
  getPaymentStatus: {
    path: "/nexuraTelemetry.PaymentService/GetPaymentStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentStatusRequest) => Buffer.from(GetPaymentStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaymentStatusRequest.decode(value),
    responseSerialize: (value: GetPaymentStatusResponse) =>
      Buffer.from(GetPaymentStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPaymentStatusResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  initiatePayment: handleUnaryCall<InitiatePaymentRequest, InitiatePaymentResponse>;
  verifyPayment: handleUnaryCall<VerifyPaymentRequest, VerifyPaymentResponse>;
  cancelPayment: handleUnaryCall<CancelPaymentRequest, CancelPaymentResponse>;
  refundPayment: handleUnaryCall<RefundPaymentRequest, RefundPaymentResponse>;
  getPaymentStatus: handleUnaryCall<GetPaymentStatusRequest, GetPaymentStatusResponse>;
}

export interface PaymentServiceClient extends Client {
  initiatePayment(
    request: InitiatePaymentRequest,
    callback: (error: ServiceError | null, response: InitiatePaymentResponse) => void,
  ): ClientUnaryCall;
  initiatePayment(
    request: InitiatePaymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InitiatePaymentResponse) => void,
  ): ClientUnaryCall;
  initiatePayment(
    request: InitiatePaymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InitiatePaymentResponse) => void,
  ): ClientUnaryCall;
  verifyPayment(
    request: VerifyPaymentRequest,
    callback: (error: ServiceError | null, response: VerifyPaymentResponse) => void,
  ): ClientUnaryCall;
  verifyPayment(
    request: VerifyPaymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyPaymentResponse) => void,
  ): ClientUnaryCall;
  verifyPayment(
    request: VerifyPaymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyPaymentResponse) => void,
  ): ClientUnaryCall;
  cancelPayment(
    request: CancelPaymentRequest,
    callback: (error: ServiceError | null, response: CancelPaymentResponse) => void,
  ): ClientUnaryCall;
  cancelPayment(
    request: CancelPaymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelPaymentResponse) => void,
  ): ClientUnaryCall;
  cancelPayment(
    request: CancelPaymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelPaymentResponse) => void,
  ): ClientUnaryCall;
  refundPayment(
    request: RefundPaymentRequest,
    callback: (error: ServiceError | null, response: RefundPaymentResponse) => void,
  ): ClientUnaryCall;
  refundPayment(
    request: RefundPaymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefundPaymentResponse) => void,
  ): ClientUnaryCall;
  refundPayment(
    request: RefundPaymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefundPaymentResponse) => void,
  ): ClientUnaryCall;
  getPaymentStatus(
    request: GetPaymentStatusRequest,
    callback: (error: ServiceError | null, response: GetPaymentStatusResponse) => void,
  ): ClientUnaryCall;
  getPaymentStatus(
    request: GetPaymentStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPaymentStatusResponse) => void,
  ): ClientUnaryCall;
  getPaymentStatus(
    request: GetPaymentStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPaymentStatusResponse) => void,
  ): ClientUnaryCall;
}

export const PaymentServiceClient = makeGenericClientConstructor(
  PaymentServiceService,
  "nexuraTelemetry.PaymentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PaymentServiceClient;
  service: typeof PaymentServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
