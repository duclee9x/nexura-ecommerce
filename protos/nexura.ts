// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v4.24.4
// source: nexura.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "nexuraTelemetry";

export interface GetAddressesRequest {
  userId: string;
}

export interface GetAddressesResponse {
  success: boolean;
  message: string;
  addresses: ExtendedAddress[];
}

export interface GetCountriesResponse {
  success: boolean;
  message: string;
  countries: Country[];
}

export interface GetProvincesByCountryRequest {
  countryId: string;
}

export interface GetProvincesResponse {
  success: boolean;
  message: string;
  provinces: Province[];
}

export interface GetDistrictsByProvinceRequest {
  provinceId: string;
}

export interface GetDistrictsResponse {
  success: boolean;
  message: string;
  districts: District[];
}

export interface GetWardsByDistrictRequest {
  districtId: string;
}

export interface GetWardsResponse {
  success: boolean;
  message: string;
  wards: Ward[];
}

export interface AddAddressRequest {
  userId: string;
  address: Address | undefined;
}

export interface UpdateAddressRequest {
  userId: string;
  address: ExtendedAddress | undefined;
}

export interface DeleteAddressRequest {
  userId: string;
  addressId: string;
}

export interface AddressResponse {
  success: boolean;
  message: string;
  address: Address | undefined;
}

export interface DeleteAddressResponse {
  success: boolean;
  message: string;
}

export interface Country {
  id: string;
  name: string;
  codeName: string;
}

export interface Province {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  administrativeUnitId: string;
  administrativeRegionId: string;
  countryId: string;
}

export interface District {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  provinceId: string;
  administrativeUnitId: string;
}

export interface Ward {
  id: string;
  name: string;
  nameEn: string;
  fullName: string;
  fullNameEn: string;
  districtId: string;
  administrativeUnitId: string;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success: boolean;
  message: string;
}

export interface ValidateOTPRequest {
  email: string;
  otp: string;
}

export interface ValidateOTPResponse {
  success: boolean;
  message: string;
}

export interface ResetPasswordRequest {
  email: string;
  newPassword: string;
}

export interface ResetPasswordResponse {
  success: boolean;
  message: string;
}

export interface GetUserRequest {
  id: string;
}

export interface UpdateUserResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface GetUserResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface DeleteUserRequest {
  id: string;
}

export interface UpdateUserRequest {
  id: string;
  user: User | undefined;
  currentPassword: string;
  newPassword: string;
}

export interface RegisterUserRequest {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

export interface RegisterUserResponse {
  success: boolean;
  message: string;
}

export interface LoginUserRequest {
  email: string;
  password: string;
}

export interface LoginUserResponse {
  success: boolean;
  message: string;
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
}

export interface User {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  createdAt: string;
  dateOfBirth: string;
  gender: string;
  updatedAt: string;
  isActive: boolean;
  isVerified: boolean;
  role: string;
  lastLogin: string;
  permissions: string;
  profilePictureUrl: string;
}

export interface ExtendedAddress {
  id: string;
  name: string;
  street: string;
  city: string;
  state: string;
  countryId: string;
  countryName: string;
  zip: string;
  vnProvinceId: string;
  vnProvinceName: string;
  vnDistrictId: string;
  vnDistrictName: string;
  vnWardId: string;
  vnWardName: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface Address {
  id: string;
  name: string;
  street: string;
  city: string;
  state: string;
  countryId: string;
  zip: string;
  vnProvinceId: string;
  vnDistrictId: string;
  vnWardId: string;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface DeleteUserResponse {
  success: boolean;
  message: string;
}

export interface VerifyAccountRequest {
  token: string;
}

export interface VerifyAccountResponse {
  success: boolean;
  message: string;
}

export interface CartItem {
  productId: string;
  quantity: number;
}

export interface AddItemRequest {
  userId: string;
  item: CartItem | undefined;
}

export interface EmptyCartRequest {
  userId: string;
}

export interface GetCartRequest {
  userId: string;
}

export interface Cart {
  userId: string;
  items: CartItem[];
}

export interface Empty {
}

export interface ListRecommendationsRequest {
  userId: string;
  productIds: string[];
}

export interface ListRecommendationsResponse {
  productIds: string[];
}

export interface GetProductAttributesRequest {
  productId: string;
}

export interface GetProductAttributesResponse {
  attributes: ProductAttribute[];
}

export interface UpdateProductAttributesRequest {
  attribute: ProductAttribute | undefined;
}

export interface UpdateProductAttributesResponse {
  attribute: ProductAttribute | undefined;
}

export interface DeleteProductAttributesRequest {
  attributeId: string;
}

export interface DeleteProductAttributesResponse {
  attributeId: string;
}

export interface CreateProductAttributeRequest {
  attribute: ProductAttribute | undefined;
}

export interface CreateProductAttributeResponse {
  attribute: ProductAttribute | undefined;
}

export interface ProductAttribute {
  id: string;
  name: string;
  required: boolean;
  visible: boolean;
  values: string[];
  productId: string;
  variantable: boolean;
  filterable: boolean;
  searchable: boolean;
  displayOrder: number;
}

export interface Product {
  id: string;
  name: string;
  slug: string;
  description: string;
  costPrice: number;
  basePrice: number;
  sku: string;
  barcode: string;
  brandId: string;
  featured: boolean;
  status: string;
  createdAt: string;
  updatedAt: string;
  seo: Seo | undefined;
  taxable: boolean;
  shippable: boolean;
  categories: string[];
  productTags: ProductTag[];
  images: Image[];
  attributes: ProductAttribute[];
  variants: ProductVariant[];
  dimensions: Dimensions | undefined;
  sizeCharts: SizeChart[];
}

export interface SizeChart {
  id: string;
  name: string;
  category: string;
  description?: string | undefined;
  productId: string;
  columns: SizeChartColumn[];
  rows: SizeChartRow[];
  images: SizeChartImage[];
  createdAt: string;
  updatedAt: string;
}

export interface SizeChartColumn {
  id: string;
  name: string;
  type: string;
  unit?: string | undefined;
  sizeChartId: string;
  createdAt: string;
}

export interface SizeChartRow {
  id: string;
  name: string;
  cells: SizeChartCell[];
}

export interface SizeChartCell {
  id: string;
  value: string;
}

export interface SizeChartImage {
  id: string;
  url: string;
  name: string;
  sizeChartId: string;
  createdAt: string;
}

export interface ProductTag {
  id: string;
  tag: Tag | undefined;
  productId: string;
}

export interface Tag {
  id: string;
  name: string;
  createdAt: string;
  updatedAt: string;
}

export interface Dimensions {
  length: number;
  width: number;
  height: number;
  weight: number;
}

export interface Seo {
  title: string;
  description: string;
  keywords: string;
}

export interface ProductVariant {
  id: string;
  sku: string;
  price: number;
  quantity: number;
  lowStockThreshold: number;
  warehouseId: string;
  images: Image[];
  attributes: VariantAttribute[];
}

export interface VariantAttribute {
  id: string;
  name: string;
  value: string;
  extraValue: string;
}

export interface Image {
  id: string;
  url: string;
  isMain: boolean;
}

export interface CreateProductRequest {
  product: Product | undefined;
}

export interface CreateProductResponse {
  product: Product | undefined;
}

export interface UpdateProductRequest {
  product: Product | undefined;
}

export interface UpdateProductResponse {
  product: Product | undefined;
}

export interface DeleteProductRequest {
  id: string;
}

export interface DeleteProductResponse {
  id: string;
}

export interface CreateVariantRequest {
  variant: ProductVariant | undefined;
}

export interface CreateVariantResponse {
  variant: ProductVariant | undefined;
}

export interface CreateBrandRequest {
  brand: Brand | undefined;
}

export interface CreateBrandResponse {
  brand: Brand | undefined;
}

export interface GetAllCategoryResponse {
  categories: Category[];
}

export interface CreateCategoryRequest {
  category: Category | undefined;
}

export interface CreateCategoryResponse {
  category: Category | undefined;
}

export interface UpdateCategoryRequest {
  category: Category | undefined;
}

export interface UpdateCategoryResponse {
  category: Category | undefined;
}

export interface DeleteCategoryRequest {
  id: string;
}

export interface DeleteCategoryResponse {
  id: string;
}

export interface CreateImageRequest {
  image: Image | undefined;
}

export interface CreateImageResponse {
  image: Image | undefined;
}

export interface ListProductsResponse {
  products: Product[];
}

export interface ListProductsRequest {
}

export interface GetProductRequest {
  id: string;
}

export interface GetProductResponse {
  product: Product | undefined;
}

export interface Variant {
  id: string;
  name: string;
  description: string;
  picture: string;
  priceUsd: Money | undefined;
}

export interface Brand {
  id: string;
  name: string;
  logo: string;
}

export interface Category {
  id: string;
  name: string;
  parentId: string;
}

export interface GetWarehousesResponse {
  warehouses: Warehouse[];
}

export interface Warehouse {
  id: string;
  name: string;
  code: string;
  location: string[];
  address: string;
  manager: string;
  contact: string;
  status: string;
  createdAt: string;
  updatedAt: string;
}

export interface SearchProductsRequest {
  query: string;
}

export interface SearchProductsResponse {
  results: Product[];
}

export interface GetQuoteRequest {
  address: Address | undefined;
  items: CartItem[];
}

export interface GetQuoteResponse {
  costUsd: Money | undefined;
}

export interface ShipOrderRequest {
  address: Address | undefined;
  items: CartItem[];
}

export interface ShipOrderResponse {
  trackingId: string;
}

/** Represents an amount of money with its currency type. */
export interface Money {
  /** The 3-letter currency code defined in ISO 4217. */
  currencyCode: string;
  /**
   * The whole units of the amount.
   * For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
   */
  units: number;
  /**
   * Number of nano (10^-9) units of the amount.
   * The value must be between -999,999,999 and +999,999,999 inclusive.
   * If `units` is positive, `nanos` must be positive or zero.
   * If `units` is zero, `nanos` can be positive, zero, or negative.
   * If `units` is negative, `nanos` must be negative or zero.
   * For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
   */
  nanos: number;
}

export interface GetSupportedCurrenciesResponse {
  /** The 3-letter currency code defined in ISO 4217. */
  currencyCodes: string[];
}

export interface CurrencyConversionRequest {
  from:
    | Money
    | undefined;
  /** The 3-letter currency code defined in ISO 4217. */
  toCode: string;
}

export interface CreditCardInfo {
  creditCardNumber: string;
  creditCardCvv: number;
  creditCardExpirationYear: number;
  creditCardExpirationMonth: number;
}

export interface ChargeRequest {
  amount: Money | undefined;
  creditCard: CreditCardInfo | undefined;
}

export interface ChargeResponse {
  transactionId: string;
}

export interface OrderItem {
  item: CartItem | undefined;
  cost: Money | undefined;
}

export interface OrderResult {
  orderId: string;
  shippingTrackingId: string;
  shippingCost: Money | undefined;
  shippingAddress: Address | undefined;
  items: OrderItem[];
}

export interface SendOrderConfirmationRequest {
  email: string;
  order: OrderResult | undefined;
}

export interface SendOTPResetPasswordRequest {
  email: string;
  verificationCode: string;
}

export interface SendOTPResetPasswordResponse {
  success: boolean;
  message: string;
}

export interface SendWelcomeEmailRequest {
  email: string;
  name: string;
  token: string;
}

export interface SendWelcomeEmailResponse {
  success: boolean;
  message: string;
}

export interface PlaceOrderRequest {
  userId: string;
  userCurrency: string;
  address: Address | undefined;
  email: string;
  creditCard: CreditCardInfo | undefined;
}

export interface PlaceOrderResponse {
  order: OrderResult | undefined;
}

export interface AdRequest {
  /** List of important key words from the current page describing the context. */
  contextKeys: string[];
}

export interface AdResponse {
  ads: Ad[];
}

export interface Ad {
  /** url to redirect to when an ad is clicked. */
  redirectUrl: string;
  /** short advertisement text to display. */
  text: string;
}

export interface Flag {
  name: string;
  description: string;
  enabled: boolean;
}

export interface GetFlagRequest {
  name: string;
}

export interface GetFlagResponse {
  flag: Flag | undefined;
}

export interface CreateFlagRequest {
  name: string;
  description: string;
  enabled: boolean;
}

export interface CreateFlagResponse {
  flag: Flag | undefined;
}

export interface UpdateFlagRequest {
  name: string;
  enabled: boolean;
}

export interface UpdateFlagResponse {
}

export interface ListFlagsRequest {
}

export interface ListFlagsResponse {
  flag: Flag[];
}

export interface DeleteFlagRequest {
  name: string;
}

export interface DeleteFlagResponse {
}

export interface NewBrandRequest {
  brand: Brand | undefined;
}

export interface NewBrandResponse {
  success: boolean;
  message: string;
  brand: Brand | undefined;
}

export interface RemoveBrandRequest {
  id: string;
}

export interface RemoveBrandResponse {
  success: boolean;
  message: string;
}

export interface GetAllBrandResponse {
  success: boolean;
  message: string;
  brands: Brand[];
}

function createBaseGetAddressesRequest(): GetAddressesRequest {
  return { userId: "" };
}

export const GetAddressesRequest: MessageFns<GetAddressesRequest> = {
  encode(message: GetAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetAddressesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressesRequest>, I>>(base?: I): GetAddressesRequest {
    return GetAddressesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressesRequest>, I>>(object: I): GetAddressesRequest {
    const message = createBaseGetAddressesRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetAddressesResponse(): GetAddressesResponse {
  return { success: false, message: "", addresses: [] };
}

export const GetAddressesResponse: MessageFns<GetAddressesResponse> = {
  encode(message: GetAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.addresses) {
      ExtendedAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addresses.push(ExtendedAddress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => ExtendedAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAddressesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => ExtendedAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAddressesResponse>, I>>(base?: I): GetAddressesResponse {
    return GetAddressesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAddressesResponse>, I>>(object: I): GetAddressesResponse {
    const message = createBaseGetAddressesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.addresses = object.addresses?.map((e) => ExtendedAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCountriesResponse(): GetCountriesResponse {
  return { success: false, message: "", countries: [] };
}

export const GetCountriesResponse: MessageFns<GetCountriesResponse> = {
  encode(message: GetCountriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.countries) {
      Country.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.countries.push(Country.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountriesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      countries: globalThis.Array.isArray(object?.countries)
        ? object.countries.map((e: any) => Country.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCountriesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.countries?.length) {
      obj.countries = message.countries.map((e) => Country.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCountriesResponse>, I>>(base?: I): GetCountriesResponse {
    return GetCountriesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCountriesResponse>, I>>(object: I): GetCountriesResponse {
    const message = createBaseGetCountriesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.countries = object.countries?.map((e) => Country.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProvincesByCountryRequest(): GetProvincesByCountryRequest {
  return { countryId: "" };
}

export const GetProvincesByCountryRequest: MessageFns<GetProvincesByCountryRequest> = {
  encode(message: GetProvincesByCountryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryId !== "") {
      writer.uint32(10).string(message.countryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvincesByCountryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvincesByCountryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvincesByCountryRequest {
    return { countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "" };
  },

  toJSON(message: GetProvincesByCountryRequest): unknown {
    const obj: any = {};
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProvincesByCountryRequest>, I>>(base?: I): GetProvincesByCountryRequest {
    return GetProvincesByCountryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProvincesByCountryRequest>, I>>(object: I): GetProvincesByCountryRequest {
    const message = createBaseGetProvincesByCountryRequest();
    message.countryId = object.countryId ?? "";
    return message;
  },
};

function createBaseGetProvincesResponse(): GetProvincesResponse {
  return { success: false, message: "", provinces: [] };
}

export const GetProvincesResponse: MessageFns<GetProvincesResponse> = {
  encode(message: GetProvincesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.provinces) {
      Province.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvincesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvincesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provinces.push(Province.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvincesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      provinces: globalThis.Array.isArray(object?.provinces)
        ? object.provinces.map((e: any) => Province.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetProvincesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.provinces?.length) {
      obj.provinces = message.provinces.map((e) => Province.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProvincesResponse>, I>>(base?: I): GetProvincesResponse {
    return GetProvincesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProvincesResponse>, I>>(object: I): GetProvincesResponse {
    const message = createBaseGetProvincesResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.provinces = object.provinces?.map((e) => Province.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDistrictsByProvinceRequest(): GetDistrictsByProvinceRequest {
  return { provinceId: "" };
}

export const GetDistrictsByProvinceRequest: MessageFns<GetDistrictsByProvinceRequest> = {
  encode(message: GetDistrictsByProvinceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provinceId !== "") {
      writer.uint32(10).string(message.provinceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDistrictsByProvinceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDistrictsByProvinceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provinceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDistrictsByProvinceRequest {
    return { provinceId: isSet(object.provinceId) ? globalThis.String(object.provinceId) : "" };
  },

  toJSON(message: GetDistrictsByProvinceRequest): unknown {
    const obj: any = {};
    if (message.provinceId !== "") {
      obj.provinceId = message.provinceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDistrictsByProvinceRequest>, I>>(base?: I): GetDistrictsByProvinceRequest {
    return GetDistrictsByProvinceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDistrictsByProvinceRequest>, I>>(
    object: I,
  ): GetDistrictsByProvinceRequest {
    const message = createBaseGetDistrictsByProvinceRequest();
    message.provinceId = object.provinceId ?? "";
    return message;
  },
};

function createBaseGetDistrictsResponse(): GetDistrictsResponse {
  return { success: false, message: "", districts: [] };
}

export const GetDistrictsResponse: MessageFns<GetDistrictsResponse> = {
  encode(message: GetDistrictsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.districts) {
      District.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDistrictsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDistrictsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.districts.push(District.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDistrictsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      districts: globalThis.Array.isArray(object?.districts)
        ? object.districts.map((e: any) => District.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDistrictsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.districts?.length) {
      obj.districts = message.districts.map((e) => District.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDistrictsResponse>, I>>(base?: I): GetDistrictsResponse {
    return GetDistrictsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDistrictsResponse>, I>>(object: I): GetDistrictsResponse {
    const message = createBaseGetDistrictsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.districts = object.districts?.map((e) => District.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWardsByDistrictRequest(): GetWardsByDistrictRequest {
  return { districtId: "" };
}

export const GetWardsByDistrictRequest: MessageFns<GetWardsByDistrictRequest> = {
  encode(message: GetWardsByDistrictRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.districtId !== "") {
      writer.uint32(10).string(message.districtId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWardsByDistrictRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWardsByDistrictRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.districtId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWardsByDistrictRequest {
    return { districtId: isSet(object.districtId) ? globalThis.String(object.districtId) : "" };
  },

  toJSON(message: GetWardsByDistrictRequest): unknown {
    const obj: any = {};
    if (message.districtId !== "") {
      obj.districtId = message.districtId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWardsByDistrictRequest>, I>>(base?: I): GetWardsByDistrictRequest {
    return GetWardsByDistrictRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWardsByDistrictRequest>, I>>(object: I): GetWardsByDistrictRequest {
    const message = createBaseGetWardsByDistrictRequest();
    message.districtId = object.districtId ?? "";
    return message;
  },
};

function createBaseGetWardsResponse(): GetWardsResponse {
  return { success: false, message: "", wards: [] };
}

export const GetWardsResponse: MessageFns<GetWardsResponse> = {
  encode(message: GetWardsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.wards) {
      Ward.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWardsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWardsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wards.push(Ward.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWardsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      wards: globalThis.Array.isArray(object?.wards) ? object.wards.map((e: any) => Ward.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWardsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.wards?.length) {
      obj.wards = message.wards.map((e) => Ward.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWardsResponse>, I>>(base?: I): GetWardsResponse {
    return GetWardsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWardsResponse>, I>>(object: I): GetWardsResponse {
    const message = createBaseGetWardsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.wards = object.wards?.map((e) => Ward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddAddressRequest(): AddAddressRequest {
  return { userId: "", address: undefined };
}

export const AddAddressRequest: MessageFns<AddAddressRequest> = {
  encode(message: AddAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: AddAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddAddressRequest>, I>>(base?: I): AddAddressRequest {
    return AddAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddAddressRequest>, I>>(object: I): AddAddressRequest {
    const message = createBaseAddAddressRequest();
    message.userId = object.userId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseUpdateAddressRequest(): UpdateAddressRequest {
  return { userId: "", address: undefined };
}

export const UpdateAddressRequest: MessageFns<UpdateAddressRequest> = {
  encode(message: UpdateAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.address !== undefined) {
      ExtendedAddress.encode(message.address, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = ExtendedAddress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      address: isSet(object.address) ? ExtendedAddress.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: UpdateAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.address !== undefined) {
      obj.address = ExtendedAddress.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAddressRequest>, I>>(base?: I): UpdateAddressRequest {
    return UpdateAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAddressRequest>, I>>(object: I): UpdateAddressRequest {
    const message = createBaseUpdateAddressRequest();
    message.userId = object.userId ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? ExtendedAddress.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseDeleteAddressRequest(): DeleteAddressRequest {
  return { userId: "", addressId: "" };
}

export const DeleteAddressRequest: MessageFns<DeleteAddressRequest> = {
  encode(message: DeleteAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.addressId !== "") {
      writer.uint32(18).string(message.addressId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAddressRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      addressId: isSet(object.addressId) ? globalThis.String(object.addressId) : "",
    };
  },

  toJSON(message: DeleteAddressRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.addressId !== "") {
      obj.addressId = message.addressId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAddressRequest>, I>>(base?: I): DeleteAddressRequest {
    return DeleteAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAddressRequest>, I>>(object: I): DeleteAddressRequest {
    const message = createBaseDeleteAddressRequest();
    message.userId = object.userId ?? "";
    message.addressId = object.addressId ?? "";
    return message;
  },
};

function createBaseAddressResponse(): AddressResponse {
  return { success: false, message: "", address: undefined };
}

export const AddressResponse: MessageFns<AddressResponse> = {
  encode(message: AddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: AddressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressResponse>, I>>(base?: I): AddressResponse {
    return AddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressResponse>, I>>(object: I): AddressResponse {
    const message = createBaseAddressResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseDeleteAddressResponse(): DeleteAddressResponse {
  return { success: false, message: "" };
}

export const DeleteAddressResponse: MessageFns<DeleteAddressResponse> = {
  encode(message: DeleteAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAddressResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteAddressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAddressResponse>, I>>(base?: I): DeleteAddressResponse {
    return DeleteAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAddressResponse>, I>>(object: I): DeleteAddressResponse {
    const message = createBaseDeleteAddressResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCountry(): Country {
  return { id: "", name: "", codeName: "" };
}

export const Country: MessageFns<Country> = {
  encode(message: Country, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.codeName !== "") {
      writer.uint32(26).string(message.codeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Country {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.codeName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Country {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      codeName: isSet(object.codeName) ? globalThis.String(object.codeName) : "",
    };
  },

  toJSON(message: Country): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.codeName !== "") {
      obj.codeName = message.codeName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Country>, I>>(base?: I): Country {
    return Country.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Country>, I>>(object: I): Country {
    const message = createBaseCountry();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.codeName = object.codeName ?? "";
    return message;
  },
};

function createBaseProvince(): Province {
  return {
    id: "",
    name: "",
    nameEn: "",
    fullName: "",
    fullNameEn: "",
    administrativeUnitId: "",
    administrativeRegionId: "",
    countryId: "",
  };
}

export const Province: MessageFns<Province> = {
  encode(message: Province, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(50).string(message.administrativeUnitId);
    }
    if (message.administrativeRegionId !== "") {
      writer.uint32(58).string(message.administrativeRegionId);
    }
    if (message.countryId !== "") {
      writer.uint32(66).string(message.countryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Province {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvince();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeRegionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Province {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
      administrativeRegionId: isSet(object.administrativeRegionId)
        ? globalThis.String(object.administrativeRegionId)
        : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
    };
  },

  toJSON(message: Province): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    if (message.administrativeRegionId !== "") {
      obj.administrativeRegionId = message.administrativeRegionId;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Province>, I>>(base?: I): Province {
    return Province.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Province>, I>>(object: I): Province {
    const message = createBaseProvince();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    message.administrativeRegionId = object.administrativeRegionId ?? "";
    message.countryId = object.countryId ?? "";
    return message;
  },
};

function createBaseDistrict(): District {
  return { id: "", name: "", nameEn: "", fullName: "", fullNameEn: "", provinceId: "", administrativeUnitId: "" };
}

export const District: MessageFns<District> = {
  encode(message: District, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.provinceId !== "") {
      writer.uint32(50).string(message.provinceId);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(58).string(message.administrativeUnitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): District {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistrict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.provinceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): District {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      provinceId: isSet(object.provinceId) ? globalThis.String(object.provinceId) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
    };
  },

  toJSON(message: District): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.provinceId !== "") {
      obj.provinceId = message.provinceId;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<District>, I>>(base?: I): District {
    return District.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<District>, I>>(object: I): District {
    const message = createBaseDistrict();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.provinceId = object.provinceId ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    return message;
  },
};

function createBaseWard(): Ward {
  return { id: "", name: "", nameEn: "", fullName: "", fullNameEn: "", districtId: "", administrativeUnitId: "" };
}

export const Ward: MessageFns<Ward> = {
  encode(message: Ward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameEn !== "") {
      writer.uint32(26).string(message.nameEn);
    }
    if (message.fullName !== "") {
      writer.uint32(34).string(message.fullName);
    }
    if (message.fullNameEn !== "") {
      writer.uint32(42).string(message.fullNameEn);
    }
    if (message.districtId !== "") {
      writer.uint32(50).string(message.districtId);
    }
    if (message.administrativeUnitId !== "") {
      writer.uint32(58).string(message.administrativeUnitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nameEn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fullNameEn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.districtId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.administrativeUnitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ward {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameEn: isSet(object.nameEn) ? globalThis.String(object.nameEn) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      fullNameEn: isSet(object.fullNameEn) ? globalThis.String(object.fullNameEn) : "",
      districtId: isSet(object.districtId) ? globalThis.String(object.districtId) : "",
      administrativeUnitId: isSet(object.administrativeUnitId) ? globalThis.String(object.administrativeUnitId) : "",
    };
  },

  toJSON(message: Ward): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameEn !== "") {
      obj.nameEn = message.nameEn;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.fullNameEn !== "") {
      obj.fullNameEn = message.fullNameEn;
    }
    if (message.districtId !== "") {
      obj.districtId = message.districtId;
    }
    if (message.administrativeUnitId !== "") {
      obj.administrativeUnitId = message.administrativeUnitId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ward>, I>>(base?: I): Ward {
    return Ward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ward>, I>>(object: I): Ward {
    const message = createBaseWard();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nameEn = object.nameEn ?? "";
    message.fullName = object.fullName ?? "";
    message.fullNameEn = object.fullNameEn ?? "";
    message.districtId = object.districtId ?? "";
    message.administrativeUnitId = object.administrativeUnitId ?? "";
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: false, message: "" };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseValidateOTPRequest(): ValidateOTPRequest {
  return { email: "", otp: "" };
}

export const ValidateOTPRequest: MessageFns<ValidateOTPRequest> = {
  encode(message: ValidateOTPRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.otp !== "") {
      writer.uint32(18).string(message.otp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateOTPRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateOTPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateOTPRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      otp: isSet(object.otp) ? globalThis.String(object.otp) : "",
    };
  },

  toJSON(message: ValidateOTPRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.otp !== "") {
      obj.otp = message.otp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateOTPRequest>, I>>(base?: I): ValidateOTPRequest {
    return ValidateOTPRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateOTPRequest>, I>>(object: I): ValidateOTPRequest {
    const message = createBaseValidateOTPRequest();
    message.email = object.email ?? "";
    message.otp = object.otp ?? "";
    return message;
  },
};

function createBaseValidateOTPResponse(): ValidateOTPResponse {
  return { success: false, message: "" };
}

export const ValidateOTPResponse: MessageFns<ValidateOTPResponse> = {
  encode(message: ValidateOTPResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateOTPResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateOTPResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateOTPResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ValidateOTPResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateOTPResponse>, I>>(base?: I): ValidateOTPResponse {
    return ValidateOTPResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateOTPResponse>, I>>(object: I): ValidateOTPResponse {
    const message = createBaseValidateOTPResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { email: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.email = object.email ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { success: false, message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(base?: I): ResetPasswordResponse {
    return ResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordResponse>, I>>(object: I): ResetPasswordResponse {
    const message = createBaseResetPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { id: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return { success: false, message: "", user: undefined };
}

export const UpdateUserResponse: MessageFns<UpdateUserResponse> = {
  encode(message: UpdateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: UpdateUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(object: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { success: false, message: "", user: undefined };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { id: "" };
}

export const DeleteUserRequest: MessageFns<DeleteUserRequest> = {
  encode(message: DeleteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { id: "", user: undefined, currentPassword: "", newPassword: "" };
}

export const UpdateUserRequest: MessageFns<UpdateUserRequest> = {
  encode(message: UpdateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.currentPassword !== "") {
      writer.uint32(26).string(message.currentPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(34).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentPassword = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      currentPassword: isSet(object.currentPassword) ? globalThis.String(object.currentPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.currentPassword !== "") {
      obj.currentPassword = message.currentPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.id = object.id ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.currentPassword = object.currentPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { firstName: "", lastName: "", email: "", password: "" };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(18).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(object: I): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { success: false, message: "" };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(object: I): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseLoginUserRequest(): LoginUserRequest {
  return { email: "", password: "" };
}

export const LoginUserRequest: MessageFns<LoginUserRequest> = {
  encode(message: LoginUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserRequest>, I>>(base?: I): LoginUserRequest {
    return LoginUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserRequest>, I>>(object: I): LoginUserRequest {
    const message = createBaseLoginUserRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginUserResponse(): LoginUserResponse {
  return { success: false, message: "", accessToken: "", refreshToken: "", user: undefined };
}

export const LoginUserResponse: MessageFns<LoginUserResponse> = {
  encode(message: LoginUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.accessToken !== "") {
      writer.uint32(26).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(34).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: LoginUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserResponse>, I>>(base?: I): LoginUserResponse {
    return LoginUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserResponse>, I>>(object: I): LoginUserResponse {
    const message = createBaseLoginUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    firstName: "",
    lastName: "",
    email: "",
    phone: "",
    createdAt: "",
    dateOfBirth: "",
    gender: "",
    updatedAt: "",
    isActive: false,
    isVerified: false,
    role: "",
    lastLogin: "",
    permissions: "",
    profilePictureUrl: "",
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(42).string(message.phone);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.dateOfBirth !== "") {
      writer.uint32(58).string(message.dateOfBirth);
    }
    if (message.gender !== "") {
      writer.uint32(66).string(message.gender);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.isVerified !== false) {
      writer.uint32(88).bool(message.isVerified);
    }
    if (message.role !== "") {
      writer.uint32(98).string(message.role);
    }
    if (message.lastLogin !== "") {
      writer.uint32(106).string(message.lastLogin);
    }
    if (message.permissions !== "") {
      writer.uint32(114).string(message.permissions);
    }
    if (message.profilePictureUrl !== "") {
      writer.uint32(122).string(message.profilePictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateOfBirth = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.lastLogin = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.permissions = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profilePictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      dateOfBirth: isSet(object.dateOfBirth) ? globalThis.String(object.dateOfBirth) : "",
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      lastLogin: isSet(object.lastLogin) ? globalThis.String(object.lastLogin) : "",
      permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
      profilePictureUrl: isSet(object.profilePictureUrl) ? globalThis.String(object.profilePictureUrl) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.dateOfBirth !== "") {
      obj.dateOfBirth = message.dateOfBirth;
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.lastLogin !== "") {
      obj.lastLogin = message.lastLogin;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    if (message.profilePictureUrl !== "") {
      obj.profilePictureUrl = message.profilePictureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? "";
    message.createdAt = object.createdAt ?? "";
    message.dateOfBirth = object.dateOfBirth ?? "";
    message.gender = object.gender ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.isActive = object.isActive ?? false;
    message.isVerified = object.isVerified ?? false;
    message.role = object.role ?? "";
    message.lastLogin = object.lastLogin ?? "";
    message.permissions = object.permissions ?? "";
    message.profilePictureUrl = object.profilePictureUrl ?? "";
    return message;
  },
};

function createBaseExtendedAddress(): ExtendedAddress {
  return {
    id: "",
    name: "",
    street: "",
    city: "",
    state: "",
    countryId: "",
    countryName: "",
    zip: "",
    vnProvinceId: "",
    vnProvinceName: "",
    vnDistrictId: "",
    vnDistrictName: "",
    vnWardId: "",
    vnWardName: "",
    isDefault: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ExtendedAddress: MessageFns<ExtendedAddress> = {
  encode(message: ExtendedAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.countryId !== "") {
      writer.uint32(50).string(message.countryId);
    }
    if (message.countryName !== "") {
      writer.uint32(58).string(message.countryName);
    }
    if (message.zip !== "") {
      writer.uint32(66).string(message.zip);
    }
    if (message.vnProvinceId !== "") {
      writer.uint32(74).string(message.vnProvinceId);
    }
    if (message.vnProvinceName !== "") {
      writer.uint32(82).string(message.vnProvinceName);
    }
    if (message.vnDistrictId !== "") {
      writer.uint32(90).string(message.vnDistrictId);
    }
    if (message.vnDistrictName !== "") {
      writer.uint32(98).string(message.vnDistrictName);
    }
    if (message.vnWardId !== "") {
      writer.uint32(106).string(message.vnWardId);
    }
    if (message.vnWardName !== "") {
      writer.uint32(114).string(message.vnWardName);
    }
    if (message.isDefault !== false) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtendedAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.countryName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.zip = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.vnProvinceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vnProvinceName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.vnDistrictId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.vnDistrictName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.vnWardId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.vnWardName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedAddress {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
      countryName: isSet(object.countryName) ? globalThis.String(object.countryName) : "",
      zip: isSet(object.zip) ? globalThis.String(object.zip) : "",
      vnProvinceId: isSet(object.vnProvinceId) ? globalThis.String(object.vnProvinceId) : "",
      vnProvinceName: isSet(object.vnProvinceName) ? globalThis.String(object.vnProvinceName) : "",
      vnDistrictId: isSet(object.vnDistrictId) ? globalThis.String(object.vnDistrictId) : "",
      vnDistrictName: isSet(object.vnDistrictName) ? globalThis.String(object.vnDistrictName) : "",
      vnWardId: isSet(object.vnWardId) ? globalThis.String(object.vnWardId) : "",
      vnWardName: isSet(object.vnWardName) ? globalThis.String(object.vnWardName) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ExtendedAddress): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    if (message.countryName !== "") {
      obj.countryName = message.countryName;
    }
    if (message.zip !== "") {
      obj.zip = message.zip;
    }
    if (message.vnProvinceId !== "") {
      obj.vnProvinceId = message.vnProvinceId;
    }
    if (message.vnProvinceName !== "") {
      obj.vnProvinceName = message.vnProvinceName;
    }
    if (message.vnDistrictId !== "") {
      obj.vnDistrictId = message.vnDistrictId;
    }
    if (message.vnDistrictName !== "") {
      obj.vnDistrictName = message.vnDistrictName;
    }
    if (message.vnWardId !== "") {
      obj.vnWardId = message.vnWardId;
    }
    if (message.vnWardName !== "") {
      obj.vnWardName = message.vnWardName;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtendedAddress>, I>>(base?: I): ExtendedAddress {
    return ExtendedAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtendedAddress>, I>>(object: I): ExtendedAddress {
    const message = createBaseExtendedAddress();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.state = object.state ?? "";
    message.countryId = object.countryId ?? "";
    message.countryName = object.countryName ?? "";
    message.zip = object.zip ?? "";
    message.vnProvinceId = object.vnProvinceId ?? "";
    message.vnProvinceName = object.vnProvinceName ?? "";
    message.vnDistrictId = object.vnDistrictId ?? "";
    message.vnDistrictName = object.vnDistrictName ?? "";
    message.vnWardId = object.vnWardId ?? "";
    message.vnWardName = object.vnWardName ?? "";
    message.isDefault = object.isDefault ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseAddress(): Address {
  return {
    id: "",
    name: "",
    street: "",
    city: "",
    state: "",
    countryId: "",
    zip: "",
    vnProvinceId: "",
    vnDistrictId: "",
    vnWardId: "",
    isDefault: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.countryId !== "") {
      writer.uint32(50).string(message.countryId);
    }
    if (message.zip !== "") {
      writer.uint32(58).string(message.zip);
    }
    if (message.vnProvinceId !== "") {
      writer.uint32(66).string(message.vnProvinceId);
    }
    if (message.vnDistrictId !== "") {
      writer.uint32(74).string(message.vnDistrictId);
    }
    if (message.vnWardId !== "") {
      writer.uint32(82).string(message.vnWardId);
    }
    if (message.isDefault !== false) {
      writer.uint32(88).bool(message.isDefault);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.countryId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.zip = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.vnProvinceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.vnDistrictId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vnWardId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      countryId: isSet(object.countryId) ? globalThis.String(object.countryId) : "",
      zip: isSet(object.zip) ? globalThis.String(object.zip) : "",
      vnProvinceId: isSet(object.vnProvinceId) ? globalThis.String(object.vnProvinceId) : "",
      vnDistrictId: isSet(object.vnDistrictId) ? globalThis.String(object.vnDistrictId) : "",
      vnWardId: isSet(object.vnWardId) ? globalThis.String(object.vnWardId) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.countryId !== "") {
      obj.countryId = message.countryId;
    }
    if (message.zip !== "") {
      obj.zip = message.zip;
    }
    if (message.vnProvinceId !== "") {
      obj.vnProvinceId = message.vnProvinceId;
    }
    if (message.vnDistrictId !== "") {
      obj.vnDistrictId = message.vnDistrictId;
    }
    if (message.vnWardId !== "") {
      obj.vnWardId = message.vnWardId;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.state = object.state ?? "";
    message.countryId = object.countryId ?? "";
    message.zip = object.zip ?? "";
    message.vnProvinceId = object.vnProvinceId ?? "";
    message.vnDistrictId = object.vnDistrictId ?? "";
    message.vnWardId = object.vnWardId ?? "";
    message.isDefault = object.isDefault ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false, message: "" };
}

export const DeleteUserResponse: MessageFns<DeleteUserResponse> = {
  encode(message: DeleteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(object: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseVerifyAccountRequest(): VerifyAccountRequest {
  return { token: "" };
}

export const VerifyAccountRequest: MessageFns<VerifyAccountRequest> = {
  encode(message: VerifyAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccountRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: VerifyAccountRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(base?: I): VerifyAccountRequest {
    return VerifyAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(object: I): VerifyAccountRequest {
    const message = createBaseVerifyAccountRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseVerifyAccountResponse(): VerifyAccountResponse {
  return { success: false, message: "" };
}

export const VerifyAccountResponse: MessageFns<VerifyAccountResponse> = {
  encode(message: VerifyAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccountResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: VerifyAccountResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccountResponse>, I>>(base?: I): VerifyAccountResponse {
    return VerifyAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccountResponse>, I>>(object: I): VerifyAccountResponse {
    const message = createBaseVerifyAccountResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCartItem(): CartItem {
  return { productId: "", quantity: 0 };
}

export const CartItem: MessageFns<CartItem> = {
  encode(message: CartItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CartItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCartItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CartItem {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: CartItem): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CartItem>, I>>(base?: I): CartItem {
    return CartItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CartItem>, I>>(object: I): CartItem {
    const message = createBaseCartItem();
    message.productId = object.productId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseAddItemRequest(): AddItemRequest {
  return { userId: "", item: undefined };
}

export const AddItemRequest: MessageFns<AddItemRequest> = {
  encode(message: AddItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.item !== undefined) {
      CartItem.encode(message.item, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.item = CartItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      item: isSet(object.item) ? CartItem.fromJSON(object.item) : undefined,
    };
  },

  toJSON(message: AddItemRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.item !== undefined) {
      obj.item = CartItem.toJSON(message.item);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemRequest>, I>>(base?: I): AddItemRequest {
    return AddItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemRequest>, I>>(object: I): AddItemRequest {
    const message = createBaseAddItemRequest();
    message.userId = object.userId ?? "";
    message.item = (object.item !== undefined && object.item !== null) ? CartItem.fromPartial(object.item) : undefined;
    return message;
  },
};

function createBaseEmptyCartRequest(): EmptyCartRequest {
  return { userId: "" };
}

export const EmptyCartRequest: MessageFns<EmptyCartRequest> = {
  encode(message: EmptyCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmptyCartRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: EmptyCartRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyCartRequest>, I>>(base?: I): EmptyCartRequest {
    return EmptyCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyCartRequest>, I>>(object: I): EmptyCartRequest {
    const message = createBaseEmptyCartRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetCartRequest(): GetCartRequest {
  return { userId: "" };
}

export const GetCartRequest: MessageFns<GetCartRequest> = {
  encode(message: GetCartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCartRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetCartRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCartRequest>, I>>(base?: I): GetCartRequest {
    return GetCartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCartRequest>, I>>(object: I): GetCartRequest {
    const message = createBaseGetCartRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseCart(): Cart {
  return { userId: "", items: [] };
}

export const Cart: MessageFns<Cart> = {
  encode(message: Cart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cart {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: Cart): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cart>, I>>(base?: I): Cart {
    return Cart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cart>, I>>(object: I): Cart {
    const message = createBaseCart();
    message.userId = object.userId ?? "";
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseListRecommendationsRequest(): ListRecommendationsRequest {
  return { userId: "", productIds: [] };
}

export const ListRecommendationsRequest: MessageFns<ListRecommendationsRequest> = {
  encode(message: ListRecommendationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.productIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecommendationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecommendationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecommendationsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRecommendationsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecommendationsRequest>, I>>(base?: I): ListRecommendationsRequest {
    return ListRecommendationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecommendationsRequest>, I>>(object: I): ListRecommendationsRequest {
    const message = createBaseListRecommendationsRequest();
    message.userId = object.userId ?? "";
    message.productIds = object.productIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListRecommendationsResponse(): ListRecommendationsResponse {
  return { productIds: [] };
}

export const ListRecommendationsResponse: MessageFns<ListRecommendationsResponse> = {
  encode(message: ListRecommendationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecommendationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecommendationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecommendationsResponse {
    return {
      productIds: globalThis.Array.isArray(object?.productIds)
        ? object.productIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRecommendationsResponse): unknown {
    const obj: any = {};
    if (message.productIds?.length) {
      obj.productIds = message.productIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecommendationsResponse>, I>>(base?: I): ListRecommendationsResponse {
    return ListRecommendationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecommendationsResponse>, I>>(object: I): ListRecommendationsResponse {
    const message = createBaseListRecommendationsResponse();
    message.productIds = object.productIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetProductAttributesRequest(): GetProductAttributesRequest {
  return { productId: "" };
}

export const GetProductAttributesRequest: MessageFns<GetProductAttributesRequest> = {
  encode(message: GetProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductAttributesRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductAttributesRequest>, I>>(base?: I): GetProductAttributesRequest {
    return GetProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductAttributesRequest>, I>>(object: I): GetProductAttributesRequest {
    const message = createBaseGetProductAttributesRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetProductAttributesResponse(): GetProductAttributesResponse {
  return { attributes: [] };
}

export const GetProductAttributesResponse: MessageFns<GetProductAttributesResponse> = {
  encode(message: GetProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      ProductAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributes.push(ProductAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductAttributesResponse {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => ProductAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => ProductAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductAttributesResponse>, I>>(base?: I): GetProductAttributesResponse {
    return GetProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductAttributesResponse>, I>>(object: I): GetProductAttributesResponse {
    const message = createBaseGetProductAttributesResponse();
    message.attributes = object.attributes?.map((e) => ProductAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateProductAttributesRequest(): UpdateProductAttributesRequest {
  return { attribute: undefined };
}

export const UpdateProductAttributesRequest: MessageFns<UpdateProductAttributesRequest> = {
  encode(message: UpdateProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductAttributesRequest {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: UpdateProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductAttributesRequest>, I>>(base?: I): UpdateProductAttributesRequest {
    return UpdateProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductAttributesRequest>, I>>(
    object: I,
  ): UpdateProductAttributesRequest {
    const message = createBaseUpdateProductAttributesRequest();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductAttributesResponse(): UpdateProductAttributesResponse {
  return { attribute: undefined };
}

export const UpdateProductAttributesResponse: MessageFns<UpdateProductAttributesResponse> = {
  encode(message: UpdateProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductAttributesResponse {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: UpdateProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductAttributesResponse>, I>>(base?: I): UpdateProductAttributesResponse {
    return UpdateProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductAttributesResponse>, I>>(
    object: I,
  ): UpdateProductAttributesResponse {
    const message = createBaseUpdateProductAttributesResponse();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseDeleteProductAttributesRequest(): DeleteProductAttributesRequest {
  return { attributeId: "" };
}

export const DeleteProductAttributesRequest: MessageFns<DeleteProductAttributesRequest> = {
  encode(message: DeleteProductAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductAttributesRequest {
    return { attributeId: isSet(object.attributeId) ? globalThis.String(object.attributeId) : "" };
  },

  toJSON(message: DeleteProductAttributesRequest): unknown {
    const obj: any = {};
    if (message.attributeId !== "") {
      obj.attributeId = message.attributeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductAttributesRequest>, I>>(base?: I): DeleteProductAttributesRequest {
    return DeleteProductAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductAttributesRequest>, I>>(
    object: I,
  ): DeleteProductAttributesRequest {
    const message = createBaseDeleteProductAttributesRequest();
    message.attributeId = object.attributeId ?? "";
    return message;
  },
};

function createBaseDeleteProductAttributesResponse(): DeleteProductAttributesResponse {
  return { attributeId: "" };
}

export const DeleteProductAttributesResponse: MessageFns<DeleteProductAttributesResponse> = {
  encode(message: DeleteProductAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductAttributesResponse {
    return { attributeId: isSet(object.attributeId) ? globalThis.String(object.attributeId) : "" };
  },

  toJSON(message: DeleteProductAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributeId !== "") {
      obj.attributeId = message.attributeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductAttributesResponse>, I>>(base?: I): DeleteProductAttributesResponse {
    return DeleteProductAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductAttributesResponse>, I>>(
    object: I,
  ): DeleteProductAttributesResponse {
    const message = createBaseDeleteProductAttributesResponse();
    message.attributeId = object.attributeId ?? "";
    return message;
  },
};

function createBaseCreateProductAttributeRequest(): CreateProductAttributeRequest {
  return { attribute: undefined };
}

export const CreateProductAttributeRequest: MessageFns<CreateProductAttributeRequest> = {
  encode(message: CreateProductAttributeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductAttributeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductAttributeRequest {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: CreateProductAttributeRequest): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductAttributeRequest>, I>>(base?: I): CreateProductAttributeRequest {
    return CreateProductAttributeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductAttributeRequest>, I>>(
    object: I,
  ): CreateProductAttributeRequest {
    const message = createBaseCreateProductAttributeRequest();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseCreateProductAttributeResponse(): CreateProductAttributeResponse {
  return { attribute: undefined };
}

export const CreateProductAttributeResponse: MessageFns<CreateProductAttributeResponse> = {
  encode(message: CreateProductAttributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== undefined) {
      ProductAttribute.encode(message.attribute, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductAttributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductAttributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attribute = ProductAttribute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductAttributeResponse {
    return { attribute: isSet(object.attribute) ? ProductAttribute.fromJSON(object.attribute) : undefined };
  },

  toJSON(message: CreateProductAttributeResponse): unknown {
    const obj: any = {};
    if (message.attribute !== undefined) {
      obj.attribute = ProductAttribute.toJSON(message.attribute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductAttributeResponse>, I>>(base?: I): CreateProductAttributeResponse {
    return CreateProductAttributeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductAttributeResponse>, I>>(
    object: I,
  ): CreateProductAttributeResponse {
    const message = createBaseCreateProductAttributeResponse();
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? ProductAttribute.fromPartial(object.attribute)
      : undefined;
    return message;
  },
};

function createBaseProductAttribute(): ProductAttribute {
  return {
    id: "",
    name: "",
    required: false,
    visible: false,
    values: [],
    productId: "",
    variantable: false,
    filterable: false,
    searchable: false,
    displayOrder: 0,
  };
}

export const ProductAttribute: MessageFns<ProductAttribute> = {
  encode(message: ProductAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    if (message.visible !== false) {
      writer.uint32(32).bool(message.visible);
    }
    for (const v of message.values) {
      writer.uint32(42).string(v!);
    }
    if (message.productId !== "") {
      writer.uint32(50).string(message.productId);
    }
    if (message.variantable !== false) {
      writer.uint32(56).bool(message.variantable);
    }
    if (message.filterable !== false) {
      writer.uint32(64).bool(message.filterable);
    }
    if (message.searchable !== false) {
      writer.uint32(72).bool(message.searchable);
    }
    if (message.displayOrder !== 0) {
      writer.uint32(80).int32(message.displayOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visible = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.variantable = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.filterable = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.searchable = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.displayOrder = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      variantable: isSet(object.variantable) ? globalThis.Boolean(object.variantable) : false,
      filterable: isSet(object.filterable) ? globalThis.Boolean(object.filterable) : false,
      searchable: isSet(object.searchable) ? globalThis.Boolean(object.searchable) : false,
      displayOrder: isSet(object.displayOrder) ? globalThis.Number(object.displayOrder) : 0,
    };
  },

  toJSON(message: ProductAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.variantable !== false) {
      obj.variantable = message.variantable;
    }
    if (message.filterable !== false) {
      obj.filterable = message.filterable;
    }
    if (message.searchable !== false) {
      obj.searchable = message.searchable;
    }
    if (message.displayOrder !== 0) {
      obj.displayOrder = Math.round(message.displayOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductAttribute>, I>>(base?: I): ProductAttribute {
    return ProductAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductAttribute>, I>>(object: I): ProductAttribute {
    const message = createBaseProductAttribute();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.required = object.required ?? false;
    message.visible = object.visible ?? false;
    message.values = object.values?.map((e) => e) || [];
    message.productId = object.productId ?? "";
    message.variantable = object.variantable ?? false;
    message.filterable = object.filterable ?? false;
    message.searchable = object.searchable ?? false;
    message.displayOrder = object.displayOrder ?? 0;
    return message;
  },
};

function createBaseProduct(): Product {
  return {
    id: "",
    name: "",
    slug: "",
    description: "",
    costPrice: 0,
    basePrice: 0,
    sku: "",
    barcode: "",
    brandId: "",
    featured: false,
    status: "",
    createdAt: "",
    updatedAt: "",
    seo: undefined,
    taxable: false,
    shippable: false,
    categories: [],
    productTags: [],
    images: [],
    attributes: [],
    variants: [],
    dimensions: undefined,
    sizeCharts: [],
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.costPrice !== 0) {
      writer.uint32(45).float(message.costPrice);
    }
    if (message.basePrice !== 0) {
      writer.uint32(53).float(message.basePrice);
    }
    if (message.sku !== "") {
      writer.uint32(58).string(message.sku);
    }
    if (message.barcode !== "") {
      writer.uint32(66).string(message.barcode);
    }
    if (message.brandId !== "") {
      writer.uint32(74).string(message.brandId);
    }
    if (message.featured !== false) {
      writer.uint32(80).bool(message.featured);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    if (message.seo !== undefined) {
      Seo.encode(message.seo, writer.uint32(114).fork()).join();
    }
    if (message.taxable !== false) {
      writer.uint32(120).bool(message.taxable);
    }
    if (message.shippable !== false) {
      writer.uint32(128).bool(message.shippable);
    }
    for (const v of message.categories) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.productTags) {
      ProductTag.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.attributes) {
      ProductAttribute.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.variants) {
      ProductVariant.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.dimensions !== undefined) {
      Dimensions.encode(message.dimensions, writer.uint32(178).fork()).join();
    }
    for (const v of message.sizeCharts) {
      SizeChart.encode(v!, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.costPrice = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.basePrice = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.barcode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.brandId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.featured = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.seo = Seo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.taxable = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.shippable = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.productTags.push(ProductTag.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.attributes.push(ProductAttribute.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.variants.push(ProductVariant.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dimensions = Dimensions.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.sizeCharts.push(SizeChart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      costPrice: isSet(object.costPrice) ? globalThis.Number(object.costPrice) : 0,
      basePrice: isSet(object.basePrice) ? globalThis.Number(object.basePrice) : 0,
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      barcode: isSet(object.barcode) ? globalThis.String(object.barcode) : "",
      brandId: isSet(object.brandId) ? globalThis.String(object.brandId) : "",
      featured: isSet(object.featured) ? globalThis.Boolean(object.featured) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      seo: isSet(object.seo) ? Seo.fromJSON(object.seo) : undefined,
      taxable: isSet(object.taxable) ? globalThis.Boolean(object.taxable) : false,
      shippable: isSet(object.shippable) ? globalThis.Boolean(object.shippable) : false,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      productTags: globalThis.Array.isArray(object?.productTags)
        ? object.productTags.map((e: any) => ProductTag.fromJSON(e))
        : [],
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => Image.fromJSON(e)) : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => ProductAttribute.fromJSON(e))
        : [],
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => ProductVariant.fromJSON(e))
        : [],
      dimensions: isSet(object.dimensions) ? Dimensions.fromJSON(object.dimensions) : undefined,
      sizeCharts: globalThis.Array.isArray(object?.sizeCharts)
        ? object.sizeCharts.map((e: any) => SizeChart.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.costPrice !== 0) {
      obj.costPrice = message.costPrice;
    }
    if (message.basePrice !== 0) {
      obj.basePrice = message.basePrice;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.barcode !== "") {
      obj.barcode = message.barcode;
    }
    if (message.brandId !== "") {
      obj.brandId = message.brandId;
    }
    if (message.featured !== false) {
      obj.featured = message.featured;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.seo !== undefined) {
      obj.seo = Seo.toJSON(message.seo);
    }
    if (message.taxable !== false) {
      obj.taxable = message.taxable;
    }
    if (message.shippable !== false) {
      obj.shippable = message.shippable;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.productTags?.length) {
      obj.productTags = message.productTags.map((e) => ProductTag.toJSON(e));
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => ProductAttribute.toJSON(e));
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => ProductVariant.toJSON(e));
    }
    if (message.dimensions !== undefined) {
      obj.dimensions = Dimensions.toJSON(message.dimensions);
    }
    if (message.sizeCharts?.length) {
      obj.sizeCharts = message.sizeCharts.map((e) => SizeChart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Product>, I>>(base?: I): Product {
    return Product.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Product>, I>>(object: I): Product {
    const message = createBaseProduct();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.slug = object.slug ?? "";
    message.description = object.description ?? "";
    message.costPrice = object.costPrice ?? 0;
    message.basePrice = object.basePrice ?? 0;
    message.sku = object.sku ?? "";
    message.barcode = object.barcode ?? "";
    message.brandId = object.brandId ?? "";
    message.featured = object.featured ?? false;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.seo = (object.seo !== undefined && object.seo !== null) ? Seo.fromPartial(object.seo) : undefined;
    message.taxable = object.taxable ?? false;
    message.shippable = object.shippable ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.productTags = object.productTags?.map((e) => ProductTag.fromPartial(e)) || [];
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => ProductAttribute.fromPartial(e)) || [];
    message.variants = object.variants?.map((e) => ProductVariant.fromPartial(e)) || [];
    message.dimensions = (object.dimensions !== undefined && object.dimensions !== null)
      ? Dimensions.fromPartial(object.dimensions)
      : undefined;
    message.sizeCharts = object.sizeCharts?.map((e) => SizeChart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSizeChart(): SizeChart {
  return {
    id: "",
    name: "",
    category: "",
    description: undefined,
    productId: "",
    columns: [],
    rows: [],
    images: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const SizeChart: MessageFns<SizeChart> = {
  encode(message: SizeChart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.category !== "") {
      writer.uint32(26).string(message.category);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.productId !== "") {
      writer.uint32(42).string(message.productId);
    }
    for (const v of message.columns) {
      SizeChartColumn.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.rows) {
      SizeChartRow.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.images) {
      SizeChartImage.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.columns.push(SizeChartColumn.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rows.push(SizeChartRow.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.images.push(SizeChartImage.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChart {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => SizeChartColumn.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => SizeChartRow.fromJSON(e)) : [],
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => SizeChartImage.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: SizeChart): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => SizeChartColumn.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => SizeChartRow.toJSON(e));
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => SizeChartImage.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChart>, I>>(base?: I): SizeChart {
    return SizeChart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChart>, I>>(object: I): SizeChart {
    const message = createBaseSizeChart();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.category = object.category ?? "";
    message.description = object.description ?? undefined;
    message.productId = object.productId ?? "";
    message.columns = object.columns?.map((e) => SizeChartColumn.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => SizeChartRow.fromPartial(e)) || [];
    message.images = object.images?.map((e) => SizeChartImage.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSizeChartColumn(): SizeChartColumn {
  return { id: "", name: "", type: "", unit: undefined, sizeChartId: "", createdAt: "" };
}

export const SizeChartColumn: MessageFns<SizeChartColumn> = {
  encode(message: SizeChartColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.unit !== undefined) {
      writer.uint32(34).string(message.unit);
    }
    if (message.sizeChartId !== "") {
      writer.uint32(42).string(message.sizeChartId);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sizeChartId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartColumn {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      unit: isSet(object.unit) ? globalThis.String(object.unit) : undefined,
      sizeChartId: isSet(object.sizeChartId) ? globalThis.String(object.sizeChartId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: SizeChartColumn): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.unit !== undefined) {
      obj.unit = message.unit;
    }
    if (message.sizeChartId !== "") {
      obj.sizeChartId = message.sizeChartId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartColumn>, I>>(base?: I): SizeChartColumn {
    return SizeChartColumn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartColumn>, I>>(object: I): SizeChartColumn {
    const message = createBaseSizeChartColumn();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.unit = object.unit ?? undefined;
    message.sizeChartId = object.sizeChartId ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseSizeChartRow(): SizeChartRow {
  return { id: "", name: "", cells: [] };
}

export const SizeChartRow: MessageFns<SizeChartRow> = {
  encode(message: SizeChartRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.cells) {
      SizeChartCell.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cells.push(SizeChartCell.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartRow {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => SizeChartCell.fromJSON(e)) : [],
    };
  },

  toJSON(message: SizeChartRow): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => SizeChartCell.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartRow>, I>>(base?: I): SizeChartRow {
    return SizeChartRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartRow>, I>>(object: I): SizeChartRow {
    const message = createBaseSizeChartRow();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.cells = object.cells?.map((e) => SizeChartCell.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSizeChartCell(): SizeChartCell {
  return { id: "", value: "" };
}

export const SizeChartCell: MessageFns<SizeChartCell> = {
  encode(message: SizeChartCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartCell {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SizeChartCell): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartCell>, I>>(base?: I): SizeChartCell {
    return SizeChartCell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartCell>, I>>(object: I): SizeChartCell {
    const message = createBaseSizeChartCell();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSizeChartImage(): SizeChartImage {
  return { id: "", url: "", name: "", sizeChartId: "", createdAt: "" };
}

export const SizeChartImage: MessageFns<SizeChartImage> = {
  encode(message: SizeChartImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.sizeChartId !== "") {
      writer.uint32(34).string(message.sizeChartId);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SizeChartImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSizeChartImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sizeChartId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SizeChartImage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sizeChartId: isSet(object.sizeChartId) ? globalThis.String(object.sizeChartId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: SizeChartImage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sizeChartId !== "") {
      obj.sizeChartId = message.sizeChartId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SizeChartImage>, I>>(base?: I): SizeChartImage {
    return SizeChartImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SizeChartImage>, I>>(object: I): SizeChartImage {
    const message = createBaseSizeChartImage();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.name = object.name ?? "";
    message.sizeChartId = object.sizeChartId ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseProductTag(): ProductTag {
  return { id: "", tag: undefined, productId: "" };
}

export const ProductTag: MessageFns<ProductTag> = {
  encode(message: ProductTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tag !== undefined) {
      Tag.encode(message.tag, writer.uint32(18).fork()).join();
    }
    if (message.productId !== "") {
      writer.uint32(26).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductTag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tag: isSet(object.tag) ? Tag.fromJSON(object.tag) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
    };
  },

  toJSON(message: ProductTag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tag !== undefined) {
      obj.tag = Tag.toJSON(message.tag);
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductTag>, I>>(base?: I): ProductTag {
    return ProductTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductTag>, I>>(object: I): ProductTag {
    const message = createBaseProductTag();
    message.id = object.id ?? "";
    message.tag = (object.tag !== undefined && object.tag !== null) ? Tag.fromPartial(object.tag) : undefined;
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseTag(): Tag {
  return { id: "", name: "", createdAt: "", updatedAt: "" };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(34).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseDimensions(): Dimensions {
  return { length: 0, width: 0, height: 0, weight: 0 };
}

export const Dimensions: MessageFns<Dimensions> = {
  encode(message: Dimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.length !== 0) {
      writer.uint32(13).float(message.length);
    }
    if (message.width !== 0) {
      writer.uint32(21).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(29).float(message.height);
    }
    if (message.weight !== 0) {
      writer.uint32(37).float(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.length = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.width = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimensions {
    return {
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: Dimensions): unknown {
    const obj: any = {};
    if (message.length !== 0) {
      obj.length = message.length;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dimensions>, I>>(base?: I): Dimensions {
    return Dimensions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dimensions>, I>>(object: I): Dimensions {
    const message = createBaseDimensions();
    message.length = object.length ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseSeo(): Seo {
  return { title: "", description: "", keywords: "" };
}

export const Seo: MessageFns<Seo> = {
  encode(message: Seo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.keywords !== "") {
      writer.uint32(26).string(message.keywords);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Seo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keywords = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Seo {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      keywords: isSet(object.keywords) ? globalThis.String(object.keywords) : "",
    };
  },

  toJSON(message: Seo): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.keywords !== "") {
      obj.keywords = message.keywords;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Seo>, I>>(base?: I): Seo {
    return Seo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Seo>, I>>(object: I): Seo {
    const message = createBaseSeo();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.keywords = object.keywords ?? "";
    return message;
  },
};

function createBaseProductVariant(): ProductVariant {
  return { id: "", sku: "", price: 0, quantity: 0, lowStockThreshold: 0, warehouseId: "", images: [], attributes: [] };
}

export const ProductVariant: MessageFns<ProductVariant> = {
  encode(message: ProductVariant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sku !== "") {
      writer.uint32(18).string(message.sku);
    }
    if (message.price !== 0) {
      writer.uint32(29).float(message.price);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.lowStockThreshold !== 0) {
      writer.uint32(45).float(message.lowStockThreshold);
    }
    if (message.warehouseId !== "") {
      writer.uint32(50).string(message.warehouseId);
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.attributes) {
      VariantAttribute.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductVariant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.lowStockThreshold = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.warehouseId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attributes.push(VariantAttribute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductVariant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      lowStockThreshold: isSet(object.lowStockThreshold) ? globalThis.Number(object.lowStockThreshold) : 0,
      warehouseId: isSet(object.warehouseId) ? globalThis.String(object.warehouseId) : "",
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => Image.fromJSON(e)) : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VariantAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProductVariant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.lowStockThreshold !== 0) {
      obj.lowStockThreshold = message.lowStockThreshold;
    }
    if (message.warehouseId !== "") {
      obj.warehouseId = message.warehouseId;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VariantAttribute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductVariant>, I>>(base?: I): ProductVariant {
    return ProductVariant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductVariant>, I>>(object: I): ProductVariant {
    const message = createBaseProductVariant();
    message.id = object.id ?? "";
    message.sku = object.sku ?? "";
    message.price = object.price ?? 0;
    message.quantity = object.quantity ?? 0;
    message.lowStockThreshold = object.lowStockThreshold ?? 0;
    message.warehouseId = object.warehouseId ?? "";
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => VariantAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVariantAttribute(): VariantAttribute {
  return { id: "", name: "", value: "", extraValue: "" };
}

export const VariantAttribute: MessageFns<VariantAttribute> = {
  encode(message: VariantAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.extraValue !== "") {
      writer.uint32(34).string(message.extraValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      extraValue: isSet(object.extraValue) ? globalThis.String(object.extraValue) : "",
    };
  },

  toJSON(message: VariantAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.extraValue !== "") {
      obj.extraValue = message.extraValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VariantAttribute>, I>>(base?: I): VariantAttribute {
    return VariantAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VariantAttribute>, I>>(object: I): VariantAttribute {
    const message = createBaseVariantAttribute();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.extraValue = object.extraValue ?? "";
    return message;
  },
};

function createBaseImage(): Image {
  return { id: "", url: "", isMain: false };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.isMain !== false) {
      writer.uint32(24).bool(message.isMain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMain = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      isMain: isSet(object.isMain) ? globalThis.Boolean(object.isMain) : false,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.isMain !== false) {
      obj.isMain = message.isMain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Image>, I>>(base?: I): Image {
    return Image.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image>, I>>(object: I): Image {
    const message = createBaseImage();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.isMain = object.isMain ?? false;
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { product: undefined };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductRequest>, I>>(base?: I): CreateProductRequest {
    return CreateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductRequest>, I>>(object: I): CreateProductRequest {
    const message = createBaseCreateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return { product: undefined };
}

export const CreateProductResponse: MessageFns<CreateProductResponse> = {
  encode(message: CreateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductResponse>, I>>(base?: I): CreateProductResponse {
    return CreateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductResponse>, I>>(object: I): CreateProductResponse {
    const message = createBaseCreateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { product: undefined };
}

export const UpdateProductRequest: MessageFns<UpdateProductRequest> = {
  encode(message: UpdateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(base?: I): UpdateProductRequest {
    return UpdateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(object: I): UpdateProductRequest {
    const message = createBaseUpdateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return { product: undefined };
}

export const UpdateProductResponse: MessageFns<UpdateProductResponse> = {
  encode(message: UpdateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(base?: I): UpdateProductResponse {
    return UpdateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(object: I): UpdateProductResponse {
    const message = createBaseUpdateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { id: "" };
}

export const DeleteProductRequest: MessageFns<DeleteProductRequest> = {
  encode(message: DeleteProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteProductRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(base?: I): DeleteProductRequest {
    return DeleteProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(object: I): DeleteProductRequest {
    const message = createBaseDeleteProductRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteProductResponse(): DeleteProductResponse {
  return { id: "" };
}

export const DeleteProductResponse: MessageFns<DeleteProductResponse> = {
  encode(message: DeleteProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteProductResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(base?: I): DeleteProductResponse {
    return DeleteProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(object: I): DeleteProductResponse {
    const message = createBaseDeleteProductResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateVariantRequest(): CreateVariantRequest {
  return { variant: undefined };
}

export const CreateVariantRequest: MessageFns<CreateVariantRequest> = {
  encode(message: CreateVariantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      ProductVariant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = ProductVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantRequest {
    return { variant: isSet(object.variant) ? ProductVariant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: CreateVariantRequest): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = ProductVariant.toJSON(message.variant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVariantRequest>, I>>(base?: I): CreateVariantRequest {
    return CreateVariantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVariantRequest>, I>>(object: I): CreateVariantRequest {
    const message = createBaseCreateVariantRequest();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? ProductVariant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseCreateVariantResponse(): CreateVariantResponse {
  return { variant: undefined };
}

export const CreateVariantResponse: MessageFns<CreateVariantResponse> = {
  encode(message: CreateVariantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      ProductVariant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVariantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVariantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = ProductVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVariantResponse {
    return { variant: isSet(object.variant) ? ProductVariant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: CreateVariantResponse): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = ProductVariant.toJSON(message.variant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVariantResponse>, I>>(base?: I): CreateVariantResponse {
    return CreateVariantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVariantResponse>, I>>(object: I): CreateVariantResponse {
    const message = createBaseCreateVariantResponse();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? ProductVariant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseCreateBrandRequest(): CreateBrandRequest {
  return { brand: undefined };
}

export const CreateBrandRequest: MessageFns<CreateBrandRequest> = {
  encode(message: CreateBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandRequest {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandRequest): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBrandRequest>, I>>(base?: I): CreateBrandRequest {
    return CreateBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBrandRequest>, I>>(object: I): CreateBrandRequest {
    const message = createBaseCreateBrandRequest();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseCreateBrandResponse(): CreateBrandResponse {
  return { brand: undefined };
}

export const CreateBrandResponse: MessageFns<CreateBrandResponse> = {
  encode(message: CreateBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandResponse {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: CreateBrandResponse): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBrandResponse>, I>>(base?: I): CreateBrandResponse {
    return CreateBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBrandResponse>, I>>(object: I): CreateBrandResponse {
    const message = createBaseCreateBrandResponse();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseGetAllCategoryResponse(): GetAllCategoryResponse {
  return { categories: [] };
}

export const GetAllCategoryResponse: MessageFns<GetAllCategoryResponse> = {
  encode(message: GetAllCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      Category.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.categories.push(Category.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCategoryResponse {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => Category.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllCategoryResponse): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories.map((e) => Category.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCategoryResponse>, I>>(base?: I): GetAllCategoryResponse {
    return GetAllCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCategoryResponse>, I>>(object: I): GetAllCategoryResponse {
    const message = createBaseGetAllCategoryResponse();
    message.categories = object.categories?.map((e) => Category.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateCategoryRequest(): CreateCategoryRequest {
  return { category: undefined };
}

export const CreateCategoryRequest: MessageFns<CreateCategoryRequest> = {
  encode(message: CreateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryRequest {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: CreateCategoryRequest): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCategoryRequest>, I>>(base?: I): CreateCategoryRequest {
    return CreateCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCategoryRequest>, I>>(object: I): CreateCategoryRequest {
    const message = createBaseCreateCategoryRequest();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseCreateCategoryResponse(): CreateCategoryResponse {
  return { category: undefined };
}

export const CreateCategoryResponse: MessageFns<CreateCategoryResponse> = {
  encode(message: CreateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCategoryResponse {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: CreateCategoryResponse): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCategoryResponse>, I>>(base?: I): CreateCategoryResponse {
    return CreateCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCategoryResponse>, I>>(object: I): CreateCategoryResponse {
    const message = createBaseCreateCategoryResponse();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseUpdateCategoryRequest(): UpdateCategoryRequest {
  return { category: undefined };
}

export const UpdateCategoryRequest: MessageFns<UpdateCategoryRequest> = {
  encode(message: UpdateCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryRequest {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: UpdateCategoryRequest): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryRequest>, I>>(base?: I): UpdateCategoryRequest {
    return UpdateCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryRequest>, I>>(object: I): UpdateCategoryRequest {
    const message = createBaseUpdateCategoryRequest();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseUpdateCategoryResponse(): UpdateCategoryResponse {
  return { category: undefined };
}

export const UpdateCategoryResponse: MessageFns<UpdateCategoryResponse> = {
  encode(message: UpdateCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCategoryResponse {
    return { category: isSet(object.category) ? Category.fromJSON(object.category) : undefined };
  },

  toJSON(message: UpdateCategoryResponse): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCategoryResponse>, I>>(base?: I): UpdateCategoryResponse {
    return UpdateCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCategoryResponse>, I>>(object: I): UpdateCategoryResponse {
    const message = createBaseUpdateCategoryResponse();
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseDeleteCategoryRequest(): DeleteCategoryRequest {
  return { id: "" };
}

export const DeleteCategoryRequest: MessageFns<DeleteCategoryRequest> = {
  encode(message: DeleteCategoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCategoryRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryRequest>, I>>(base?: I): DeleteCategoryRequest {
    return DeleteCategoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryRequest>, I>>(object: I): DeleteCategoryRequest {
    const message = createBaseDeleteCategoryRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteCategoryResponse(): DeleteCategoryResponse {
  return { id: "" };
}

export const DeleteCategoryResponse: MessageFns<DeleteCategoryResponse> = {
  encode(message: DeleteCategoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCategoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCategoryResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCategoryResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCategoryResponse>, I>>(base?: I): DeleteCategoryResponse {
    return DeleteCategoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCategoryResponse>, I>>(object: I): DeleteCategoryResponse {
    const message = createBaseDeleteCategoryResponse();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateImageRequest(): CreateImageRequest {
  return { image: undefined };
}

export const CreateImageRequest: MessageFns<CreateImageRequest> = {
  encode(message: CreateImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageRequest {
    return { image: isSet(object.image) ? Image.fromJSON(object.image) : undefined };
  },

  toJSON(message: CreateImageRequest): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageRequest>, I>>(base?: I): CreateImageRequest {
    return CreateImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageRequest>, I>>(object: I): CreateImageRequest {
    const message = createBaseCreateImageRequest();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseCreateImageResponse(): CreateImageResponse {
  return { image: undefined };
}

export const CreateImageResponse: MessageFns<CreateImageResponse> = {
  encode(message: CreateImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageResponse {
    return { image: isSet(object.image) ? Image.fromJSON(object.image) : undefined };
  },

  toJSON(message: CreateImageResponse): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageResponse>, I>>(base?: I): CreateImageResponse {
    return CreateImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageResponse>, I>>(object: I): CreateImageResponse {
    const message = createBaseCreateImageResponse();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [] };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsResponse>, I>>(base?: I): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsResponse>, I>>(object: I): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListProductsRequest(): ListProductsRequest {
  return {};
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(_: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListProductsRequest {
    return {};
  },

  toJSON(_: ListProductsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsRequest>, I>>(base?: I): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsRequest>, I>>(_: I): ListProductsRequest {
    const message = createBaseListProductsRequest();
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { id: "" };
}

export const GetProductRequest: MessageFns<GetProductRequest> = {
  encode(message: GetProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetProductRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductRequest>, I>>(base?: I): GetProductRequest {
    return GetProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductRequest>, I>>(object: I): GetProductRequest {
    const message = createBaseGetProductRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { product: undefined };
}

export const GetProductResponse: MessageFns<GetProductResponse> = {
  encode(message: GetProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: GetProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductResponse>, I>>(base?: I): GetProductResponse {
    return GetProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductResponse>, I>>(object: I): GetProductResponse {
    const message = createBaseGetProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseVariant(): Variant {
  return { id: "", name: "", description: "", picture: "", priceUsd: undefined };
}

export const Variant: MessageFns<Variant> = {
  encode(message: Variant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.picture !== "") {
      writer.uint32(34).string(message.picture);
    }
    if (message.priceUsd !== undefined) {
      Money.encode(message.priceUsd, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.picture = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.priceUsd = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : "",
      priceUsd: isSet(object.priceUsd) ? Money.fromJSON(object.priceUsd) : undefined,
    };
  },

  toJSON(message: Variant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.picture !== "") {
      obj.picture = message.picture;
    }
    if (message.priceUsd !== undefined) {
      obj.priceUsd = Money.toJSON(message.priceUsd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Variant>, I>>(base?: I): Variant {
    return Variant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Variant>, I>>(object: I): Variant {
    const message = createBaseVariant();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.picture = object.picture ?? "";
    message.priceUsd = (object.priceUsd !== undefined && object.priceUsd !== null)
      ? Money.fromPartial(object.priceUsd)
      : undefined;
    return message;
  },
};

function createBaseBrand(): Brand {
  return { id: "", name: "", logo: "" };
}

export const Brand: MessageFns<Brand> = {
  encode(message: Brand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.logo !== "") {
      writer.uint32(26).string(message.logo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Brand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Brand {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      logo: isSet(object.logo) ? globalThis.String(object.logo) : "",
    };
  },

  toJSON(message: Brand): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.logo !== "") {
      obj.logo = message.logo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Brand>, I>>(base?: I): Brand {
    return Brand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Brand>, I>>(object: I): Brand {
    const message = createBaseBrand();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.logo = object.logo ?? "";
    return message;
  },
};

function createBaseCategory(): Category {
  return { id: "", name: "", parentId: "" };
}

export const Category: MessageFns<Category> = {
  encode(message: Category, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.parentId !== "") {
      writer.uint32(26).string(message.parentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Category {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Category {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
    };
  },

  toJSON(message: Category): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Category>, I>>(base?: I): Category {
    return Category.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Category>, I>>(object: I): Category {
    const message = createBaseCategory();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.parentId = object.parentId ?? "";
    return message;
  },
};

function createBaseGetWarehousesResponse(): GetWarehousesResponse {
  return { warehouses: [] };
}

export const GetWarehousesResponse: MessageFns<GetWarehousesResponse> = {
  encode(message: GetWarehousesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.warehouses) {
      Warehouse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWarehousesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWarehousesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.warehouses.push(Warehouse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWarehousesResponse {
    return {
      warehouses: globalThis.Array.isArray(object?.warehouses)
        ? object.warehouses.map((e: any) => Warehouse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetWarehousesResponse): unknown {
    const obj: any = {};
    if (message.warehouses?.length) {
      obj.warehouses = message.warehouses.map((e) => Warehouse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWarehousesResponse>, I>>(base?: I): GetWarehousesResponse {
    return GetWarehousesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWarehousesResponse>, I>>(object: I): GetWarehousesResponse {
    const message = createBaseGetWarehousesResponse();
    message.warehouses = object.warehouses?.map((e) => Warehouse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWarehouse(): Warehouse {
  return {
    id: "",
    name: "",
    code: "",
    location: [],
    address: "",
    manager: "",
    contact: "",
    status: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Warehouse: MessageFns<Warehouse> = {
  encode(message: Warehouse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    for (const v of message.location) {
      writer.uint32(34).string(v!);
    }
    if (message.address !== "") {
      writer.uint32(42).string(message.address);
    }
    if (message.manager !== "") {
      writer.uint32(50).string(message.manager);
    }
    if (message.contact !== "") {
      writer.uint32(58).string(message.contact);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Warehouse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWarehouse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contact = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Warehouse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.String(e)) : [],
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      contact: isSet(object.contact) ? globalThis.String(object.contact) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Warehouse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.location?.length) {
      obj.location = message.location;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.contact !== "") {
      obj.contact = message.contact;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Warehouse>, I>>(base?: I): Warehouse {
    return Warehouse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Warehouse>, I>>(object: I): Warehouse {
    const message = createBaseWarehouse();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.code = object.code ?? "";
    message.location = object.location?.map((e) => e) || [];
    message.address = object.address ?? "";
    message.manager = object.manager ?? "";
    message.contact = object.contact ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSearchProductsRequest(): SearchProductsRequest {
  return { query: "" };
}

export const SearchProductsRequest: MessageFns<SearchProductsRequest> = {
  encode(message: SearchProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SearchProductsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(base?: I): SearchProductsRequest {
    return SearchProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(object: I): SearchProductsRequest {
    const message = createBaseSearchProductsRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchProductsResponse(): SearchProductsResponse {
  return { results: [] };
}

export const SearchProductsResponse: MessageFns<SearchProductsResponse> = {
  encode(message: SearchProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Product.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchProductsResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(base?: I): SearchProductsResponse {
    return SearchProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(object: I): SearchProductsResponse {
    const message = createBaseSearchProductsResponse();
    message.results = object.results?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuoteRequest(): GetQuoteRequest {
  return { address: undefined, items: [] };
}

export const GetQuoteRequest: MessageFns<GetQuoteRequest> = {
  encode(message: GetQuoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteRequest {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetQuoteRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(base?: I): GetQuoteRequest {
    return GetQuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(object: I): GetQuoteRequest {
    const message = createBaseGetQuoteRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuoteResponse(): GetQuoteResponse {
  return { costUsd: undefined };
}

export const GetQuoteResponse: MessageFns<GetQuoteResponse> = {
  encode(message: GetQuoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.costUsd !== undefined) {
      Money.encode(message.costUsd, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.costUsd = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteResponse {
    return { costUsd: isSet(object.costUsd) ? Money.fromJSON(object.costUsd) : undefined };
  },

  toJSON(message: GetQuoteResponse): unknown {
    const obj: any = {};
    if (message.costUsd !== undefined) {
      obj.costUsd = Money.toJSON(message.costUsd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(base?: I): GetQuoteResponse {
    return GetQuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(object: I): GetQuoteResponse {
    const message = createBaseGetQuoteResponse();
    message.costUsd = (object.costUsd !== undefined && object.costUsd !== null)
      ? Money.fromPartial(object.costUsd)
      : undefined;
    return message;
  },
};

function createBaseShipOrderRequest(): ShipOrderRequest {
  return { address: undefined, items: [] };
}

export const ShipOrderRequest: MessageFns<ShipOrderRequest> = {
  encode(message: ShipOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.items) {
      CartItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CartItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipOrderRequest {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: ShipOrderRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShipOrderRequest>, I>>(base?: I): ShipOrderRequest {
    return ShipOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShipOrderRequest>, I>>(object: I): ShipOrderRequest {
    const message = createBaseShipOrderRequest();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.items = object.items?.map((e) => CartItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShipOrderResponse(): ShipOrderResponse {
  return { trackingId: "" };
}

export const ShipOrderResponse: MessageFns<ShipOrderResponse> = {
  encode(message: ShipOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShipOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShipOrderResponse {
    return { trackingId: isSet(object.trackingId) ? globalThis.String(object.trackingId) : "" };
  },

  toJSON(message: ShipOrderResponse): unknown {
    const obj: any = {};
    if (message.trackingId !== "") {
      obj.trackingId = message.trackingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShipOrderResponse>, I>>(base?: I): ShipOrderResponse {
    return ShipOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShipOrderResponse>, I>>(object: I): ShipOrderResponse {
    const message = createBaseShipOrderResponse();
    message.trackingId = object.trackingId ?? "";
    return message;
  },
};

function createBaseMoney(): Money {
  return { currencyCode: "", units: 0, nanos: 0 };
}

export const Money: MessageFns<Money> = {
  encode(message: Money, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.units !== 0) {
      writer.uint32(16).int64(message.units);
    }
    if (message.nanos !== 0) {
      writer.uint32(24).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Money {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.units = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Money {
    return {
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      units: isSet(object.units) ? globalThis.Number(object.units) : 0,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: Money): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.units !== 0) {
      obj.units = Math.round(message.units);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Money>, I>>(base?: I): Money {
    return Money.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Money>, I>>(object: I): Money {
    const message = createBaseMoney();
    message.currencyCode = object.currencyCode ?? "";
    message.units = object.units ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseGetSupportedCurrenciesResponse(): GetSupportedCurrenciesResponse {
  return { currencyCodes: [] };
}

export const GetSupportedCurrenciesResponse: MessageFns<GetSupportedCurrenciesResponse> = {
  encode(message: GetSupportedCurrenciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.currencyCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSupportedCurrenciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSupportedCurrenciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSupportedCurrenciesResponse {
    return {
      currencyCodes: globalThis.Array.isArray(object?.currencyCodes)
        ? object.currencyCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetSupportedCurrenciesResponse): unknown {
    const obj: any = {};
    if (message.currencyCodes?.length) {
      obj.currencyCodes = message.currencyCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSupportedCurrenciesResponse>, I>>(base?: I): GetSupportedCurrenciesResponse {
    return GetSupportedCurrenciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSupportedCurrenciesResponse>, I>>(
    object: I,
  ): GetSupportedCurrenciesResponse {
    const message = createBaseGetSupportedCurrenciesResponse();
    message.currencyCodes = object.currencyCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCurrencyConversionRequest(): CurrencyConversionRequest {
  return { from: undefined, toCode: "" };
}

export const CurrencyConversionRequest: MessageFns<CurrencyConversionRequest> = {
  encode(message: CurrencyConversionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.from !== undefined) {
      Money.encode(message.from, writer.uint32(10).fork()).join();
    }
    if (message.toCode !== "") {
      writer.uint32(18).string(message.toCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyConversionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyConversionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.from = Money.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyConversionRequest {
    return {
      from: isSet(object.from) ? Money.fromJSON(object.from) : undefined,
      toCode: isSet(object.toCode) ? globalThis.String(object.toCode) : "",
    };
  },

  toJSON(message: CurrencyConversionRequest): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Money.toJSON(message.from);
    }
    if (message.toCode !== "") {
      obj.toCode = message.toCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyConversionRequest>, I>>(base?: I): CurrencyConversionRequest {
    return CurrencyConversionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyConversionRequest>, I>>(object: I): CurrencyConversionRequest {
    const message = createBaseCurrencyConversionRequest();
    message.from = (object.from !== undefined && object.from !== null) ? Money.fromPartial(object.from) : undefined;
    message.toCode = object.toCode ?? "";
    return message;
  },
};

function createBaseCreditCardInfo(): CreditCardInfo {
  return { creditCardNumber: "", creditCardCvv: 0, creditCardExpirationYear: 0, creditCardExpirationMonth: 0 };
}

export const CreditCardInfo: MessageFns<CreditCardInfo> = {
  encode(message: CreditCardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creditCardNumber !== "") {
      writer.uint32(10).string(message.creditCardNumber);
    }
    if (message.creditCardCvv !== 0) {
      writer.uint32(16).int32(message.creditCardCvv);
    }
    if (message.creditCardExpirationYear !== 0) {
      writer.uint32(24).int32(message.creditCardExpirationYear);
    }
    if (message.creditCardExpirationMonth !== 0) {
      writer.uint32(32).int32(message.creditCardExpirationMonth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreditCardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreditCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creditCardNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.creditCardCvv = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.creditCardExpirationYear = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.creditCardExpirationMonth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreditCardInfo {
    return {
      creditCardNumber: isSet(object.creditCardNumber) ? globalThis.String(object.creditCardNumber) : "",
      creditCardCvv: isSet(object.creditCardCvv) ? globalThis.Number(object.creditCardCvv) : 0,
      creditCardExpirationYear: isSet(object.creditCardExpirationYear)
        ? globalThis.Number(object.creditCardExpirationYear)
        : 0,
      creditCardExpirationMonth: isSet(object.creditCardExpirationMonth)
        ? globalThis.Number(object.creditCardExpirationMonth)
        : 0,
    };
  },

  toJSON(message: CreditCardInfo): unknown {
    const obj: any = {};
    if (message.creditCardNumber !== "") {
      obj.creditCardNumber = message.creditCardNumber;
    }
    if (message.creditCardCvv !== 0) {
      obj.creditCardCvv = Math.round(message.creditCardCvv);
    }
    if (message.creditCardExpirationYear !== 0) {
      obj.creditCardExpirationYear = Math.round(message.creditCardExpirationYear);
    }
    if (message.creditCardExpirationMonth !== 0) {
      obj.creditCardExpirationMonth = Math.round(message.creditCardExpirationMonth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreditCardInfo>, I>>(base?: I): CreditCardInfo {
    return CreditCardInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreditCardInfo>, I>>(object: I): CreditCardInfo {
    const message = createBaseCreditCardInfo();
    message.creditCardNumber = object.creditCardNumber ?? "";
    message.creditCardCvv = object.creditCardCvv ?? 0;
    message.creditCardExpirationYear = object.creditCardExpirationYear ?? 0;
    message.creditCardExpirationMonth = object.creditCardExpirationMonth ?? 0;
    return message;
  },
};

function createBaseChargeRequest(): ChargeRequest {
  return { amount: undefined, creditCard: undefined };
}

export const ChargeRequest: MessageFns<ChargeRequest> = {
  encode(message: ChargeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.creditCard !== undefined) {
      CreditCardInfo.encode(message.creditCard, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChargeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChargeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creditCard = CreditCardInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChargeRequest {
    return {
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      creditCard: isSet(object.creditCard) ? CreditCardInfo.fromJSON(object.creditCard) : undefined,
    };
  },

  toJSON(message: ChargeRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.creditCard !== undefined) {
      obj.creditCard = CreditCardInfo.toJSON(message.creditCard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChargeRequest>, I>>(base?: I): ChargeRequest {
    return ChargeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChargeRequest>, I>>(object: I): ChargeRequest {
    const message = createBaseChargeRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.creditCard = (object.creditCard !== undefined && object.creditCard !== null)
      ? CreditCardInfo.fromPartial(object.creditCard)
      : undefined;
    return message;
  },
};

function createBaseChargeResponse(): ChargeResponse {
  return { transactionId: "" };
}

export const ChargeResponse: MessageFns<ChargeResponse> = {
  encode(message: ChargeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChargeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChargeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChargeResponse {
    return { transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "" };
  },

  toJSON(message: ChargeResponse): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChargeResponse>, I>>(base?: I): ChargeResponse {
    return ChargeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChargeResponse>, I>>(object: I): ChargeResponse {
    const message = createBaseChargeResponse();
    message.transactionId = object.transactionId ?? "";
    return message;
  },
};

function createBaseOrderItem(): OrderItem {
  return { item: undefined, cost: undefined };
}

export const OrderItem: MessageFns<OrderItem> = {
  encode(message: OrderItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      CartItem.encode(message.item, writer.uint32(10).fork()).join();
    }
    if (message.cost !== undefined) {
      Money.encode(message.cost, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item = CartItem.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cost = Money.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderItem {
    return {
      item: isSet(object.item) ? CartItem.fromJSON(object.item) : undefined,
      cost: isSet(object.cost) ? Money.fromJSON(object.cost) : undefined,
    };
  },

  toJSON(message: OrderItem): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = CartItem.toJSON(message.item);
    }
    if (message.cost !== undefined) {
      obj.cost = Money.toJSON(message.cost);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderItem>, I>>(base?: I): OrderItem {
    return OrderItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderItem>, I>>(object: I): OrderItem {
    const message = createBaseOrderItem();
    message.item = (object.item !== undefined && object.item !== null) ? CartItem.fromPartial(object.item) : undefined;
    message.cost = (object.cost !== undefined && object.cost !== null) ? Money.fromPartial(object.cost) : undefined;
    return message;
  },
};

function createBaseOrderResult(): OrderResult {
  return { orderId: "", shippingTrackingId: "", shippingCost: undefined, shippingAddress: undefined, items: [] };
}

export const OrderResult: MessageFns<OrderResult> = {
  encode(message: OrderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.shippingTrackingId !== "") {
      writer.uint32(18).string(message.shippingTrackingId);
    }
    if (message.shippingCost !== undefined) {
      Money.encode(message.shippingCost, writer.uint32(26).fork()).join();
    }
    if (message.shippingAddress !== undefined) {
      Address.encode(message.shippingAddress, writer.uint32(34).fork()).join();
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shippingTrackingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shippingCost = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shippingAddress = Address.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderResult {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      shippingTrackingId: isSet(object.shippingTrackingId) ? globalThis.String(object.shippingTrackingId) : "",
      shippingCost: isSet(object.shippingCost) ? Money.fromJSON(object.shippingCost) : undefined,
      shippingAddress: isSet(object.shippingAddress) ? Address.fromJSON(object.shippingAddress) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: OrderResult): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.shippingTrackingId !== "") {
      obj.shippingTrackingId = message.shippingTrackingId;
    }
    if (message.shippingCost !== undefined) {
      obj.shippingCost = Money.toJSON(message.shippingCost);
    }
    if (message.shippingAddress !== undefined) {
      obj.shippingAddress = Address.toJSON(message.shippingAddress);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderResult>, I>>(base?: I): OrderResult {
    return OrderResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderResult>, I>>(object: I): OrderResult {
    const message = createBaseOrderResult();
    message.orderId = object.orderId ?? "";
    message.shippingTrackingId = object.shippingTrackingId ?? "";
    message.shippingCost = (object.shippingCost !== undefined && object.shippingCost !== null)
      ? Money.fromPartial(object.shippingCost)
      : undefined;
    message.shippingAddress = (object.shippingAddress !== undefined && object.shippingAddress !== null)
      ? Address.fromPartial(object.shippingAddress)
      : undefined;
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendOrderConfirmationRequest(): SendOrderConfirmationRequest {
  return { email: "", order: undefined };
}

export const SendOrderConfirmationRequest: MessageFns<SendOrderConfirmationRequest> = {
  encode(message: SendOrderConfirmationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.order !== undefined) {
      OrderResult.encode(message.order, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendOrderConfirmationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOrderConfirmationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.order = OrderResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOrderConfirmationRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      order: isSet(object.order) ? OrderResult.fromJSON(object.order) : undefined,
    };
  },

  toJSON(message: SendOrderConfirmationRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.order !== undefined) {
      obj.order = OrderResult.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOrderConfirmationRequest>, I>>(base?: I): SendOrderConfirmationRequest {
    return SendOrderConfirmationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOrderConfirmationRequest>, I>>(object: I): SendOrderConfirmationRequest {
    const message = createBaseSendOrderConfirmationRequest();
    message.email = object.email ?? "";
    message.order = (object.order !== undefined && object.order !== null)
      ? OrderResult.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseSendOTPResetPasswordRequest(): SendOTPResetPasswordRequest {
  return { email: "", verificationCode: "" };
}

export const SendOTPResetPasswordRequest: MessageFns<SendOTPResetPasswordRequest> = {
  encode(message: SendOTPResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.verificationCode !== "") {
      writer.uint32(18).string(message.verificationCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendOTPResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOTPResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verificationCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOTPResetPasswordRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      verificationCode: isSet(object.verificationCode) ? globalThis.String(object.verificationCode) : "",
    };
  },

  toJSON(message: SendOTPResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.verificationCode !== "") {
      obj.verificationCode = message.verificationCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOTPResetPasswordRequest>, I>>(base?: I): SendOTPResetPasswordRequest {
    return SendOTPResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOTPResetPasswordRequest>, I>>(object: I): SendOTPResetPasswordRequest {
    const message = createBaseSendOTPResetPasswordRequest();
    message.email = object.email ?? "";
    message.verificationCode = object.verificationCode ?? "";
    return message;
  },
};

function createBaseSendOTPResetPasswordResponse(): SendOTPResetPasswordResponse {
  return { success: false, message: "" };
}

export const SendOTPResetPasswordResponse: MessageFns<SendOTPResetPasswordResponse> = {
  encode(message: SendOTPResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendOTPResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOTPResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOTPResetPasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendOTPResetPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOTPResetPasswordResponse>, I>>(base?: I): SendOTPResetPasswordResponse {
    return SendOTPResetPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOTPResetPasswordResponse>, I>>(object: I): SendOTPResetPasswordResponse {
    const message = createBaseSendOTPResetPasswordResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSendWelcomeEmailRequest(): SendWelcomeEmailRequest {
  return { email: "", name: "", token: "" };
}

export const SendWelcomeEmailRequest: MessageFns<SendWelcomeEmailRequest> = {
  encode(message: SendWelcomeEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendWelcomeEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendWelcomeEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendWelcomeEmailRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: SendWelcomeEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendWelcomeEmailRequest>, I>>(base?: I): SendWelcomeEmailRequest {
    return SendWelcomeEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendWelcomeEmailRequest>, I>>(object: I): SendWelcomeEmailRequest {
    const message = createBaseSendWelcomeEmailRequest();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseSendWelcomeEmailResponse(): SendWelcomeEmailResponse {
  return { success: false, message: "" };
}

export const SendWelcomeEmailResponse: MessageFns<SendWelcomeEmailResponse> = {
  encode(message: SendWelcomeEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendWelcomeEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendWelcomeEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendWelcomeEmailResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SendWelcomeEmailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendWelcomeEmailResponse>, I>>(base?: I): SendWelcomeEmailResponse {
    return SendWelcomeEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendWelcomeEmailResponse>, I>>(object: I): SendWelcomeEmailResponse {
    const message = createBaseSendWelcomeEmailResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePlaceOrderRequest(): PlaceOrderRequest {
  return { userId: "", userCurrency: "", address: undefined, email: "", creditCard: undefined };
}

export const PlaceOrderRequest: MessageFns<PlaceOrderRequest> = {
  encode(message: PlaceOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.userCurrency !== "") {
      writer.uint32(18).string(message.userCurrency);
    }
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.creditCard !== undefined) {
      CreditCardInfo.encode(message.creditCard, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userCurrency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creditCard = CreditCardInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceOrderRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userCurrency: isSet(object.userCurrency) ? globalThis.String(object.userCurrency) : "",
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      creditCard: isSet(object.creditCard) ? CreditCardInfo.fromJSON(object.creditCard) : undefined,
    };
  },

  toJSON(message: PlaceOrderRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userCurrency !== "") {
      obj.userCurrency = message.userCurrency;
    }
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.creditCard !== undefined) {
      obj.creditCard = CreditCardInfo.toJSON(message.creditCard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceOrderRequest>, I>>(base?: I): PlaceOrderRequest {
    return PlaceOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceOrderRequest>, I>>(object: I): PlaceOrderRequest {
    const message = createBasePlaceOrderRequest();
    message.userId = object.userId ?? "";
    message.userCurrency = object.userCurrency ?? "";
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.email = object.email ?? "";
    message.creditCard = (object.creditCard !== undefined && object.creditCard !== null)
      ? CreditCardInfo.fromPartial(object.creditCard)
      : undefined;
    return message;
  },
};

function createBasePlaceOrderResponse(): PlaceOrderResponse {
  return { order: undefined };
}

export const PlaceOrderResponse: MessageFns<PlaceOrderResponse> = {
  encode(message: PlaceOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderResult.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceOrderResponse {
    return { order: isSet(object.order) ? OrderResult.fromJSON(object.order) : undefined };
  },

  toJSON(message: PlaceOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderResult.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceOrderResponse>, I>>(base?: I): PlaceOrderResponse {
    return PlaceOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceOrderResponse>, I>>(object: I): PlaceOrderResponse {
    const message = createBasePlaceOrderResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? OrderResult.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseAdRequest(): AdRequest {
  return { contextKeys: [] };
}

export const AdRequest: MessageFns<AdRequest> = {
  encode(message: AdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contextKeys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contextKeys.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdRequest {
    return {
      contextKeys: globalThis.Array.isArray(object?.contextKeys)
        ? object.contextKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AdRequest): unknown {
    const obj: any = {};
    if (message.contextKeys?.length) {
      obj.contextKeys = message.contextKeys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdRequest>, I>>(base?: I): AdRequest {
    return AdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdRequest>, I>>(object: I): AdRequest {
    const message = createBaseAdRequest();
    message.contextKeys = object.contextKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseAdResponse(): AdResponse {
  return { ads: [] };
}

export const AdResponse: MessageFns<AdResponse> = {
  encode(message: AdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ads) {
      Ad.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ads.push(Ad.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdResponse {
    return { ads: globalThis.Array.isArray(object?.ads) ? object.ads.map((e: any) => Ad.fromJSON(e)) : [] };
  },

  toJSON(message: AdResponse): unknown {
    const obj: any = {};
    if (message.ads?.length) {
      obj.ads = message.ads.map((e) => Ad.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdResponse>, I>>(base?: I): AdResponse {
    return AdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdResponse>, I>>(object: I): AdResponse {
    const message = createBaseAdResponse();
    message.ads = object.ads?.map((e) => Ad.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAd(): Ad {
  return { redirectUrl: "", text: "" };
}

export const Ad: MessageFns<Ad> = {
  encode(message: Ad, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUrl !== "") {
      writer.uint32(10).string(message.redirectUrl);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ad {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ad {
    return {
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: Ad): unknown {
    const obj: any = {};
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ad>, I>>(base?: I): Ad {
    return Ad.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ad>, I>>(object: I): Ad {
    const message = createBaseAd();
    message.redirectUrl = object.redirectUrl ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseFlag(): Flag {
  return { name: "", description: "", enabled: false };
}

export const Flag: MessageFns<Flag> = {
  encode(message: Flag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.enabled !== false) {
      writer.uint32(24).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Flag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Flag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: Flag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Flag>, I>>(base?: I): Flag {
    return Flag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Flag>, I>>(object: I): Flag {
    const message = createBaseFlag();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGetFlagRequest(): GetFlagRequest {
  return { name: "" };
}

export const GetFlagRequest: MessageFns<GetFlagRequest> = {
  encode(message: GetFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFlagRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFlagRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFlagRequest>, I>>(base?: I): GetFlagRequest {
    return GetFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFlagRequest>, I>>(object: I): GetFlagRequest {
    const message = createBaseGetFlagRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetFlagResponse(): GetFlagResponse {
  return { flag: undefined };
}

export const GetFlagResponse: MessageFns<GetFlagResponse> = {
  encode(message: GetFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFlagResponse {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: GetFlagResponse): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFlagResponse>, I>>(base?: I): GetFlagResponse {
    return GetFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFlagResponse>, I>>(object: I): GetFlagResponse {
    const message = createBaseGetFlagResponse();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseCreateFlagRequest(): CreateFlagRequest {
  return { name: "", description: "", enabled: false };
}

export const CreateFlagRequest: MessageFns<CreateFlagRequest> = {
  encode(message: CreateFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.enabled !== false) {
      writer.uint32(24).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFlagRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: CreateFlagRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFlagRequest>, I>>(base?: I): CreateFlagRequest {
    return CreateFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFlagRequest>, I>>(object: I): CreateFlagRequest {
    const message = createBaseCreateFlagRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCreateFlagResponse(): CreateFlagResponse {
  return { flag: undefined };
}

export const CreateFlagResponse: MessageFns<CreateFlagResponse> = {
  encode(message: CreateFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined) {
      Flag.encode(message.flag, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flag = Flag.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFlagResponse {
    return { flag: isSet(object.flag) ? Flag.fromJSON(object.flag) : undefined };
  },

  toJSON(message: CreateFlagResponse): unknown {
    const obj: any = {};
    if (message.flag !== undefined) {
      obj.flag = Flag.toJSON(message.flag);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFlagResponse>, I>>(base?: I): CreateFlagResponse {
    return CreateFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFlagResponse>, I>>(object: I): CreateFlagResponse {
    const message = createBaseCreateFlagResponse();
    message.flag = (object.flag !== undefined && object.flag !== null) ? Flag.fromPartial(object.flag) : undefined;
    return message;
  },
};

function createBaseUpdateFlagRequest(): UpdateFlagRequest {
  return { name: "", enabled: false };
}

export const UpdateFlagRequest: MessageFns<UpdateFlagRequest> = {
  encode(message: UpdateFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFlagRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: UpdateFlagRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFlagRequest>, I>>(base?: I): UpdateFlagRequest {
    return UpdateFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFlagRequest>, I>>(object: I): UpdateFlagRequest {
    const message = createBaseUpdateFlagRequest();
    message.name = object.name ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseUpdateFlagResponse(): UpdateFlagResponse {
  return {};
}

export const UpdateFlagResponse: MessageFns<UpdateFlagResponse> = {
  encode(_: UpdateFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateFlagResponse {
    return {};
  },

  toJSON(_: UpdateFlagResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFlagResponse>, I>>(base?: I): UpdateFlagResponse {
    return UpdateFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFlagResponse>, I>>(_: I): UpdateFlagResponse {
    const message = createBaseUpdateFlagResponse();
    return message;
  },
};

function createBaseListFlagsRequest(): ListFlagsRequest {
  return {};
}

export const ListFlagsRequest: MessageFns<ListFlagsRequest> = {
  encode(_: ListFlagsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlagsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListFlagsRequest {
    return {};
  },

  toJSON(_: ListFlagsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlagsRequest>, I>>(base?: I): ListFlagsRequest {
    return ListFlagsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlagsRequest>, I>>(_: I): ListFlagsRequest {
    const message = createBaseListFlagsRequest();
    return message;
  },
};

function createBaseListFlagsResponse(): ListFlagsResponse {
  return { flag: [] };
}

export const ListFlagsResponse: MessageFns<ListFlagsResponse> = {
  encode(message: ListFlagsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flag) {
      Flag.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFlagsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFlagsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flag.push(Flag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFlagsResponse {
    return { flag: globalThis.Array.isArray(object?.flag) ? object.flag.map((e: any) => Flag.fromJSON(e)) : [] };
  },

  toJSON(message: ListFlagsResponse): unknown {
    const obj: any = {};
    if (message.flag?.length) {
      obj.flag = message.flag.map((e) => Flag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFlagsResponse>, I>>(base?: I): ListFlagsResponse {
    return ListFlagsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFlagsResponse>, I>>(object: I): ListFlagsResponse {
    const message = createBaseListFlagsResponse();
    message.flag = object.flag?.map((e) => Flag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteFlagRequest(): DeleteFlagRequest {
  return { name: "" };
}

export const DeleteFlagRequest: MessageFns<DeleteFlagRequest> = {
  encode(message: DeleteFlagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFlagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFlagRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteFlagRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFlagRequest>, I>>(base?: I): DeleteFlagRequest {
    return DeleteFlagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFlagRequest>, I>>(object: I): DeleteFlagRequest {
    const message = createBaseDeleteFlagRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteFlagResponse(): DeleteFlagResponse {
  return {};
}

export const DeleteFlagResponse: MessageFns<DeleteFlagResponse> = {
  encode(_: DeleteFlagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFlagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFlagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteFlagResponse {
    return {};
  },

  toJSON(_: DeleteFlagResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFlagResponse>, I>>(base?: I): DeleteFlagResponse {
    return DeleteFlagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFlagResponse>, I>>(_: I): DeleteFlagResponse {
    const message = createBaseDeleteFlagResponse();
    return message;
  },
};

function createBaseNewBrandRequest(): NewBrandRequest {
  return { brand: undefined };
}

export const NewBrandRequest: MessageFns<NewBrandRequest> = {
  encode(message: NewBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBrandRequest {
    return { brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined };
  },

  toJSON(message: NewBrandRequest): unknown {
    const obj: any = {};
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBrandRequest>, I>>(base?: I): NewBrandRequest {
    return NewBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBrandRequest>, I>>(object: I): NewBrandRequest {
    const message = createBaseNewBrandRequest();
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseNewBrandResponse(): NewBrandResponse {
  return { success: false, message: "", brand: undefined };
}

export const NewBrandResponse: MessageFns<NewBrandResponse> = {
  encode(message: NewBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined,
    };
  },

  toJSON(message: NewBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewBrandResponse>, I>>(base?: I): NewBrandResponse {
    return NewBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewBrandResponse>, I>>(object: I): NewBrandResponse {
    const message = createBaseNewBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseRemoveBrandRequest(): RemoveBrandRequest {
  return { id: "" };
}

export const RemoveBrandRequest: MessageFns<RemoveBrandRequest> = {
  encode(message: RemoveBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveBrandRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: RemoveBrandRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveBrandRequest>, I>>(base?: I): RemoveBrandRequest {
    return RemoveBrandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveBrandRequest>, I>>(object: I): RemoveBrandRequest {
    const message = createBaseRemoveBrandRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRemoveBrandResponse(): RemoveBrandResponse {
  return { success: false, message: "" };
}

export const RemoveBrandResponse: MessageFns<RemoveBrandResponse> = {
  encode(message: RemoveBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RemoveBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveBrandResponse>, I>>(base?: I): RemoveBrandResponse {
    return RemoveBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveBrandResponse>, I>>(object: I): RemoveBrandResponse {
    const message = createBaseRemoveBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetAllBrandResponse(): GetAllBrandResponse {
  return { success: false, message: "", brands: [] };
}

export const GetAllBrandResponse: MessageFns<GetAllBrandResponse> = {
  encode(message: GetAllBrandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.brands) {
      Brand.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllBrandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.brands.push(Brand.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllBrandResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      brands: globalThis.Array.isArray(object?.brands) ? object.brands.map((e: any) => Brand.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAllBrandResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.brands?.length) {
      obj.brands = message.brands.map((e) => Brand.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllBrandResponse>, I>>(base?: I): GetAllBrandResponse {
    return GetAllBrandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllBrandResponse>, I>>(object: I): GetAllBrandResponse {
    const message = createBaseGetAllBrandResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.brands = object.brands?.map((e) => Brand.fromPartial(e)) || [];
    return message;
  },
};

export type AddressServiceService = typeof AddressServiceService;
export const AddressServiceService = {
  getCountries: {
    path: "/nexuraTelemetry.AddressService/GetCountries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetCountriesResponse) => Buffer.from(GetCountriesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetCountriesResponse.decode(value),
  },
  getProvincesByCountry: {
    path: "/nexuraTelemetry.AddressService/GetProvincesByCountry",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProvincesByCountryRequest) =>
      Buffer.from(GetProvincesByCountryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProvincesByCountryRequest.decode(value),
    responseSerialize: (value: GetProvincesResponse) => Buffer.from(GetProvincesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProvincesResponse.decode(value),
  },
  getDistrictsByProvince: {
    path: "/nexuraTelemetry.AddressService/GetDistrictsByProvince",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDistrictsByProvinceRequest) =>
      Buffer.from(GetDistrictsByProvinceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDistrictsByProvinceRequest.decode(value),
    responseSerialize: (value: GetDistrictsResponse) => Buffer.from(GetDistrictsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDistrictsResponse.decode(value),
  },
  getWardsByDistrict: {
    path: "/nexuraTelemetry.AddressService/GetWardsByDistrict",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWardsByDistrictRequest) =>
      Buffer.from(GetWardsByDistrictRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWardsByDistrictRequest.decode(value),
    responseSerialize: (value: GetWardsResponse) => Buffer.from(GetWardsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWardsResponse.decode(value),
  },
  addAddress: {
    path: "/nexuraTelemetry.AddressService/AddAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddAddressRequest) => Buffer.from(AddAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  updateAddress: {
    path: "/nexuraTelemetry.AddressService/UpdateAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAddressRequest) => Buffer.from(UpdateAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  deleteAddress: {
    path: "/nexuraTelemetry.AddressService/DeleteAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAddressRequest) => Buffer.from(DeleteAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteAddressRequest.decode(value),
    responseSerialize: (value: DeleteAddressResponse) => Buffer.from(DeleteAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteAddressResponse.decode(value),
  },
  getAddresses: {
    path: "/nexuraTelemetry.AddressService/GetAddresses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAddressesRequest) => Buffer.from(GetAddressesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAddressesRequest.decode(value),
    responseSerialize: (value: GetAddressesResponse) => Buffer.from(GetAddressesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAddressesResponse.decode(value),
  },
} as const;

export interface AddressServiceServer extends UntypedServiceImplementation {
  getCountries: handleUnaryCall<Empty, GetCountriesResponse>;
  getProvincesByCountry: handleUnaryCall<GetProvincesByCountryRequest, GetProvincesResponse>;
  getDistrictsByProvince: handleUnaryCall<GetDistrictsByProvinceRequest, GetDistrictsResponse>;
  getWardsByDistrict: handleUnaryCall<GetWardsByDistrictRequest, GetWardsResponse>;
  addAddress: handleUnaryCall<AddAddressRequest, AddressResponse>;
  updateAddress: handleUnaryCall<UpdateAddressRequest, AddressResponse>;
  deleteAddress: handleUnaryCall<DeleteAddressRequest, DeleteAddressResponse>;
  getAddresses: handleUnaryCall<GetAddressesRequest, GetAddressesResponse>;
}

export interface AddressServiceClient extends Client {
  getCountries(
    request: Empty,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getCountries(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getCountries(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCountriesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getProvincesByCountry(
    request: GetProvincesByCountryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProvincesResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getDistrictsByProvince(
    request: GetDistrictsByProvinceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDistrictsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  getWardsByDistrict(
    request: GetWardsByDistrictRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWardsResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  addAddress(
    request: AddAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  updateAddress(
    request: UpdateAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  deleteAddress(
    request: DeleteAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteAddressResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
  getAddresses(
    request: GetAddressesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAddressesResponse) => void,
  ): ClientUnaryCall;
}

export const AddressServiceClient = makeGenericClientConstructor(
  AddressServiceService,
  "nexuraTelemetry.AddressService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AddressServiceClient;
  service: typeof AddressServiceService;
  serviceName: string;
};

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  getUser: {
    path: "/nexuraTelemetry.UserService/GetUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRequest) => Buffer.from(GetUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserRequest.decode(value),
    responseSerialize: (value: GetUserResponse) => Buffer.from(GetUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserResponse.decode(value),
  },
  updateUser: {
    path: "/nexuraTelemetry.UserService/UpdateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserRequest) => Buffer.from(UpdateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserRequest.decode(value),
    responseSerialize: (value: UpdateUserResponse) => Buffer.from(UpdateUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateUserResponse.decode(value),
  },
  deleteUser: {
    path: "/nexuraTelemetry.UserService/DeleteUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteUserRequest) => Buffer.from(DeleteUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteUserRequest.decode(value),
    responseSerialize: (value: DeleteUserResponse) => Buffer.from(DeleteUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteUserResponse.decode(value),
  },
  registerUser: {
    path: "/nexuraTelemetry.UserService/RegisterUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterUserRequest) => Buffer.from(RegisterUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterUserRequest.decode(value),
    responseSerialize: (value: RegisterUserResponse) => Buffer.from(RegisterUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterUserResponse.decode(value),
  },
  loginUser: {
    path: "/nexuraTelemetry.UserService/LoginUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginUserRequest) => Buffer.from(LoginUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginUserRequest.decode(value),
    responseSerialize: (value: LoginUserResponse) => Buffer.from(LoginUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginUserResponse.decode(value),
  },
  forgotPassword: {
    path: "/nexuraTelemetry.UserService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) => Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse) => Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ForgotPasswordResponse.decode(value),
  },
  validateOtp: {
    path: "/nexuraTelemetry.UserService/ValidateOTP",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateOTPRequest) => Buffer.from(ValidateOTPRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateOTPRequest.decode(value),
    responseSerialize: (value: ValidateOTPResponse) => Buffer.from(ValidateOTPResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateOTPResponse.decode(value),
  },
  resetPassword: {
    path: "/nexuraTelemetry.UserService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest) => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse) => Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResetPasswordResponse.decode(value),
  },
  verifyAccount: {
    path: "/nexuraTelemetry.UserService/VerifyAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyAccountRequest) => Buffer.from(VerifyAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyAccountRequest.decode(value),
    responseSerialize: (value: VerifyAccountResponse) => Buffer.from(VerifyAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyAccountResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  getUser: handleUnaryCall<GetUserRequest, GetUserResponse>;
  updateUser: handleUnaryCall<UpdateUserRequest, UpdateUserResponse>;
  deleteUser: handleUnaryCall<DeleteUserRequest, DeleteUserResponse>;
  registerUser: handleUnaryCall<RegisterUserRequest, RegisterUserResponse>;
  loginUser: handleUnaryCall<LoginUserRequest, LoginUserResponse>;
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  validateOtp: handleUnaryCall<ValidateOTPRequest, ValidateOTPResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  verifyAccount: handleUnaryCall<VerifyAccountRequest, VerifyAccountResponse>;
}

export interface UserServiceClient extends Client {
  getUser(
    request: GetUserRequest,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  getUser(
    request: GetUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  updateUser(
    request: UpdateUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  validateOtp(
    request: ValidateOTPRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateOTPResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResetPasswordResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyAccountResponse) => void,
  ): ClientUnaryCall;
}

export const UserServiceClient = makeGenericClientConstructor(
  UserServiceService,
  "nexuraTelemetry.UserService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): UserServiceClient;
  service: typeof UserServiceService;
  serviceName: string;
};

export type CartServiceService = typeof CartServiceService;
export const CartServiceService = {
  addItem: {
    path: "/nexuraTelemetry.CartService/AddItem",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddItemRequest) => Buffer.from(AddItemRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddItemRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  getCart: {
    path: "/nexuraTelemetry.CartService/GetCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCartRequest) => Buffer.from(GetCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCartRequest.decode(value),
    responseSerialize: (value: Cart) => Buffer.from(Cart.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Cart.decode(value),
  },
  emptyCart: {
    path: "/nexuraTelemetry.CartService/EmptyCart",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyCartRequest) => Buffer.from(EmptyCartRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyCartRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const;

export interface CartServiceServer extends UntypedServiceImplementation {
  addItem: handleUnaryCall<AddItemRequest, Empty>;
  getCart: handleUnaryCall<GetCartRequest, Cart>;
  emptyCart: handleUnaryCall<EmptyCartRequest, Empty>;
}

export interface CartServiceClient extends Client {
  addItem(request: AddItemRequest, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  addItem(
    request: AddItemRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  addItem(
    request: AddItemRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getCart(request: GetCartRequest, callback: (error: ServiceError | null, response: Cart) => void): ClientUnaryCall;
  getCart(
    request: GetCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Cart) => void,
  ): ClientUnaryCall;
  getCart(
    request: GetCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Cart) => void,
  ): ClientUnaryCall;
  emptyCart(
    request: EmptyCartRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  emptyCart(
    request: EmptyCartRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  emptyCart(
    request: EmptyCartRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const CartServiceClient = makeGenericClientConstructor(
  CartServiceService,
  "nexuraTelemetry.CartService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CartServiceClient;
  service: typeof CartServiceService;
  serviceName: string;
};

export type RecommendationServiceService = typeof RecommendationServiceService;
export const RecommendationServiceService = {
  listRecommendations: {
    path: "/nexuraTelemetry.RecommendationService/ListRecommendations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRecommendationsRequest) =>
      Buffer.from(ListRecommendationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListRecommendationsRequest.decode(value),
    responseSerialize: (value: ListRecommendationsResponse) =>
      Buffer.from(ListRecommendationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListRecommendationsResponse.decode(value),
  },
} as const;

export interface RecommendationServiceServer extends UntypedServiceImplementation {
  listRecommendations: handleUnaryCall<ListRecommendationsRequest, ListRecommendationsResponse>;
}

export interface RecommendationServiceClient extends Client {
  listRecommendations(
    request: ListRecommendationsRequest,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
  listRecommendations(
    request: ListRecommendationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
  listRecommendations(
    request: ListRecommendationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRecommendationsResponse) => void,
  ): ClientUnaryCall;
}

export const RecommendationServiceClient = makeGenericClientConstructor(
  RecommendationServiceService,
  "nexuraTelemetry.RecommendationService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RecommendationServiceClient;
  service: typeof RecommendationServiceService;
  serviceName: string;
};

export type ProductCatalogServiceService = typeof ProductCatalogServiceService;
export const ProductCatalogServiceService = {
  createProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductRequest) => Buffer.from(CreateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductRequest.decode(value),
    responseSerialize: (value: CreateProductResponse) => Buffer.from(CreateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductResponse.decode(value),
  },
  updateProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductRequest) => Buffer.from(UpdateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductRequest.decode(value),
    responseSerialize: (value: UpdateProductResponse) => Buffer.from(UpdateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductResponse.decode(value),
  },
  deleteProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductRequest) => Buffer.from(DeleteProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductRequest.decode(value),
    responseSerialize: (value: DeleteProductResponse) => Buffer.from(DeleteProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductResponse.decode(value),
  },
  createVariant: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateVariant",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateVariantRequest) => Buffer.from(CreateVariantRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateVariantRequest.decode(value),
    responseSerialize: (value: CreateVariantResponse) => Buffer.from(CreateVariantResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateVariantResponse.decode(value),
  },
  getProduct: {
    path: "/nexuraTelemetry.ProductCatalogService/GetProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductRequest) => Buffer.from(GetProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductRequest.decode(value),
    responseSerialize: (value: GetProductResponse) => Buffer.from(GetProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductResponse.decode(value),
  },
  listProducts: {
    path: "/nexuraTelemetry.ProductCatalogService/ListProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProductsRequest) => Buffer.from(ListProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListProductsRequest.decode(value),
    responseSerialize: (value: ListProductsResponse) => Buffer.from(ListProductsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListProductsResponse.decode(value),
  },
  createBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBrandRequest) => Buffer.from(CreateBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateBrandRequest.decode(value),
    responseSerialize: (value: CreateBrandResponse) => Buffer.from(CreateBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateBrandResponse.decode(value),
  },
  newBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/NewBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NewBrandRequest) => Buffer.from(NewBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NewBrandRequest.decode(value),
    responseSerialize: (value: NewBrandResponse) => Buffer.from(NewBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NewBrandResponse.decode(value),
  },
  removeBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/RemoveBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveBrandRequest) => Buffer.from(RemoveBrandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveBrandRequest.decode(value),
    responseSerialize: (value: RemoveBrandResponse) => Buffer.from(RemoveBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemoveBrandResponse.decode(value),
  },
  getAllBrand: {
    path: "/nexuraTelemetry.ProductCatalogService/GetAllBrand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAllBrandResponse) => Buffer.from(GetAllBrandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllBrandResponse.decode(value),
  },
  createCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCategoryRequest) => Buffer.from(CreateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCategoryRequest.decode(value),
    responseSerialize: (value: CreateCategoryResponse) => Buffer.from(CreateCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateCategoryResponse.decode(value),
  },
  updateCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCategoryRequest) => Buffer.from(UpdateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateCategoryRequest.decode(value),
    responseSerialize: (value: UpdateCategoryResponse) => Buffer.from(UpdateCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateCategoryResponse.decode(value),
  },
  deleteCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCategoryRequest) => Buffer.from(DeleteCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteCategoryRequest.decode(value),
    responseSerialize: (value: DeleteCategoryResponse) => Buffer.from(DeleteCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteCategoryResponse.decode(value),
  },
  getAllCategory: {
    path: "/nexuraTelemetry.ProductCatalogService/GetAllCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetAllCategoryResponse) => Buffer.from(GetAllCategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllCategoryResponse.decode(value),
  },
  getProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/GetProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductAttributesRequest) =>
      Buffer.from(GetProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductAttributesRequest.decode(value),
    responseSerialize: (value: GetProductAttributesResponse) =>
      Buffer.from(GetProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductAttributesResponse.decode(value),
  },
  updateProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/UpdateProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductAttributesRequest) =>
      Buffer.from(UpdateProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductAttributesRequest.decode(value),
    responseSerialize: (value: UpdateProductAttributesResponse) =>
      Buffer.from(UpdateProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductAttributesResponse.decode(value),
  },
  deleteProductAttributes: {
    path: "/nexuraTelemetry.ProductCatalogService/DeleteProductAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductAttributesRequest) =>
      Buffer.from(DeleteProductAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductAttributesRequest.decode(value),
    responseSerialize: (value: DeleteProductAttributesResponse) =>
      Buffer.from(DeleteProductAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductAttributesResponse.decode(value),
  },
  createProductAttribute: {
    path: "/nexuraTelemetry.ProductCatalogService/CreateProductAttribute",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductAttributeRequest) =>
      Buffer.from(CreateProductAttributeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductAttributeRequest.decode(value),
    responseSerialize: (value: CreateProductAttributeResponse) =>
      Buffer.from(CreateProductAttributeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductAttributeResponse.decode(value),
  },
  getWarehouses: {
    path: "/nexuraTelemetry.ProductCatalogService/GetWarehouses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetWarehousesResponse) => Buffer.from(GetWarehousesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWarehousesResponse.decode(value),
  },
} as const;

export interface ProductCatalogServiceServer extends UntypedServiceImplementation {
  createProduct: handleUnaryCall<CreateProductRequest, CreateProductResponse>;
  updateProduct: handleUnaryCall<UpdateProductRequest, UpdateProductResponse>;
  deleteProduct: handleUnaryCall<DeleteProductRequest, DeleteProductResponse>;
  createVariant: handleUnaryCall<CreateVariantRequest, CreateVariantResponse>;
  getProduct: handleUnaryCall<GetProductRequest, GetProductResponse>;
  listProducts: handleUnaryCall<ListProductsRequest, ListProductsResponse>;
  createBrand: handleUnaryCall<CreateBrandRequest, CreateBrandResponse>;
  newBrand: handleUnaryCall<NewBrandRequest, NewBrandResponse>;
  removeBrand: handleUnaryCall<RemoveBrandRequest, RemoveBrandResponse>;
  getAllBrand: handleUnaryCall<Empty, GetAllBrandResponse>;
  createCategory: handleUnaryCall<CreateCategoryRequest, CreateCategoryResponse>;
  updateCategory: handleUnaryCall<UpdateCategoryRequest, UpdateCategoryResponse>;
  deleteCategory: handleUnaryCall<DeleteCategoryRequest, DeleteCategoryResponse>;
  getAllCategory: handleUnaryCall<Empty, GetAllCategoryResponse>;
  getProductAttributes: handleUnaryCall<GetProductAttributesRequest, GetProductAttributesResponse>;
  updateProductAttributes: handleUnaryCall<UpdateProductAttributesRequest, UpdateProductAttributesResponse>;
  deleteProductAttributes: handleUnaryCall<DeleteProductAttributesRequest, DeleteProductAttributesResponse>;
  createProductAttribute: handleUnaryCall<CreateProductAttributeRequest, CreateProductAttributeResponse>;
  getWarehouses: handleUnaryCall<Empty, GetWarehousesResponse>;
}

export interface ProductCatalogServiceClient extends Client {
  createProduct(
    request: CreateProductRequest,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteProductResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  createVariant(
    request: CreateVariantRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateVariantResponse) => void,
  ): ClientUnaryCall;
  getProduct(
    request: GetProductRequest,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProductResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  listProducts(
    request: ListProductsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProductsResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  createBrand(
    request: CreateBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  newBrand(
    request: NewBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NewBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  removeBrand(
    request: RemoveBrandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RemoveBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  getAllBrand(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllBrandResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  createCategory(
    request: CreateCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  updateCategory(
    request: UpdateCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  deleteCategory(
    request: DeleteCategoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getAllCategory(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllCategoryResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  getProductAttributes(
    request: GetProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  updateProductAttributes(
    request: UpdateProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  deleteProductAttributes(
    request: DeleteProductAttributesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteProductAttributesResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  createProductAttribute(
    request: CreateProductAttributeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateProductAttributeResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
  getWarehouses(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWarehousesResponse) => void,
  ): ClientUnaryCall;
}

export const ProductCatalogServiceClient = makeGenericClientConstructor(
  ProductCatalogServiceService,
  "nexuraTelemetry.ProductCatalogService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ProductCatalogServiceClient;
  service: typeof ProductCatalogServiceService;
  serviceName: string;
};

export type ShippingServiceService = typeof ShippingServiceService;
export const ShippingServiceService = {
  getQuote: {
    path: "/nexuraTelemetry.ShippingService/GetQuote",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetQuoteRequest) => Buffer.from(GetQuoteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetQuoteRequest.decode(value),
    responseSerialize: (value: GetQuoteResponse) => Buffer.from(GetQuoteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetQuoteResponse.decode(value),
  },
  shipOrder: {
    path: "/nexuraTelemetry.ShippingService/ShipOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShipOrderRequest) => Buffer.from(ShipOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ShipOrderRequest.decode(value),
    responseSerialize: (value: ShipOrderResponse) => Buffer.from(ShipOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShipOrderResponse.decode(value),
  },
} as const;

export interface ShippingServiceServer extends UntypedServiceImplementation {
  getQuote: handleUnaryCall<GetQuoteRequest, GetQuoteResponse>;
  shipOrder: handleUnaryCall<ShipOrderRequest, ShipOrderResponse>;
}

export interface ShippingServiceClient extends Client {
  getQuote(
    request: GetQuoteRequest,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  getQuote(
    request: GetQuoteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  getQuote(
    request: GetQuoteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetQuoteResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
  shipOrder(
    request: ShipOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShipOrderResponse) => void,
  ): ClientUnaryCall;
}

export const ShippingServiceClient = makeGenericClientConstructor(
  ShippingServiceService,
  "nexuraTelemetry.ShippingService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ShippingServiceClient;
  service: typeof ShippingServiceService;
  serviceName: string;
};

export type CurrencyServiceService = typeof CurrencyServiceService;
export const CurrencyServiceService = {
  getSupportedCurrencies: {
    path: "/nexuraTelemetry.CurrencyService/GetSupportedCurrencies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: GetSupportedCurrenciesResponse) =>
      Buffer.from(GetSupportedCurrenciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSupportedCurrenciesResponse.decode(value),
  },
  convert: {
    path: "/nexuraTelemetry.CurrencyService/Convert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CurrencyConversionRequest) =>
      Buffer.from(CurrencyConversionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CurrencyConversionRequest.decode(value),
    responseSerialize: (value: Money) => Buffer.from(Money.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Money.decode(value),
  },
} as const;

export interface CurrencyServiceServer extends UntypedServiceImplementation {
  getSupportedCurrencies: handleUnaryCall<Empty, GetSupportedCurrenciesResponse>;
  convert: handleUnaryCall<CurrencyConversionRequest, Money>;
}

export interface CurrencyServiceClient extends Client {
  getSupportedCurrencies(
    request: Empty,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  getSupportedCurrencies(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  getSupportedCurrencies(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSupportedCurrenciesResponse) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
  convert(
    request: CurrencyConversionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Money) => void,
  ): ClientUnaryCall;
}

export const CurrencyServiceClient = makeGenericClientConstructor(
  CurrencyServiceService,
  "nexuraTelemetry.CurrencyService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CurrencyServiceClient;
  service: typeof CurrencyServiceService;
  serviceName: string;
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  charge: {
    path: "/nexuraTelemetry.PaymentService/Charge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChargeRequest) => Buffer.from(ChargeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChargeRequest.decode(value),
    responseSerialize: (value: ChargeResponse) => Buffer.from(ChargeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChargeResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  charge: handleUnaryCall<ChargeRequest, ChargeResponse>;
}

export interface PaymentServiceClient extends Client {
  charge(
    request: ChargeRequest,
    callback: (error: ServiceError | null, response: ChargeResponse) => void,
  ): ClientUnaryCall;
  charge(
    request: ChargeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChargeResponse) => void,
  ): ClientUnaryCall;
  charge(
    request: ChargeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChargeResponse) => void,
  ): ClientUnaryCall;
}

export const PaymentServiceClient = makeGenericClientConstructor(
  PaymentServiceService,
  "nexuraTelemetry.PaymentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PaymentServiceClient;
  service: typeof PaymentServiceService;
  serviceName: string;
};

export type EmailServiceService = typeof EmailServiceService;
export const EmailServiceService = {
  sendOrderConfirmation: {
    path: "/nexuraTelemetry.EmailService/SendOrderConfirmation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendOrderConfirmationRequest) =>
      Buffer.from(SendOrderConfirmationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendOrderConfirmationRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  sendOtpResetPassword: {
    path: "/nexuraTelemetry.EmailService/SendOTPResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendOTPResetPasswordRequest) =>
      Buffer.from(SendOTPResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendOTPResetPasswordRequest.decode(value),
    responseSerialize: (value: SendOTPResetPasswordResponse) =>
      Buffer.from(SendOTPResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendOTPResetPasswordResponse.decode(value),
  },
  sendWelcomeEmail: {
    path: "/nexuraTelemetry.EmailService/SendWelcomeEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendWelcomeEmailRequest) => Buffer.from(SendWelcomeEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendWelcomeEmailRequest.decode(value),
    responseSerialize: (value: SendWelcomeEmailResponse) =>
      Buffer.from(SendWelcomeEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendWelcomeEmailResponse.decode(value),
  },
} as const;

export interface EmailServiceServer extends UntypedServiceImplementation {
  sendOrderConfirmation: handleUnaryCall<SendOrderConfirmationRequest, Empty>;
  sendOtpResetPassword: handleUnaryCall<SendOTPResetPasswordRequest, SendOTPResetPasswordResponse>;
  sendWelcomeEmail: handleUnaryCall<SendWelcomeEmailRequest, SendWelcomeEmailResponse>;
}

export interface EmailServiceClient extends Client {
  sendOrderConfirmation(
    request: SendOrderConfirmationRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendOrderConfirmation(
    request: SendOrderConfirmationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendOrderConfirmation(
    request: SendOrderConfirmationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendOtpResetPassword(
    request: SendOTPResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendOTPResetPasswordResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
  sendWelcomeEmail(
    request: SendWelcomeEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendWelcomeEmailResponse) => void,
  ): ClientUnaryCall;
}

export const EmailServiceClient = makeGenericClientConstructor(
  EmailServiceService,
  "nexuraTelemetry.EmailService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EmailServiceClient;
  service: typeof EmailServiceService;
  serviceName: string;
};

export type CheckoutServiceService = typeof CheckoutServiceService;
export const CheckoutServiceService = {
  placeOrder: {
    path: "/nexuraTelemetry.CheckoutService/PlaceOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlaceOrderRequest) => Buffer.from(PlaceOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PlaceOrderRequest.decode(value),
    responseSerialize: (value: PlaceOrderResponse) => Buffer.from(PlaceOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PlaceOrderResponse.decode(value),
  },
} as const;

export interface CheckoutServiceServer extends UntypedServiceImplementation {
  placeOrder: handleUnaryCall<PlaceOrderRequest, PlaceOrderResponse>;
}

export interface CheckoutServiceClient extends Client {
  placeOrder(
    request: PlaceOrderRequest,
    callback: (error: ServiceError | null, response: PlaceOrderResponse) => void,
  ): ClientUnaryCall;
  placeOrder(
    request: PlaceOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PlaceOrderResponse) => void,
  ): ClientUnaryCall;
  placeOrder(
    request: PlaceOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PlaceOrderResponse) => void,
  ): ClientUnaryCall;
}

export const CheckoutServiceClient = makeGenericClientConstructor(
  CheckoutServiceService,
  "nexuraTelemetry.CheckoutService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CheckoutServiceClient;
  service: typeof CheckoutServiceService;
  serviceName: string;
};

export type AdServiceService = typeof AdServiceService;
export const AdServiceService = {
  getAds: {
    path: "/nexuraTelemetry.AdService/GetAds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdRequest) => Buffer.from(AdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdRequest.decode(value),
    responseSerialize: (value: AdResponse) => Buffer.from(AdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdResponse.decode(value),
  },
} as const;

export interface AdServiceServer extends UntypedServiceImplementation {
  getAds: handleUnaryCall<AdRequest, AdResponse>;
}

export interface AdServiceClient extends Client {
  getAds(request: AdRequest, callback: (error: ServiceError | null, response: AdResponse) => void): ClientUnaryCall;
  getAds(
    request: AdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AdResponse) => void,
  ): ClientUnaryCall;
  getAds(
    request: AdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AdResponse) => void,
  ): ClientUnaryCall;
}

export const AdServiceClient = makeGenericClientConstructor(
  AdServiceService,
  "nexuraTelemetry.AdService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AdServiceClient;
  service: typeof AdServiceService;
  serviceName: string;
};

export type FeatureFlagServiceService = typeof FeatureFlagServiceService;
export const FeatureFlagServiceService = {
  getFlag: {
    path: "/nexuraTelemetry.FeatureFlagService/GetFlag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFlagRequest) => Buffer.from(GetFlagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetFlagRequest.decode(value),
    responseSerialize: (value: GetFlagResponse) => Buffer.from(GetFlagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetFlagResponse.decode(value),
  },
  createFlag: {
    path: "/nexuraTelemetry.FeatureFlagService/CreateFlag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFlagRequest) => Buffer.from(CreateFlagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateFlagRequest.decode(value),
    responseSerialize: (value: CreateFlagResponse) => Buffer.from(CreateFlagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateFlagResponse.decode(value),
  },
  updateFlag: {
    path: "/nexuraTelemetry.FeatureFlagService/UpdateFlag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFlagRequest) => Buffer.from(UpdateFlagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateFlagRequest.decode(value),
    responseSerialize: (value: UpdateFlagResponse) => Buffer.from(UpdateFlagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateFlagResponse.decode(value),
  },
  listFlags: {
    path: "/nexuraTelemetry.FeatureFlagService/ListFlags",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFlagsRequest) => Buffer.from(ListFlagsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListFlagsRequest.decode(value),
    responseSerialize: (value: ListFlagsResponse) => Buffer.from(ListFlagsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListFlagsResponse.decode(value),
  },
  deleteFlag: {
    path: "/nexuraTelemetry.FeatureFlagService/DeleteFlag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteFlagRequest) => Buffer.from(DeleteFlagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteFlagRequest.decode(value),
    responseSerialize: (value: DeleteFlagResponse) => Buffer.from(DeleteFlagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteFlagResponse.decode(value),
  },
} as const;

export interface FeatureFlagServiceServer extends UntypedServiceImplementation {
  getFlag: handleUnaryCall<GetFlagRequest, GetFlagResponse>;
  createFlag: handleUnaryCall<CreateFlagRequest, CreateFlagResponse>;
  updateFlag: handleUnaryCall<UpdateFlagRequest, UpdateFlagResponse>;
  listFlags: handleUnaryCall<ListFlagsRequest, ListFlagsResponse>;
  deleteFlag: handleUnaryCall<DeleteFlagRequest, DeleteFlagResponse>;
}

export interface FeatureFlagServiceClient extends Client {
  getFlag(
    request: GetFlagRequest,
    callback: (error: ServiceError | null, response: GetFlagResponse) => void,
  ): ClientUnaryCall;
  getFlag(
    request: GetFlagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetFlagResponse) => void,
  ): ClientUnaryCall;
  getFlag(
    request: GetFlagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetFlagResponse) => void,
  ): ClientUnaryCall;
  createFlag(
    request: CreateFlagRequest,
    callback: (error: ServiceError | null, response: CreateFlagResponse) => void,
  ): ClientUnaryCall;
  createFlag(
    request: CreateFlagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateFlagResponse) => void,
  ): ClientUnaryCall;
  createFlag(
    request: CreateFlagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateFlagResponse) => void,
  ): ClientUnaryCall;
  updateFlag(
    request: UpdateFlagRequest,
    callback: (error: ServiceError | null, response: UpdateFlagResponse) => void,
  ): ClientUnaryCall;
  updateFlag(
    request: UpdateFlagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateFlagResponse) => void,
  ): ClientUnaryCall;
  updateFlag(
    request: UpdateFlagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateFlagResponse) => void,
  ): ClientUnaryCall;
  listFlags(
    request: ListFlagsRequest,
    callback: (error: ServiceError | null, response: ListFlagsResponse) => void,
  ): ClientUnaryCall;
  listFlags(
    request: ListFlagsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListFlagsResponse) => void,
  ): ClientUnaryCall;
  listFlags(
    request: ListFlagsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListFlagsResponse) => void,
  ): ClientUnaryCall;
  deleteFlag(
    request: DeleteFlagRequest,
    callback: (error: ServiceError | null, response: DeleteFlagResponse) => void,
  ): ClientUnaryCall;
  deleteFlag(
    request: DeleteFlagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteFlagResponse) => void,
  ): ClientUnaryCall;
  deleteFlag(
    request: DeleteFlagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteFlagResponse) => void,
  ): ClientUnaryCall;
}

export const FeatureFlagServiceClient = makeGenericClientConstructor(
  FeatureFlagServiceService,
  "nexuraTelemetry.FeatureFlagService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): FeatureFlagServiceClient;
  service: typeof FeatureFlagServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
